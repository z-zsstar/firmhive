{"name": "command-injection-fcn.00401ac0", "location": "函数 fcn.00401ac0 在地址 0x401bd0 调用 'system'", "description": "在 'hostapd_cli' 中发现一个命令注入漏洞，允许攻击者通过可控输入执行任意命令。攻击链从输入点开始：1) 通过 -a 选项指定的动作文件（用户可控），或 2) 来自 hostapd 的事件消息（可能通过网络攻击间接可控）。数据流通过函数调用传播：主函数处理命令行参数并调用 fcn.00401f64（非交互模式）或 fcn.00402168（交互模式），最终到达 fcn.00401c30，该函数读取消息并调用 fcn.00401ac0。在 fcn.00401ac0 中，用户输入（param_1）被用于构建命令字符串（格式：\"%s %s %s\"），并直接传递给 'system' 函数，缺少输入验证和清理。触发条件包括：使用 -a 选项运行 hostapd_cli 并指定恶意动作文件，或诱使 hostapd 发送恶意事件消息。可利用性高，因为攻击者可以注入 shell 命令，例如通过插入分号或反引号来执行任意命令。", "link_identifiers": ["动作文件路径（-a 选项）", "hostapd 事件消息", "全局变量 *0x418ab0 和 *0x418ab4"], "code_snippet": "void fcn.00401ac0(char *param_1) {\n    // ... 代码简化 ...\n    if (*param_1 == '<') {\n        iVar1 = strchr(param_1, '>');\n        pcVar6 = iVar1 + 1;\n        if (iVar1 == 0) {\n            pcVar6 = param_1;\n        }\n    }\n    uVar8 = *0x418ab0;\n    uVar7 = *0x418ab4;\n    // 构建命令字符串\n    uVar4 = snprintf(iVar1, uVar5, \"%s %s %s\", uVar8, uVar7, pcVar6);\n    if ((-1 < uVar4) && (uVar4 < uVar5)) {\n        system(iVar1);\n    }\n    // ...\n}", "risk_score": 8.5, "confidence": 9.0, "notes": "攻击链依赖于用户控制动作文件或 hostapd 事件消息。建议进一步验证动作文件处理逻辑和 hostapd 事件消息的来源。相关函数包括 fcn.00401c30 和 fcn.00401f64。后续分析应检查动作文件读取代码和 hostapd 通信机制。", "file_path": "sbin/hostapd_cli"}
{"name": "BufferOverflow-do_command", "location": "Function do_command at address 0x00407ed4", "description": "A buffer overflow vulnerability exists in the do_command function of iptables-multi when processing the -j (jump target) option. The attack chain is as follows:\n1. **Input Point**: Command-line arguments passed to iptables-multi, specifically the string value for the -j option (e.g., iptables -j <long_string>).\n2. **Data Flow**: The command-line argument for -j is stored in the variable var_160h during option parsing. This variable is later used as the source for a strcpy operation.\n3. **Vulnerable Operation**: At address 0x00407ed4, strcpy is called to copy the string from var_160h into a heap-allocated buffer (pointed to by s4+0x38). The buffer is allocated with xtables_calloc based on the size of the target structure (s0 + 0x20), but no bounds checking is performed. If the -j string exceeds this size, strcpy will overflow the buffer.\n4. **Trigger Condition**: The vulnerability is triggered when the -j option is used with a string longer than the allocated buffer size (which depends on the target structure but is typically fixed).\n5. **Exploitable Analysis**: This is exploitable because strcpy does not check buffer boundaries, allowing an attacker to overwrite adjacent heap metadata or function pointers. Given that iptables-multi often runs as root, successful exploitation could lead to privilege escalation or remote code execution if iptables is exposed to untrusted inputs (e.g., via network configuration scripts).", "link_identifiers": ["iptables-multi", "-j option", "var_160h"], "code_snippet": "0x00407ecc      8f99804c       lw t9, -sym.imp.strcpy(gp)  ; [0x40cee0:4]=0x8f998010\n0x00407ed0      8fa50160       lw a1, (var_160h)\n0x00407ed4      0320f809       jalr t9\n0x00407ed8      24840002       addiu a0, a0, 2", "risk_score": 8.5, "confidence": 8.0, "notes": "The vulnerability is based on evidence from disassembly, but further analysis of the heap allocation size and potential overwrites would strengthen the exploitability assessment. The function fcn.00405d7c (which sets var_160h) should be analyzed to confirm the data flow from command-line arguments. Additionally, similar strcpy uses exist for other options (e.g., -m for matches), so multiple vectors may be present.", "file_path": "sbin/iptables-multi"}
{"name": "XSS-setTagStr", "location": "在 `setTagStr` 函数中，具体代码行包括 `obj.getElementById(tag).innerHTML = str_pages[page][tag];` 和 `items[i].innerHTML = str_pages[page][tag];`", "description": "在 `setTagStr` 函数中存在跨站脚本（XSS）漏洞。攻击链：不可信输入源（`parent.pages_js[page][tag]` 或 `parent.str_main.btn[btn]`） -> 数据流（通过 `setTagStr` 函数传播） -> 危险操作（直接赋值给 `innerHTML`）。触发条件：当 `setTagStr` 函数被调用时，如果 `parent.pages_js` 或 `parent.str_main` 包含恶意数据。可利用性分析：代码中直接使用 `innerHTML` 赋值而没有输入编码或过滤，允许攻击者注入并执行任意 JavaScript 代码，例如窃取会话或执行恶意操作。", "link_identifiers": ["parent.pages_js", "parent.str_main", "setTagStr", "innerHTML"], "code_snippet": "for ( tag in str_pages[page] ) {\n    try {\n        if(!window.ActiveXObject) {\n            items = obj.getElementsByName(tag);\n            if(items.length > 0) {\n                for(i = 0; i < items.length; i++) {\n                    items[i].innerHTML = str_pages[page][tag];\n                }\n            } else {\n                obj.getElementById(tag).innerHTML = str_pages[page][tag];\n            }\n        } else {\n            items = obj.all[tag];\n            if(undefined != items.length && items.length > 0) {\n                for(i = 0; i < items.length; i++) {\n                    items[i].innerHTML = str_pages[page][tag];\n                }\n            } else {\n                items.innerHTML = str_pages[page][tag];\n            }\n        }\n    } catch(e) {\n        continue;\n    }\n}", "risk_score": 8.5, "confidence": 9.0, "notes": "这个漏洞的利用依赖于 `setTagStr` 函数被调用且输入数据可控。建议检查调用 `setTagStr` 的代码路径，以确认输入源是否确实不可信。此外，应考虑对所有动态内容进行输出编码以防止 XSS。其他函数（如 `LoadHelp` 和 `LoadNext`）可能涉及开放重定向，但缺乏完整攻击链证据。", "file_path": "web/dynaform/common.js"}
{"name": "buffer-overflow-SAME_parse", "location": "Function SAME_parse in libipt_SAME.so, specifically the code handling the --to option when the range count is 9.", "description": "A buffer overflow vulnerability exists in the SAME_parse function when processing the --to IP range option. The attack chain is as follows: 1) Attacker provides malicious input via the --to command-line argument when adding an iptables rule with the SAME target. 2) The input is parsed and stored in a structure that holds up to 10 IP ranges. 3) When the 10th range is added, the code writes data beyond the allocated buffer due to an off-by-one error in index calculation. Specifically, for the 10th range (index 9), it writes a flag to offset iVar9 + 160 (where the buffer ends at iVar9 + 159) and IP addresses to offsets iVar9 + 164 and iVar9 + 168. These writes are attacker-controlled as they derive from user-supplied IP addresses. The trigger condition is exactly 10 --to options specified in the rule. This is exploitable because the out-of-bounds writes can corrupt adjacent memory structures, such as function pointers or heap metadata, potentially leading to code execution when iptables is invoked with elevated privileges.", "link_identifiers": ["iptables command-line arguments (--to)", "NVRAM variables related to firewall rules (if stored)"], "code_snippet": "From SAME_parse decompilation:\n- iVar7 = *param_6;\n- iVar9 = iVar7 + 0x20; // Base of IP range array\n- iVar1 = *(iVar7 + 0x24); // Current range count\n- if (iVar1 == 10) goto error; // Max check\n- puVar4 = iVar9 + (iVar1 + 1) * 0x10; // For iVar1=9, puVar4 = iVar9 + 160\n- *puVar4 = *puVar4 | 1; // Write flag out-of-bounds\n- iVar10 = iVar9 + (iVar1 + 1) * 0x10; // iVar10 = iVar9 + 160\n- *(iVar10 + 4) = first_IP; // Write to iVar9 + 164\n- if (second_IP exists) {\n    *(iVar9 + iVar1 * 0x10 + 0x18) = second_IP; // For iVar1=9, write to iVar9 + 168\n  }\n- *(iVar7 + 0x24) = iVar1 + 1; // Increment count", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability requires the iptables command to be run with the SAME target and exactly 10 --to options. Further verification could involve dynamic testing to confirm memory corruption and exploitability. The structure ipt_same_info likely has a fixed-size array for IP ranges, and the out-of-bounds writes could affect adjacent heap or stack data. Related functions: SAME_check, SAME_save, but the issue is primarily in SAME_parse.", "file_path": "lib/libexec/xtables/libipt_SAME.so"}
{"name": "command-injection-wpa_cli", "location": "fcn.00405224 at address 0x405188 (system call)", "description": "A command injection vulnerability exists in 'wpa_cli' where user-controlled data from wpa_supplicant events (e.g., SSID from network connections) is incorporated into a command string without proper sanitization, leading to arbitrary command execution. Attack chain: Attacker sets up a malicious Wi-Fi network with a crafted SSID containing command injection payload -> Victim connects to the network -> wpa_supplicant sends a 'CTRL-EVENT-CONNECTED' event including the SSID -> wpa_cli processes the event and constructs a command string using the format '%s %s %s' with the SSID as one of the arguments -> The command string is executed via system() -> Arbitrary commands are executed with the privileges of wpa_cli. Trigger condition: wpa_cli must be running and receive a wpa_supplicant event (e.g., upon network connection). Exploitable due to lack of input sanitization for shell metacharacters in the event data.", "link_identifiers": ["/var/run/wpa_supplicant"], "code_snippet": "// From decompilation of fcn.00405224\nelse {\n    // ... after building the command string\n    uVar3 = (**(loc._gp + -0x7ecc))(iVar4, uVar10, 0x40bd50, uVar7, uVar9, pcVar11); // sprintf-like call with format \"%s %s %s\"\n    // ...\n    pcVar12 = *(loc._gp + -0x7e50); // sym.imp.system\n    iVar1 = (*pcVar12)(iVar4); // system(iVar4)\n}", "risk_score": 8.5, "confidence": 9.0, "notes": "Assumption: The wpa_supplicant event string contains user-controlled data like SSID. Further verification could involve dynamic testing with crafted events. Related functions: fcn.004051bc (string comparison), main (initialization).", "file_path": "sbin/wpa_cli"}
{"description": "在 'iwlist' 的扫描功能中发现一个栈缓冲区溢出漏洞。攻击链如下：\n- **输入点**：命令行参数，特别是 'scanning essid' 选项后的用户提供的 ESSID 字符串。\n- **数据流**：用户输入通过 main 函数传递到扫描处理函数 fcn.00403b78。在处理 'essid' 选项时，代码使用 `strncpy` 将用户字符串复制到栈缓冲区 `auStack_3bc`（大小 296 字节），但第三个参数设置为源字符串长度（通过 `strlen` 获取），而不是缓冲区大小。如果用户字符串长度超过 296 字节，`strncpy` 会复制超过缓冲区大小的数据，导致栈溢出。\n- **触发条件**：运行命令 `iwlist scanning essid <long_string>`，其中 `<long_string>` 长度超过 296 字节。\n- **可利用性分析**：溢出可能覆盖返回地址或局部变量，允许攻击者控制程序流并执行任意代码。缺少边界检查是根本原因，且漏洞可通过命令行直接触发。", "link_identifiers": ["命令行参数", "ESSID 字符串"], "location": "函数 fcn.00403b78（扫描处理函数）中处理 'essid' 选项的代码区域", "code_snippet": "// 从反编译代码中提取的相关片段\nuStack_3cf = (**(loc._gp + -0x7f2c))(pcVar10); // strlen 获取用户字符串长度\n(**(loc._gp + -0x7ef0))(auStack_3bc, pcVar10, uStack_3cf); // strncpy 使用源长度作为 n，导致溢出\n// auStack_3bc 是栈缓冲区，定义为 uchar auStack_3bc [296]", "risk_score": 8.5, "confidence": 9.0, "notes": "基于反编译证据，漏洞可利用性高。建议进一步验证其他命令处理函数（如 encryption、keys）是否存在类似问题。后续分析可关注动态内存分配和 IOCTL 调用中的安全问题。", "file_path": "sbin/iwlist"}
{"name": "信息暴露-ChangeLoginPwdRpm表单", "location": "HTML 表单定义（FORM 标签），第 3 行：<FORM action=\"ChangeLoginPwdRpm.htm\" enctype=\"multipart/form-data\" method=\"get\" onSubmit=\"return doSubmit();\">", "description": "表单使用 GET 方法提交密码更改请求，导致敏感信息（如旧密码、新密码）以明文形式暴露在 URL 查询字符串中。攻击链：攻击者通过拦截网络流量、访问浏览器历史或服务器日志，可获取密码信息。触发条件为用户提交表单。可利用性分析：这是由于缺少对敏感操作使用 POST 方法的保护，攻击者可直接利用此问题窃取凭证。", "link_identifiers": ["oldname", "oldpassword", "newname", "newpassword", "newpassword2", "ChangeLoginPwdRpm.htm"], "code_snippet": "<FORM action=\"ChangeLoginPwdRpm.htm\" enctype=\"multipart/form-data\" method=\"get\" onSubmit=\"return doSubmit();\">\n  ...\n  <INPUT class=\"textS\" type=\"password\" maxlength=\"14\" size=\"15\" name=\"oldpassword\">\n  <INPUT class=\"textS\" type=\"password\" maxlength=\"14\" size=\"15\" name=\"newpassword\">\n  ...\n</FORM>", "risk_score": 5.0, "confidence": 7.0, "notes": "此风险依赖于攻击者能访问网络流量或日志；建议验证后端是否使用 POST 方法处理请求。客户端验证（doSubmit 函数）可能被绕过，但无后端证据表明存在注入或其他漏洞。", "file_path": "web/userRpm/ChangeLoginPwdRpm.htm"}
{"name": "BufferOverflow-parse_target", "location": "function parse_target in libipt_SET.so", "description": "A buffer overflow vulnerability exists in the parse_target function of libipt_SET.so, which handles command-line parsing for the iptables SET target. The attack chain begins when an attacker provides a set name via the --add-set or --del-set command-line option. The set name is passed to parse_target, where its length is checked (must be less than 32 bytes). If the condition is met, strncpy is called with a size of 32 bytes to copy the set name into a stack buffer aiStack_48, which is only 30 bytes (defined as int16_t aiStack_48[15]). This results in a 2-byte overflow, potentially overwriting adjacent stack variables, saved registers, or the return address. The vulnerability is exploitable because it allows controlled data to corrupt stack memory, which could lead to denial of service or code execution, especially since iptables may run with elevated privileges. The trigger condition is precise: the set name must have a length between 0 and 31 characters inclusive.", "link_identifiers": ["--add-set", "--del-set"], "code_snippet": "uVar4 = strlen(unaff_s2);\nif (uVar4 < 0x20) {\n    // ...\n    strncpy(aiStack_48, unaff_s2, 0x20); // aiStack_48 is defined as int16_t aiStack_48[15] (30 bytes)\n}", "risk_score": 7.5, "confidence": 9.0, "notes": "The overflow is limited to 2 bytes, which may constrain exploitation, but on MIPS architecture, it could still be leveraged for code execution or denial of service. Further analysis of the stack layout is recommended to determine the exact impact. Related functions like SET_check and SET_parse should be reviewed for additional issues.", "file_path": "lib/libexec/xtables/libipt_SET.so"}
{"name": "info-disclosure-parse-print_multiurl", "location": "dbg.parse function at addresses 0x00000bd8 (strncpy call) and dbg.print_multiurl function at 0x00000988 (printf call)", "description": "The vulnerability involves improper null termination when copying URL strings using strncpy in the parse function, leading to buffer over-read when printing the URLs. Attack chain: 1) Attacker provides a URL string of length between 1-30 bytes via iptables command-line configuration; 2) The parse function uses strncpy with n=len (where len < 31) to copy the URL into a 31-byte buffer without ensuring null termination; 3) When the print_multiurl function uses printf(\"%s\") on the non-null-terminated buffer, it reads beyond the buffer until a null byte is found, leaking adjacent memory contents. This is exploitable for information disclosure as attackers can control the input and trigger the over-read to extract sensitive data from memory.", "link_identifiers": ["iptables command-line arguments for --urls option"], "code_snippet": "Parse function strncpy usage:\n0x00000bd8      8f99804c       lw t9, -sym.imp.strncpy(gp) ; [0xd30:4]=0x8f998010\n0x00000bdc      02202821       move a1, s1\n0x00000be0      0320f809       jalr t9\n0x00000be4      02602021       move a0, s3\n\nPrint function printf usage:\n0x00000988      8f99803c       lw t9, -sym.imp.printf(gp) ; [0xd60:4]=0x8f998010\n0x0000098c      02202821       move a1, s1\n0x00000990      0320f809       jalr t9\n0x00000994      02602021       move a0, s3 ; 0xe5c ; \"%s\"", "risk_score": 7.5, "confidence": 9.0, "notes": "The vulnerability is specific to the multiurl iptables module and requires the module to be loaded and used. Further analysis could involve testing with actual iptables rules to confirm exploitability. No other critical vulnerabilities were identified in the limited functions analyzed.", "file_path": "lib/libexec/xtables/libipt_multiurl.so"}
{"name": "BufferOverflow-athr_gmac_recv_packets", "location": "Function sym.athr_gmac_recv_packets at address 0x08005bb4, in the loop where 'uVar12' is decremented from 0x20 to 0.", "description": "A stack buffer overflow vulnerability exists in 'sym.athr_gmac_recv_packets' due to missing bounds checks when indexing a local stack array. The attack chain is: (1) Attacker sends a malicious network packet that is passed to this function via 'param_1'; (2) The function processes the packet in a loop where 'uVar12' (initialized to 0x20) is decremented; (3) When 'uVar12' is odd, 'iVar5' becomes 12, causing writes to 'auStack_40[12]' (out-of-bounds, as the array has only 6 elements); (4) The written data ('*puVar9') is derived from 'param_1[0x1d] + iVar13 * 0xc', which is attacker-controlled; (5) This corrupts adjacent stack data, including potential return addresses, enabling code execution. Trigger condition: The function is called with 'param_1' where '*(param_1 + 4) != 0' and avoids early error traps (e.g., 'uVar12 >= 1'). Exploitability is high due to direct control over written data and stack corruption.", "link_identifiers": ["sym.athr_gmac_recv_packets", "param_1"], "code_snippet": "// Relevant code from decompilation\nulong sym.athr_gmac_recv_packets(int32_t *param_1) {\n    // ...\n    uint32_t auStack_40 [6]; // 6-element stack buffer (24 bytes)\n    uVar12 = 0x20;\n    // ...\n    iVar5 = (uVar12 & 1) * 0xc; // iVar5 can be 0 or 12\n    *(auStack_40 + iVar5) = *puVar9; // Out-of-bounds write when iVar5=12 (beyond buffer)\n    // Similar issues with iVar6 and iVar3\n    iVar6 = 0xc;\n    if ((uVar12 & 1) != 0) {\n        iVar6 = 0;\n    }\n    *(auStack_40 + iVar6) = *puVar9; // Potential out-of-bounds\n    // ...\n}", "risk_score": 8.0, "confidence": 8.0, "notes": "Decompilation has warnings, but the vulnerability logic is clear and supported by evidence. Assumes 'param_1' is derived from external network input. Further validation could involve tracing callers to confirm the input source or examining the binary for exact stack layout. No other high-risk vulnerabilities were found in this function.", "file_path": "lib/modules/2.6.31/net/ag7240_mod.ko"}
{"name": "format-string-tproxy_tg_print", "location": "函数 dbg.tproxy_tg_print 中的 printf 调用（地址 0x00000a14-0x00000a18）", "description": "在 tproxy_tg_print 函数中发现格式字符串漏洞。完整攻击链如下：\n- **不可信输入源**：攻击者通过网络接口（如 HTTP API 或命令行）配置 iptables TPROXY 规则，控制规则中的 IP 地址字段（例如，通过 '--on-ip' 参数）。\n- **数据流传播**：\n  1. 在规则配置阶段，用户提供的 IP 地址字符串被解析并存储在 xt_entry_target 结构的偏移 0x28 处。\n  2. 当规则被打印时（例如，通过 'iptables -L' 命令），tproxy_tg_print 函数被调用。\n  3. 函数使用 xtables_ipaddr_to_numeric 将 IP 地址字符串转换为数值（uVar1），但该数值被错误地传递给 printf 的 %s 格式符。\n  4. printf 使用固定格式字符串 \"TPROXY redirect %s:%u mark 0x%x/0x%x\"，其中 %s 期望字符串指针，但实际接收 uVar1（数值），导致将数值解引用为指针，读取任意内存地址。\n- **精确触发条件**：攻击者配置恶意 iptables TPROXY 规则后，任何触发规则打印的操作（如 'iptables -L'）都会执行漏洞代码。\n- **可利用性分析**：攻击者可完全控制 uVar1 的值（通过设置 IP 地址字符串，覆盖 32 位地址空间），使 %s 读取任意内存，泄露敏感信息（如密码、密钥）。漏洞缺少输入验证和类型检查，导致实际可利用的信息泄露。", "link_identifiers": ["iptables规则配置", "TPROXY", "--on-ip", "dbg.tproxy_tg_print", "printf"], "code_snippet": "void dbg.tproxy_tg_print(uint param_1, int32_t param_2) {\n    uint uVar1;\n    int32_t in_t9;\n    int32_t iVar2;\n    \n    iVar2 = 0x189d8 + in_t9;\n    uVar1 = (**(iVar2 + -0x7fb8))(param_2 + 0x28);  // Convert IP to numeric\n    (**(iVar2 + -0x7fbc))(*(iVar2 + -0x7fdc) + 0xf60, uVar1, *(param_2 + 0x2c), *(param_2 + 0x24), *(param_2 + 0x20));  // printf with format string \"TPROXY redirect %s:%u mark 0x%x/0x%x\"\n    return;\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "漏洞依赖于攻击者能配置 iptables 规则，在固件中可能通过 web 界面或网络 API 实现。建议检查规则配置接口的访问控制。后续可分析其他输出函数或规则处理组件以识别类似问题。反编译代码基于 r2 工具，证据可靠。", "file_path": "lib/libexec/xtables/libxt_TPROXY.so"}
{"name": "NullPtr-DoS-__adf_net_dev_tx", "location": "adf.ko:0x08000d70 [__adf_net_dev_tx]", "description": "在 `__adf_net_dev_tx` 函数中存在空指针解引用漏洞。攻击链：攻击者发送网络数据包到目标设备 → 驱动调用 `ndo_start_xmit`（指向 `__adf_net_dev_tx`）→ 函数检查 `*(param_1 + 4)`（设备状态）是否为0 → 如果为0，则执行 `(*NULL)(0)`，解引用空指针 → 导致内核崩溃。触发条件是设备未正确初始化或状态为0。可利用性分析：这是一个明确的逻辑缺陷，缺少空指针检查，攻击者可通过发送数据包到脆弱设备触发DoS。", "link_identifiers": ["__adf_net_dev_tx", "ndo_start_xmit"], "code_snippet": "uint sym.__adf_net_dev_tx(int32_t param_1,int32_t param_2)\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 4);\n    if (iVar1 == 0) {\n        (*NULL)(0);\n        param_2 = 0;\n        (*NULL)(0,param_2,0xa4,0,0x1ea);\n        (*NULL)();\n        iVar1 = (*NULL)(0);\n    }\n    *(param_2 + 0x18) = iVar1;\n    (*NULL)();\n    return 0;\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "漏洞依赖于设备状态，可能需特定初始化条件。建议检查调用此函数的模块以确认攻击面。", "file_path": "lib/modules/2.6.31/net/adf.ko"}
{"name": "NullPtr-DoS-__adf_net_indicate_packet", "location": "adf.ko:0x08000ad4 [__adf_net_indicate_packet]", "description": "在 `__adf_net_indicate_packet` 函数中存在空指针解引用漏洞。攻击链：攻击者发送恶意网络数据包 → 驱动调用数据包指示函数（如 `__adf_net_indicate_packet`）→ 函数检查 `*(param_2 + 100)` 的标志 → 如果满足条件，则执行 `(*NULL)(0)` 和 `(*NULL)(param_2,iVar7)`，解引用空指针 → 导致内核崩溃。触发条件是数据包具有特定标志（如 VLAN 处理）。可利用性分析：缺少输入验证和空指针检查，攻击者可构造数据包触发崩溃。", "link_identifiers": ["__adf_net_indicate_packet", "sk_buff"], "code_snippet": "uint sym.__adf_net_indicate_packet(int32_t param_1,int32_t param_2)\n{\n    // ... 代码省略 for brevity\n    if ((*(param_2 + 100) & 0x30000000) == 0x10000000) {\n        if (*(*(param_2 + 0x98) + 4) == 0) {\n            iVar1 = *(param_2 + 0xa0);\n        }\n        else {\n            (*NULL)(0,0,0xb8,0,0x1ac);\n            (*NULL)();\n            iVar1 = (*NULL)(0);\n        }\n        // ... 更多代码\n    }\n    uVar3 = (*NULL)(param_2,iVar7);\n    // ...\n}", "risk_score": 7.0, "confidence": 8.0, "notes": "漏洞涉及复杂条件，需进一步验证数据包构造。相关函数如 `__adf_net_vlan_add` 可能交互。", "file_path": "lib/modules/2.6.31/net/adf.ko"}
{"name": "Null-Pointer-Dereference-asf_print_new", "location": "0x08000adc in asf_print_new function", "description": "Null pointer dereference in asf_print_new function leads to kernel panic when called. The function attempts to call a function pointer at address NULL (0x0), which is invalid in kernel space, causing a system crash. This is a denial-of-service vulnerability that can be triggered by any code that calls the exported symbol asf_print_new.", "link_identifiers": ["asf_print_new"], "code_snippet": "iVar1 = (*NULL)(0,0xc,0);", "risk_score": 7.5, "confidence": 9.0, "notes": "This vulnerability is easily triggerable if the function is called, resulting in immediate kernel panic. No additional conditions are required. Found in function asf_print_new.", "file_path": "lib/modules/2.6.31/net/asf.ko"}
{"name": "Null-Pointer-Dereference-asf_amem_create", "location": "0x08000d98 in asf_amem_create function", "description": "Null pointer dereference in asf_amem_create function when param_9 is non-zero. The function calls a function pointer at NULL, leading to kernel panic. This can be triggered by calling asf_amem_create with a non-zero param_9 argument.", "link_identifiers": ["asf_amem_create"], "code_snippet": "if (param_9 != 0) {\n    (*NULL)(param_9,0x38,0);\n    halt_baddata();\n}", "risk_score": 7.5, "confidence": 9.0, "notes": "Requires param_9 != 0 to trigger. Results in denial of service. Found in function asf_amem_create.", "file_path": "lib/modules/2.6.31/net/asf.ko"}
{"name": "StackOverflow-msglogd", "location": "函数 msglogd 的偏移地址 0x00000810（在反编译代码中 vsprintf 调用点）", "description": "在 'libmsglog.so' 的 msglogd 函数中，发现栈缓冲区溢出漏洞。攻击链如下：不可信输入通过参数 param_3（格式字符串）和 param_4（参数）传入函数。在代码中，首先使用 vsprintf 格式化固定字符串到栈缓冲区 auStack_274（500字节），然后使用 strlen 获取当前长度，再次使用 vsprintf 将用户控制的 param_3 和 param_4 追加到同一缓冲区，起始位置为 auStack_274 + iVar1。由于 vsprintf 不检查缓冲区边界，如果用户提供的格式字符串和参数导致总长度超过500字节，就会发生栈缓冲区溢出。溢出可能覆盖返回地址或其他栈数据，允许攻击者执行任意代码。触发条件为：调用 msglogd 时，param_1 必须介于 0 到 7 之间，param_2 必须为 0 或 8 到 13（即 8、9、10、11、12、13）。可利用性分析：缺少边界检查，且溢出在栈上，攻击者可通过精心构造的 param_3 和 param_4 控制执行流。", "link_identifiers": ["param_3", "param_4", "auStack_274"], "code_snippet": "void sym.msglogd(int32_t param_1,int32_t param_2,uint param_3,uint param_4) {\n    // ... 局部变量定义\n    if ((param_2 == 0) || ((7 < param_2 && (param_2 < 0xe)))) {\n        if ((*&iStackX_0 < 0) || (7 < *&iStackX_0)) {\n            // 错误处理\n        } else {\n            (**(iVar4 + -0x7fbc))(auStack_274,0,500); // memset 清空缓冲区\n            (**(iVar4 + -0x7fc0))(auStack_274,*(iVar4 + -0x7fdc) + 0xca0,*&iStackX_0,iStackX_4 + 0x30,*&iStackX_0 + 0x30); // 第一次 vsprintf\n            iVar1 = (**(iVar4 + -0x7fa8))(auStack_274); // strlen\n            puStack_10 = &uStackX_c;\n            (**(iVar4 + -0x7fb0))(auStack_274 + iVar1,uStackX_8,puStack_10); // 第二次 vsprintf，使用 param_3 和 param_4\n            // ... 其他代码\n        }\n    }\n}", "risk_score": 8.5, "confidence": 8.0, "notes": "此漏洞依赖于 msglogd 函数被外部组件调用时参数 param_3 和 param_4 来自不可信源（如网络输入或 IPC）。建议进一步分析调用 msglogd 的组件以验证输入点。漏洞利用可能需考虑 MIPS 架构的栈布局和绕过保护机制。", "file_path": "lib/libmsglog.so"}
{"name": "XSS-setTagStr", "location": "在 `setTagStr` 函数中，具体代码行包括：`items[i].innerHTML = str_pages[page][tag];`、`obj.getElementById(tag).innerHTML = str_pages[page][tag];` 和 `items.innerHTML = str_pages[page][tag];`", "description": "在 `setTagStr` 函数中存在跨站脚本（XSS）漏洞，攻击链完整且可验证：\n- **输入可控性**：`str_pages` 和 `str_main` 变量分别从 `parent.pages_js` 和 `parent.str_main` 初始化（见文件开头代码），这些来自父窗口，攻击者可通过恶意网页或注入控制其内容。\n- **路径可达性**：当 `setTagStr` 函数被调用时（例如通过页面加载或事件触发），它会遍历 `str_pages[page]` 中的标签，并直接赋值给 `innerHTML`。代码中没有条件阻止此路径，只要函数被调用且输入存在，漏洞即可触发。\n- **实际影响**：直接使用 `innerHTML` 赋值而没有编码或过滤，允许攻击者注入并执行任意 JavaScript 代码，导致会话窃取、恶意操作等安全损害。\n- **触发条件**：调用 `setTagStr` 函数并传递可控的 `page` 参数，且 `parent.pages_js` 或 `parent.str_main` 包含恶意数据。", "link_identifiers": ["parent.pages_js", "parent.str_main", "str_pages", "str_main"], "code_snippet": "var str_pages = parent.pages_js;\nvar str_main = parent.str_main;\n\nfunction setTagStr(obj,page) {\n    // ... 省略部分代码\n    for ( tag in str_pages[page] ) {\n        try {\n            if(!window.ActiveXObject) {\n                items = obj.getElementsByName(tag);\n                if(items.length > 0) {\n                    for(i = 0; i < items.length; i++) {\n                        items[i].innerHTML = str_pages[page][tag];\n                    }\n                } else {\n                    obj.getElementById(tag).innerHTML = str_pages[page][tag];\n                }\n            } else {\n                items = obj.all[tag];\n                if(undefined != items.length && items.length > 0) {\n                    for(i = 0; i < items.length; i++) {\n                        items[i].innerHTML = str_pages[page][tag];\n                    }\n                } else {\n                    items.innerHTML = str_pages[page][tag];\n                }\n            }\n        } catch(e) {\n            continue;\n        }\n    }\n    // ... 省略部分代码\n}", "risk_score": 8.5, "confidence": 9.5, "notes": "证据来自文件 'web/dynaform/common.js' 的直接分析。漏洞可利用性高，因为输入源明确可控且没有防护措施。建议检查调用 `setTagStr` 函数的上下文以确定具体攻击面。无需进一步分析此文件，验证已完成。", "file_path": "web/dynaform/common.js", "stage": "verify_XSS-setTagStr"}
