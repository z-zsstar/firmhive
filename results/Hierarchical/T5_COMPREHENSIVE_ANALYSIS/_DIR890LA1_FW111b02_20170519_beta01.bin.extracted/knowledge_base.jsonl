{"name": "static-init-S19init-script", "file_path": "etc/init.d/S19init.sh", "location": "S19init.sh:1-4", "risk_score": 0.0, "confidence": 5.0, "description": "The S19init.sh script performs purely static initialization operations: creates the /var directory structure and writes predefined content to resolv.conf/TZ/hosts files. It contains no variable processing, input reception, or external interaction logic. Specific behaviors: 1) No calls to nvram_get/set or other environment variable operations 2) No network/IPC interfaces 3) All operations based on hardcoded paths and content 4) No usage of dangerous commands like eval/system. This script has no trigger conditions, does not constitute any attack vector component, and has zero security impact.", "code_snippet": "mkdir -p /var/etc...\necho -n > /var/etc/resolv.conf\necho -n > /var/TZ\necho \"127.0.0.1 hgw\" > /var/hosts", "link_identifiers": ["mkdir", "echo", "/var/etc/resolv.conf", "/var/TZ", "/var/hosts"], "notes": "Recommend analyzing scripts that handle dynamic inputs (such as network service startup scripts) or binary components."}
{"name": "init-script-udevd-start", "file_path": "etc/init.d/S15udevd.sh", "location": "etc/init.d/S15udevd.sh", "risk_score": 0.5, "confidence": 4.95, "description": "The S15udevd.sh script is a static initialization script that performs only the following actions: 1) Mounts tmpfs to the /dev directory, 2) Creates the /dev/net directory, 3) Starts the udevd daemon, and 4) Executes udevstart to initialize devices. It contains no input processing logic (does not accept HTTP/API/UART inputs) and does not manipulate environment variables/NVRAM. While the script itself has no externally triggerable vulnerabilities, the udevd service it launches (which handles hotplug device events) could potentially serve as an attack entry point.", "code_snippet": "udevd --daemon\nudevstart", "link_identifiers": ["mount", "mkdir", "udevd", "udevstart", "/dev", "/dev/pts", "/dev/net"], "notes": "Recommended follow-up deep analysis: 1) The device event handling logic of /sbin/udevd 2) The initialization process of /sbin/udevstart 3) How udev rule files (/etc/udev/rules.d) filter external device inputs. These components may form an exploitable path from physical device interfaces to kernel operations."}
{"name": "script-udev-start_script", "file_path": "etc/init.d/S23udevd.sh", "location": "etc/init.d/S23udevd.sh:0", "risk_score": 0.0, "confidence": 8.75, "description": "S23udevd.sh is the startup script for the udev service, executing the /sbin/udevstart program during system initialization. The script itself does not process any external inputs (such as environment variables, parameters, or configuration files) nor performs boundary checks. Security risks entirely depend on the implementation of udevstart: 1) If udevstart has input validation flaws, they could be triggered through kernel device events (e.g., USB device insertion); 2) The attack surface lies in the parsing and processing of device event data; 3) The trigger condition is automatic execution during system boot or hotplug events.", "link_identifiers": ["udevstart"], "notes": "Immediate analysis of the /sbin/udevstart binary file is required:  \n1) Examine the device event handling logic  \n2) Verify input data boundary checks  \n3) Trace the data flow path from kernel to user space"}
{"name": "hardware_input-usb_driver-S12ubs_storage_modules", "file_path": "etc/init.d/S12ubs_storage.sh", "location": "etc/init.d/S12ubs_storage.sh:0 (script)", "risk_score": 4.0, "confidence": 6.0, "description": "The startup script loads three kernel modules during system initialization: usb-storage.ko (USB storage support), jnl.ko (journal module), and ufsd.ko (filesystem driver). The script itself has no parameter processing or external input reception mechanism, only performing fixed-path module loading operations. The trigger condition is automatic execution during system startup. The actual security risk depends on the code security of the loaded modules: if vulnerabilities exist in the modules (such as buffer overflows), attackers could trigger them by physically connecting malicious USB devices. However, the script itself has no input validation deficiencies and cannot directly form part of an exploitation chain.", "code_snippet": "#!/bin/sh\n\ninsmod /lib/modules/usb-storage.ko\ninsmod /lib/modules/jnl.ko\ninsmod /lib/modules/ufsd.ko", "link_identifiers": ["insmod", "usb-storage.ko", "jnl.ko", "ufsd.ko", "/lib/modules/"], "notes": "Follow-up verification required: 1) Analyze whether /lib/modules/usb-storage.ko contains USB device input processing vulnerabilities; 2) Check if the filesystem logging implementation in jnl.ko/ufsd.ko could be exploited by specially crafted storage devices; 3) Verify whether the USB interface is exposed to external attackers."}
{"name": "command_execution-gpiod_script-1", "file_path": "etc/init.d/S45gpiod.sh", "location": "S45gpiod.sh:2-4", "risk_score": 9.0, "confidence": 8.25, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["xmldbc", "REDACTED_SENSITIVE_DATA", "wanidx", "gpiod", "-w"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "network-ipv6_init_config", "file_path": "etc/init.d/S16ipv6.sh", "location": "etc/init.d/S16ipv6.sh", "risk_score": 0.0, "confidence": 5.0, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["REDACTED_SENSITIVE_DATA", "REDACTED_SENSITIVE_DATA", "REDACTED_SENSITIVE_DATA", "ip6tables", "FORWARD", "DROP", "/dev/console"], "notes": "It is recommended to check whether other network initialization scripts (such as firewall rule configuration scripts) contain dynamic input processing logic. This script runs with REDACTED_PASSWORD_PLACEHOLDER privileges but poses no security risks."}
{"name": "configuration_load-init-S10init_sh", "file_path": "etc/init.d/S10init.sh", "location": "S10init.sh:1-6", "risk_score": 0.0, "confidence": 5.0, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["mount", "echo", "REDACTED_SENSITIVE_DATA", "/proc/sys/vm/panic_on_oom"], "notes": "It is recommended to check other init scripts (such as S50service) or network service startup files, with particular focus on components involving dynamic input processing."}
{"name": "script-init_rcs-dynamic_execution", "file_path": "etc/init.d/rcS", "location": "etc/init.d/rcS", "risk_score": 7.0, "confidence": 6.0, "description": "The rcS script dynamically executes service startup scripts via `for i in /etc/init.d/S??*`. If an attacker can create a malicious file starting with 'S' in /etc/init.d (requiring filesystem write permissions), arbitrary commands will be automatically executed with REDACTED_PASSWORD_PLACEHOLDER privileges during system startup. However, no matching files exist in the current directory, and the script ultimately executes /etc/init0.d/rcS, indicating the actual service entry point may have been relocated.", "link_identifiers": ["S??*", "$i", "/etc/init0.d/rcS"], "notes": "Verify the actual existence of /etc/init0.d/rcS and analyze its startup logic. Additionally, check the filesystem permission configuration to confirm whether the /etc/init.d directory is writable."}
{"name": "command_execution-mount_mydlink-S22mydlink_sh_3", "file_path": "etc/init.d/S22mydlink.sh", "location": "S22mydlink.sh:3-7", "risk_score": 8.0, "confidence": 8.25, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "domount=`mfc mount_mydlink state`\nif [ \"$domount\" = \"on\" ]; then\n  mount -t squashfs $MYDLINK /mydlink\nfi", "link_identifiers": ["MYDLINK", "mount", "mfc", "mount_mydlink", "state", "REDACTED_SENSITIVE_DATA"], "notes": "Attack Path: Network/NVRAM Input → Tampering with mydlinkmtd → Malicious Mounting. Verification Required: 1) mydlinkmtd File Write Interface 2) mfc Command Implementation"}
{"name": "nvram_get-uid_generation-S22mydlink_sh_10", "file_path": "etc/init.d/S22mydlink.sh", "location": "S22mydlink.sh:10-27", "risk_score": 7.5, "confidence": 7.25, "description": "The device UID generation has dual vulnerabilities: 1) Directly using lanmac as input for mydlinkuid without MAC format/length validation; 2) Unconditionally executing erase_nvram.sh and reboot upon generation failure. An attacker can pollute the lanmac value to trigger: a) Buffer overflow in mydlinkuid b) Repeated NVRAM erasure leading to permanent denial of service. Constraints: Requires control over the lanmac setting interface.", "code_snippet": "uid=`devdata get -e dev_uid`\nif [ \"$uid\" == \"\" ] ; then\n  mac=`devdata get -e lanmac`\n  uid=`mydlinkuid $mac`\n  devdata set -e dev_uid=$uid\n  /etc/scripts/erase_nvram.sh\n  reboot\nfi", "link_identifiers": ["dev_uid", "devdata", "lanmac", "mydlinkuid", "erase_nvram.sh", "reboot"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "nvram_set-dev_uid-S22mydlink_sh_10", "file_path": "etc/init.d/S22mydlink.sh", "location": "S22mydlink.sh:10-23", "risk_score": 6.5, "confidence": 6.75, "description": "NVRAM operations lack security boundaries: Direct get/set operations on dev_uid and lanmac via the devdata command fail to implement: 1) Data length checks (to prevent overflow) 2) Content filtering (to prevent command injection). Attackers setting excessively long lanmac/dev_uid values or values containing special characters could influence subsequent command execution flow. Constraint: NVRAM write interfaces must be controlled.", "code_snippet": "mac=`devdata get -e lanmac`\nuid=`mydlinkuid $mac`\ndevdata set -e dev_uid=$uid", "link_identifiers": ["devdata", "get", "set", "-e", "dev_uid", "lanmac"], "notes": "nvram_set\n\nNeed to analyze the devdata command: whether it performs security validation on NVRAM values. Potential attack chain: tampering with lanmac → triggering UID generation vulnerability"}
{"name": "dos-chain-image_sign-xmldb", "file_path": "etc/init.d/S20init.sh", "location": "S20init.sh:3-4 & 15-17", "risk_score": 8.5, "confidence": 7.0, "description": "High-risk denial-of-service chain: Attackers can modify the contents of the /etc/config/image_sign file (requiring file write permissions) to inject malicious parameters, causing the xmldb process to crash. The crash triggers the pidmon monitoring mechanism, forcing a reboot after 5 seconds. Trigger conditions: 1) File content is controllable 2) xmldb fails to properly handle the -n parameter. Boundary check missing: The script lacks length validation or content filtering for $image_sign. Potential impact: Persistent crash-reboot cycles can achieve permanent denial of service, and combined with xmldb parameter vulnerabilities, may escalate to code execution.", "code_snippet": "image_sign=`cat /etc/config/image_sign`\nxmldb -d -n $image_sign -t > /dev/console\n...\npidmon $xmldb_pid add \"echo \\\"xmldb die, reboot device\\\";sleep 5;reboot\"", "link_identifiers": ["image_sign", "xmldb", "pidmon", "xmldb_pid", "/etc/config/image_sign", "reboot"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "command_injection-pidmon-xmldb_pid", "file_path": "etc/init.d/S20init.sh", "location": "/sbin/pidmon:0x000002ad", "risk_score": 9.0, "confidence": 7.5, "description": "pidmon command injection vulnerability: The $xmldb_pid variable is directly concatenated into shell commands without filtering (evidence address 0x000002ad). When the variable contains command separators (such as `;`), arbitrary commands can be injected. Trigger conditions: 1) Control the value of $xmldb_pid (requires indirect control via environment variables/IPC) 2) Trigger pidmon add execution. No input filtering or boundary checks implemented. Actual impact: Successful injection can achieve denial of service or remote code execution.", "code_snippet": "pidmon $xmldb_pid add \"echo \\\"xmldb die, reboot device\\\"\"", "link_identifiers": ["xmldb_pid", "pidmon", "add", "reboot"], "notes": "Link the crash chain associated with S20init.sh. Dynamic testing is required to verify the vulnerability and check other components that invoke pidmon."}
{"name": "file-access-restriction-etc-config-mydlinkmtd", "file_path": "REDACTED_SENSITIVE_DATA", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 5.0, "confidence": 4.5, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["REDACTED_SENSITIVE_DATA", "configuration_access"], "notes": "Configuration file access is restricted. Verification is required through the following methods: 1) Remove directory access restrictions 2) Provide file contents directly 3) Check if referenced by components such as nvram_get/set or xmldb (relevant linking_keywords already exist in the knowledge base)"}
{"name": "attack-chain-break-etc-config-mydlinkmtd", "file_path": "REDACTED_SENSITIVE_DATA", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 7.5, "confidence": 4.5, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["REDACTED_SENSITIVE_DATA", "mount_mydlink", "attack_chain"], "notes": "Correlation Found: command_execution-mount_mydlink-S22mydlink_sh_3. Solution Priority: 1) Retrieve file contents 2) Reverse engineer MFC command implementation 3) Locate mydlinkmtd write point"}
{"name": "network-https-interface-exposure", "file_path": "etc/stunnel.conf", "location": "stunnel.conf:11", "risk_score": 7.0, "confidence": 10.0, "description": "The service listens on port 443 of all network interfaces (accept=443) without IP binding restrictions. Trigger condition: Automatically takes effect upon service startup. Security impact: Expands the attack surface, making it vulnerable to network scanning and unauthorized access. Combined with HTTPS service characteristics, it may serve as an initial intrusion point.", "code_snippet": "accept  = 443\nconnect = 127.0.0.1:80", "link_identifiers": ["accept", "connect", "https"]}
{"name": "config-keyfile-permission-risk", "file_path": "etc/stunnel.conf", "location": "stunnel.conf:1-4", "risk_score": 8.0, "confidence": 9.0, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["cert", "REDACTED_SENSITIVE_DATA", "setuid", "setgid"]}
{"name": "logging-debug-sensitive-output", "file_path": "etc/stunnel.conf", "location": "stunnel.conf:6-7", "risk_score": 6.5, "confidence": 9.5, "description": "High-risk log configuration (debug=7) outputs to /var/log/stunnel.log. Trigger condition: Continuous recording during service runtime. Security impact: May expose encrypted session details or sensitive information; verification of log file permission restrictions is required.", "code_snippet": "debug = 7\noutput = /var/log/stunnel.log", "link_identifiers": ["debug", "output"], "notes": "Subsequent checks on log file permission configurations are required."}
{"name": "service_management-rcS-start_stop_chain", "file_path": "etc/init0.d/rcS", "location": "etc/init0.d/rcS:22-34", "risk_score": 7.0, "confidence": 7.5, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["S??*", "$i start", "$i stop", "&", "/var/killrc0", "ALWAYS_TN", "LOGD", "telnetd", "watchdog"], "notes": "The source of environment variables needs to be subsequently verified (whether from NVRAM/configuration files)."}
{"name": "command_injection-/var/killrc0", "file_path": "etc/init0.d/rcS", "location": "etc/init0.d/rcS:3,5,28-30,34", "risk_score": 8.5, "confidence": 6.5, "description": "High-risk External Input Point - /var/killrc0 Arbitrary Command Execution:  \n1) Attack Path: Attacker controls /var directory → Prepares malicious killrc0 → System reboots → rcS executes sh $KRC  \n2) Trigger Condition: Incorrect permission configuration of /var directory (must be writable)  \n3) Impact: Arbitrary command execution with REDACTED_PASSWORD_PLACEHOLDER privileges.  \nEvidence:  \na) No permission check for file creation (mv $KRC.tmp $KRC)  \nb) Dynamically generated content ($i stop)  \nc) Unconditional execution (sh $KRC).  \nExploitation likelihood depends on the actual protection strength of the /var directory.", "code_snippet": "if [ -f $KRC]; then\n\tsh $KRC\n...\necho \"$i stop\" > $KRC.tmp\nmv $KRC.tmp $KRC", "link_identifiers": ["KRC=/var/killrc0", "sh $KRC", "mv $KRC.tmp $KRC", "$i stop", "/var"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "insufficient_evidence-dbload_service_xmldb", "file_path": "etc/init0.d/rcS", "location": "HIDDEN", "risk_score": 0.0, "confidence": 5.0, "description": "Insufficient Evidence Statement:  \n1) NVRAM Initialization: Suspected to be implemented via /etc/scripts/dbload.sh, but file content could not be retrieved.  \n2) Vulnerability Component Interaction: The 'service' command does not exist, and the xmldb/gpiod call chain does not directly appear in rcS.  \n3) val Variable Conditional Check: Depends on the missing 'service' binary, making risk assessment impossible. Manual verification of dbload.sh and binary directories is required subsequently.", "link_identifiers": ["dbload.sh", "service", "val", "xmldb", "gpiod"], "notes": "Follow-up action recommendations: 1) Manually check /etc/scripts/dbload.sh 2) Analyze binaries in /bin and /sbin directories 3) Verify permissions in /var directory"}
{"name": "command_execution-smart404-S41smart404_sh_4_6", "file_path": "etc/init0.d/S41smart404.sh", "location": "S41smart404.sh:4-6", "risk_score": 3.0, "confidence": 5.5, "description": "The startup script executes fixed commands when $1='start': it invokes control_smart404.php via phpsh and passes hardcoded ACTION parameters (INIT_SMART404/INIT_EVENTS). No direct input validation vulnerabilities exist ($1 is strictly checked and ACTION is not controllable), but the ACTION parameter may become an independent attack surface in the PHP file. Verification required: 1) The ACTION parameter handling logic in control_smart404.php 2) Whether the phpsh binary contains parameter injection vulnerabilities.", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["phpsh", "control_smart404.php", "ACTION=INIT_SMART404", "ACTION=INIT_EVENTS", "$1"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "event-handler-network-SITESURVEY", "file_path": "etc/init0.d/S41event.sh", "location": "etc/init0.d/S41event.sh", "risk_score": 7.5, "confidence": 8.5, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["SITESURVEY", "SITESURVEY.sh", "event", "network_input"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "event-handler-hardware-DISKUP", "file_path": "etc/init0.d/S41event.sh", "location": "etc/init0.d/S41event.sh", "risk_score": 7.5, "confidence": 8.5, "description": "The DISKUP/DISKDOWN event responds to USB device status changes via update_usb_led.php. Attackers can trigger this through malicious USB devices. If the PHP script does not securely handle device parameters (such as device name/path), it may lead to code execution. Trigger condition: USB device insertion; Constraint: relies on physical access or a malicious USB device.", "code_snippet": "event DISKUP insert USB_LED:\"phpsh /etc/events/update_usb_led.php\"", "link_identifiers": ["DISKUP", "DISKDOWN", "update_usb_led.php", "event", "hardware_input"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "REDACTED_SENSITIVE_DATA", "file_path": "etc/init0.d/S80telnetd.sh", "location": "S80telnetd.sh:10", "risk_score": 8.5, "confidence": 8.5, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "telnetd -l /usr/sbin/login -u Alphanetworks:$image_sign -i br0 &", "link_identifiers": ["image_sign", "Alphanetworks", "xmldbc", "REDACTED_SENSITIVE_DATA", "telnetd -u"], "notes": "Evidence Limitation: Unable to verify the contents of /etc/config/image_sign. Attack Surface: Triggering the first boot condition via HTTP interface/web console or extracting firmware to obtain credentials."}
{"name": "nvram-logic-flaw-telnetd", "file_path": "etc/init0.d/S80telnetd.sh", "location": "S80telnetd.sh:4-6", "risk_score": 7.5, "confidence": 7.25, "description": "NVRAM Control Logic Flaw: The script controls telnetd startup by retrieving the ALWAYS_TN value via devdata. If an attacker modifies NVRAM to set ALWAYS_TN=1, it activates telnetd with abnormal timeout parameters (999...). Trigger conditions: 1) Script execution parameter $1=start 2) entn=1. Potential impacts: a) Abnormal timeout parameters may trigger integer overflow vulnerabilities in telnetd b) Persistent backdoor access. Exploitation chain: Attacker first obtains NVRAM write permissions (e.g., through web vulnerabilities) → tampers with ALWAYS_TN → triggers abnormal telnetd service.", "code_snippet": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["entn", "ALWAYS_TN", "devdata", "telnetd -t", "REDACTED_SENSITIVE_DATA"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "file_read-ntfs_parser-security_mechanism", "file_path": "sbin/ntfs-3g", "location": "sbin/ntfs-3g:0x417dc (strcpy) + fcn.0003022c+0x1c0 (ntfs_mft_records_read)", "risk_score": 1.5, "confidence": 4.5, "description": "ntfs-3g implements comprehensive input processing security mechanisms: 1) Configuration is exclusively achieved through command-line parameters, eliminating exposure risks from environment variables/NVRAM; 2) All strcpy call points first perform strlen calculation and dynamically allocate target buffers (source length + 1~12 bytes redundancy); 3) The core metadata parsing function ntfs_mft_records_read implements dual protection for the count parameter: a) 64-bit arithmetic comparison between requested record range vs allocated record limit b) Out-of-bound requests trigger ENOSPC error and abort operation. Successful malicious NTFS image attacks require simultaneously: controlling the RecordNumber field in $MFT header + bypassing 64-bit range check, though no known bypass paths exist for the actual protection mechanisms.", "code_snippet": "HIDDEN:\nif ((requested_high != allocated_high && requested_high - allocated_high < 0) ||\n   (requested_high == allocated_high && requested_low <= allocated_low)) {\n    // HIDDEN\n} else {\n    *errno = 0x1d; // ENOSPC\n    return 0xffffffff;\n}", "link_identifiers": ["getopt_long", "argc", "argv", "strcpy", "strlen", "malloc", "ntfs_mft_records_read", "RecordNumber", "ENOSPC", "$MFT", "mft_records"], "notes": "The attack surface is constrained by: 1) No network/IPC interfaces 2) File parsers incorporate defense-in-depth mechanisms. Recommendations: a) Inspect other filesystem parsing functions b) Verify CVE-2017-0358 patch implementation status"}
{"name": "stack_overflow-udevd-netlink_exec_chain", "file_path": "sbin/udevd", "location": "udevd:0xadc0 (via fcn.0001124c)", "risk_score": 9.5, "confidence": 8.25, "description": "High-risk stack overflow vulnerability: Function fcn.0001124c uses strcpy to copy network data (*0xb364) into a fixed 512-byte stack buffer without length validation. Trigger condition: Attacker sends ≥512-byte NETLINK message (protocol family 0x10, type 2, protocol 0xf). Missing boundary check: recvmsg directly passes received data without validating msg_iovlen. Security impact: Overwrites return address to control program flow, potentially chaining with execv to achieve arbitrary command execution. Exploitation method: Craft long path parameter containing shellcode to trigger overflow.", "link_identifiers": ["fcn.0001124c", "strcpy", "*0xb364", "recvmsg", "execv", "NETLINK", "0x10,2,0xf"], "notes": "Verify the ASLR/NX protection status. Attack chain: NETLINK input → event loop → path processing → strcpy overflow → control flow hijacking → execv execution"}
{"name": "traversal-attr_match-0x8fd4", "file_path": "sbin/udevtrigger", "location": "udevtrigger:0x8fd4 (dbg.attr_match)", "risk_score": 9.2, "confidence": 8.75, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "strlcpy(local_buffer, param_1, 0x200);\nstrlcat(local_buffer, '/', 0x200); // HIDDEN", "link_identifiers": ["dbg.trigger_uevent", "dbg.attr_match", "dirent.d_name", "strlcat", "../", "open64", "write", "scan_bus", "device_list_insert"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "stack_overflow-scan_bus-0x92cc", "file_path": "sbin/udevtrigger", "location": "udevtrigger:dbg.scan_bus", "risk_score": 8.0, "confidence": 7.25, "description": "Stack buffer overflow risk:\n1. Trigger condition: scan_bus processing device directory names exceeding 255 bytes\n2. Specific manifestation: 512-byte stack buffer (auStack_620) receives fixed prefix (6B) + directory name (255B) + separator (1B) + subdirectory name (255B) = 517B\n3. Boundary failure: Worst-case scenario exceeds buffer by 5 bytes, potentially overwriting return address\n4. Security impact: Physical attacker could trigger arbitrary code execution via excessively long directory names\n5. Exploitation constraints: Depends on filesystem support for overly long directory names", "link_identifiers": ["dbg.scan_bus", "auStack_620", "strlcpy", "strlcat", "0x92cc", "0x92d0", "readdir64"], "notes": "Verification required: 1) Actual directory name restrictions 2) Stack layout and overwrite feasibility 3) Compiler protection mechanisms"}
{"name": "attack_chain-scan_bus-multivuln", "file_path": "sbin/udevtrigger", "location": "udevtrigger:dbg.scan_bus", "risk_score": 9.0, "confidence": 8.25, "description": "USB Input Centralization Point Forms Multi-Vulnerability Attack Chain:\n1. Core Hub: scan_bus function handles USB device enumeration (dirent.d_name and directory names)\n2. Dual Propagation Paths:\n   - Path 1: Device names directly passed to attr_match function, triggering path traversal vulnerability (0x8fd4)\n   - Path 2: Directory structure passed to local buffer processing, triggering stack overflow risk (0x92cc)\n3. Attack Scenario: A single insertion of a specially crafted USB device can simultaneously trigger both vulnerability types\n4. Exploitation Advantage: Physical attackers can attempt multiple attack vectors without requiring repeated triggering", "link_identifiers": ["scan_bus", "dbg.scan_bus", "dirent.d_name", "attr_match", "auStack_620"], "notes": "Associated existing vulnerabilities: traversal-attr_match-0x8fd4 and stack_overflow-scan_bus-0x92cc"}
{"name": "network_input-smbd-http_heap_overflow", "file_path": "sbin/smbd", "location": "sbin/smbd:0x11d0e4 (fcn.0011cbb0)", "risk_score": 9.5, "confidence": 4.5, "description": "HTTP Parameter Heap Overflow Vulnerability: An attacker sends an HTTP request containing excessively long parameters, contaminating memory through the call chain fcn.0011d428->fcn.0011d28c->fcn.0011c60c, ultimately triggering a heap overflow via an unvalidated strcpy in fcn.0011cbb0. Trigger condition: The device exposes HTTP services without requiring authentication. Missing boundary check: The length of puVar2 is not verified against the buffer size of pcVar16+1 before copying. Security impact: Remote code execution with full device control.", "link_identifiers": ["fcn.0011cbb0", "strcpy", "puVar2", "pcVar16", "param_1", "malloc", "HTTP"], "notes": "Verify the default status of the HTTP service; it is recommended to check the ratio of heap allocation size to actual input length"}
{"name": "env_get-smbd-env_cmd_injection", "file_path": "sbin/smbd", "location": "sbin/smbd:0xd8e5c (fcn.000d8c28)", "risk_score": 8.0, "confidence": 4.25, "description": "Environment variable command injection: By contaminating the LIBSMB_PROG environment variable (potentially injected via NVRAM/web configuration), arbitrary commands are executed in fcn.000d8c28 through system(getenv(\"LIBSMB_PROG\")). Trigger condition: Attackers can modify device environment variables (e.g., via startup scripts/NVRAM writes). Boundary check missing: No filtering of LIBSMB_PROG content. Security impact: REDACTED_PASSWORD_PLACEHOLDER-privileged command execution, forming a complete chain from NVRAM to RCE.", "link_identifiers": ["LIBSMB_PROG", "getenv", "system", "fcn.000d8c28", "*0x76b34", "NVRAM"], "notes": "Analyze the /etc/init.d startup script to confirm the environment variable setting point; verify whether *0x76b34 consistently points to LIBSMB_PROG."}
{"name": "network_input-smbd-smb_fmt_string", "file_path": "sbin/smbd", "location": "sbin/smbd:0xc57b4 (fcn.000c57b4)", "risk_score": 9.0, "confidence": 4.0, "description": "SMB Format String Vulnerability: Malicious SMB requests control the *(puVar9+0x24) parameter, causing the fcn.000cd9d4 function to write excessive data into a 1024-byte buffer acStack_43c during processing. Trigger condition: Crafted SMB requests containing abnormal format specifiers. Boundary check missing: Failure to validate the length of format strings. Security impact: Remote unauthenticated stack overflow leading to code execution.", "link_identifiers": ["fcn.000c57b4", "fcn.000cd9d4", "acStack_43c", "puVar9", "SMB", "fcn.000d808c"], "notes": "Track the origin of the puVar9 structure; recommend analyzing the SMB request parsing function fcn.000d808c."}
{"name": "env_get-smbd-nvram_heap_overflow", "file_path": "sbin/smbd", "location": "sbin/smbd:fcn.000d01b8", "risk_score": 7.5, "confidence": 3.5, "description": "NVRAM Interaction Heap Overflow: In fcn.000da554 after obtaining environment variables, the memcpy in fcn.000d01b8 copies tainted data (param_3) without length validation. Trigger condition: Setting excessively long NVRAM values or environment variables. Missing boundary check: memcpy lacks length restrictions. Security impact: Heap corruption may lead to privilege escalation.", "link_identifiers": ["fcn.000d01b8", "fcn.000da554", "memcpy", "param_3", "NVRAM", "getenv"], "notes": "Verify the target buffer allocation size; check if the NVRAM settings interface has length restrictions"}
{"name": "buffer_overflow-httpd-default_param-0x13628", "file_path": "sbin/httpd", "location": "httpd:0x13628 fcn.0001331c", "risk_score": 9.8, "confidence": 9.25, "description": "High-risk stack buffer overflow vulnerability: When processing HTTP requests containing the 'default' parameter (request type unspecified), the function fcn.0001331c uses strcpy to copy the parameter value into a fixed-size stack buffer (acStack_680[800]). Without length validation, the return address is overwritten when the parameter value exceeds 787 bytes. Trigger conditions: 1) Send an HTTP request containing the 'default' parameter 2) Parameter value length >787 bytes. Exploitation method: Craft an excessively long malicious parameter to achieve arbitrary code execution, posing an extremely high risk level without requiring authentication.", "code_snippet": "sym.imp.strcpy(puVar7 + iVar6 + -0x67c, *(puVar7 + -0x30));", "link_identifiers": ["fcn.0001331c", "acStack_680", "strcpy", "default", "fcn.00013a78", "fcn.0001738c", "HTTPHIDDEN"], "notes": "Complete attack chain verification: network input → parameter parsing → dangerous operation. It is recommended to test the feasibility of actual exploitation in subsequent steps."}
{"name": "function_pointer_overflow-httpd-uri_handler-0x19a90", "file_path": "sbin/httpd", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 8.7, "confidence": 8.0, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "sym.imp.strcpy(ppcVar7[-8] + 0xdb0, ppcVar7[-7]);\n*(ppcVar7[-8] + 0x14) = ppcVar7[-8] + 0xdb0;", "link_identifiers": ["REDACTED_SENSITIVE_DATA", "strcpy", "0xdb0", "0x14", "ppcVar7[-7]", "ppcVar7[-8]", "fcn.0001b89c", "HTTP_URI"], "notes": "The actual exploitation difficulty needs to be evaluated in conjunction with firmware ASLR implementation."}
{"name": "command_injection-httpd-content_type_3-0xa640", "file_path": "sbin/httpd", "location": "httpd:0xa640 fcn.0000a640", "risk_score": 9.9, "confidence": 8.75, "description": "High-risk Command Injection Vulnerability: When the HTTP request Content-Type=3, the function fcn.0000a640 copies request body data unfiltered into the execve parameter array. Attackers can embed command separators (such as `;`) in the request body. Trigger conditions: 1) HTTP request with Content-Type=3 2) Malicious request body containing OS commands. Exploitation method: Directly obtains remote command execution privileges, posing an extremely high risk level.", "code_snippet": "sym.imp.memcpy(target_buf, input_str, len); // HIDDEN", "link_identifiers": ["execve", "fcn.0000a640", "Content-Type=3", "memcpy", "fcn.0000b4f8", "HTTPHIDDEN"], "notes": "Complete propagation path: network input → multi-layer function passing → dangerous system call"}
{"name": "info_leak-httpd-PATH_INFO-0x16ebc", "file_path": "sbin/httpd", "location": "httpd:0x16ebc convert_cgi_headers", "risk_score": 6.5, "confidence": 9.0, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["PATH_INFO", "getpwnam", "convert_cgi_headers", "fcn.00017f74", "fcn.0000acb4", "HTTPHIDDEN"], "notes": "The attack chain is complete but has limited impact, recommended as a supplementary information gathering method"}
{"name": "network_input-http_audio_overflow-0x17f8c", "file_path": "sbin/mt-daapd", "location": "mt-daapd: [fcn.00017f64] 0x17f8c", "risk_score": 9.0, "confidence": 8.5, "description": "High-risk stack buffer overflow vulnerability: Function fcn.00017f64 (0x17f8c) uses sprintf(\"%s audio file\") to process HTTP-originated data, with a target buffer of only 56 bytes and no length validation. Trigger condition: Attacker sends crafted HTTP parameter >44 bytes → stored via gdbm_fetch → read operation triggers overflow overwriting return address. Full exploit chain confirmed: HTTP request → processed by fcn.0001285c → stored via gdbm_fetch → read by fcn.00014ad4 → overflow execution. High success probability (8.0/10) due to directly exposed network interface and absence of protection mechanisms.", "code_snippet": "sprintf(sp+12, \"%s audio file\", *(param_1+0x1c));", "link_identifiers": ["fcn.00017f64", "gdbm_fetch", "fcn.0001285c", "fcn.00014ad4", "HTTP_request", "sprintf"], "notes": "Recommended fix: Replace with snprintf and add length check"}
{"name": "network_input-http_post_decode-0xdd00", "file_path": "sbin/mt-daapd", "location": "binary: [fcn.0000dc04] 0xdd00", "risk_score": 7.5, "confidence": 7.5, "description": "HTTP POST Parameter Processing Vulnerability: The URL decoding function (fcn.0000dc04) fails to properly handle invalid hexadecimal encodings (e.g., %gh), resulting in the potential use of uninitialized variable uVar5. Combined with the lack of boundary checks in the parameter storage function (fcn.0000d504), an attacker can craft parameter values containing special characters like %00 to inject anomalous data. Trigger condition: Sending a malicious POST request with Content-Type set to application/x-www-form-urlencoded. This vulnerability could potentially be exploited in subsequent file/command operations, though the specific exploitation path requires further verification.", "code_snippet": "uVar10 = uVar10 + uVar5; // HIDDEN", "link_identifiers": ["fcn.0000dc04", "uVar5", "fcn.0000d504", "ws_getpostvars", "strsep", "Content-Length"], "notes": "Track the usage of decoded parameters in system calls or file operations"}
{"name": "network_input-thread_resource-0xd0f4", "file_path": "sbin/mt-daapd", "location": "binary: [fcn.0000d0a4] 0xd0f4", "risk_score": 6.0, "confidence": 7.0, "description": "Thread resource management flaw: HTTP request handling thread creation (fcn.0000d0a4) lacks pthread_detach attribute setting. Trigger condition: Sustained high-frequency HTTP requests cause accumulation of unrecycled threads. May exhaust system resources (thread IDs/memory), leading to denial of service. Medium probability of triggering (6.0/10) in long-term operating environments.", "code_snippet": "iVar1 = sym.imp.pthread_create(puVar7,0,*0xd2a4,piVar5);", "link_identifiers": ["pthread_create", "fcn.0000d0a4"], "notes": "It is recommended to add a pthread_detach call or set the thread detach attribute"}
{"name": "stack_overflow-gpiod_socket-0xa5f4", "file_path": "usr/sbin/gpiod", "location": "usr/sbin/gpiod:0xa5f4 [fcn.0000a5f4]", "risk_score": 9.5, "confidence": 8.5, "description": "The Unix domain socket handling in gpiod contains a critical stack-based buffer overflow vulnerability. Specifically: Function fcn.0000a5f4 uses a 268-byte stack buffer (fp-0x10c) to store socket data received via recv, but fails to validate input length. When an attacker sends data exceeding 267 bytes to the /var/gpio_ctrl socket, it can overwrite critical stack data including return addresses, leading to arbitrary code execution. Trigger conditions: 1) Attacker has local access 2) Sends unvalidated long packets 3) No authentication required.", "code_snippet": "0x0000a5f4      bl fcn.0000dcdc  ; recvHIDDEN\n0x0000a628      433f4be2       sub r3, fp, 0x10c  ; 268HIDDEN\n0x0000a638      69f9ffeb       bl sym.imp.strcmp  ; HIDDEN", "link_identifiers": ["fcn.0000a5f4", "recv", "/var/gpio_ctrl", "fp-0x10c", "strcmp", "STATUS_GREEN"], "notes": "Attack chain: Local attacker → Write to /var/gpio_ctrl → Trigger overflow. Next steps required: 1) Calculate precise overflow offset 2) Test practical exploitability 3) Check ASLR protection status"}
{"name": "unverified_event-FRESET-0x70e0", "file_path": "usr/sbin/gpiod", "location": "usr/sbin/gpiod:0x70e0 (.rodata)", "risk_score": 6.0, "confidence": 4.5, "description": "The FRESET event command chain ('echo...event FRESET') was identified at offset 0x70e0 in the .rodata section of gpiod, but the actual execution point and trigger mechanism remain unlocated. Potential risk: If vulnerabilities (such as command injection) exist in this event handler, attackers could execute arbitrary commands by triggering the FRESET event. Unknown trigger conditions require further verification: 1) Hardware reset signal handling process 2) Software trigger interface 3) Permission verification mechanism.", "link_identifiers": ["FRESET", "event", ".rodata+0x70e0"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "pending_analysis-gpio_sh-script", "file_path": "usr/sbin/gpiod", "location": "etc/scripts/gpio.sh", "risk_score": 7.5, "confidence": 5.5, "description": "REDACTED_SENSITIVE_DATA", "link_identifiers": ["gpio.sh", "FRESET", "/var/gpio_ctrl"], "notes": "Correlation analysis recommendations: 1) Reverse the execution logic of gpio.sh 2) Check whether unfiltered parameters are passed to gpiod 3) Verify interaction paths with existing gpiod vulnerabilities"}
{"name": "REDACTED_SENSITIVE_DATA", "file_path": "REDACTED_SENSITIVE_DATA", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 0.0, "confidence": 5.0, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "HIDDEN（HIDDENXMLHIDDEN）", "link_identifiers": ["$FEATURE_NOLAN", "$FEATURE_NOAPMODE", "$FEATURE_HAVEBGMODE", "REDACTED_SENSITIVE_DATA"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "analysis-html.php-HNAP_location", "file_path": "htdocs/phplib/html.php", "location": "htdocs/phplib/html.php", "risk_score": 0.0, "confidence": 5.0, "description": "The file `htdocs/phplib/html.php` is a general-purpose PHP library and does not include HNAP authentication implementation. HNAP authentication should be handled by standalone CGI programs, with typical paths including: `/www/cgi-bin/hnap.cgi`, `/www/HNAP1/`, or handlers within the `/www/hnap/` directory. The correct file must be located to analyze the data flow and vulnerability chain of the authentication mechanism.", "link_identifiers": ["html.php", "phplib", "HNAP_AUTH", "SOAPAction", "Authenticate"], "notes": "The user must provide the correct HNAP processing file path. Related knowledge base record: 'Critical security logic depends on external files...' (Revised conclusion)"}
{"name": "network_input-info_cgi-query_operation", "file_path": "htdocs/mydlink/info.cgi", "location": "/www/info.cgi:0 (main) [HIDDEN]", "risk_score": 0.0, "confidence": 4.9, "description": "REDACTED_SENSITIVE_DATA", "code_snippet": "", "link_identifiers": ["query", "model", "version", "macaddr", "echo", "toupper"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "stack_overflow-http_uri_handler-fcn0000ac44", "file_path": "htdocs/fileaccess.cgi", "location": "fileaccess.cgi:0xaddc fcn.0000ac44", "risk_score": 9.5, "confidence": 9.1, "description": "High-risk stack buffer overflow vulnerability: The main function (fcn.0000ac44) retrieves the HTTP request URI via getenv('REQUEST_URI') and copies it to a fixed-size stack buffer (fp-0x1030) using strcpy. Boundary check flaw: The length comparison (<=0xfc2 / 4034 bytes) is performed against an actual buffer capacity of 4144 bytes (0x1030). Attackers can craft malicious URIs of 4035-4144 bytes to trigger overflow. Trigger condition: Sending HTTP requests with excessively long URIs. Security impact: Return address overwrite leading to remote code execution (RCE) with high exploit probability.", "code_snippet": "r0 = getenv(\"REQUEST_URI\");\n[src] = r0;\nr0 = strlen([src]);\nif (r0 <= 0xfc2) { /* HIDDEN */\n  strcpy(fp-0x1030, [src]); /* HIDDEN */\n}", "link_identifiers": ["REQUEST_URI", "getenv", "strcpy", "fcn.0000ac44", "src", "var_ch"], "notes": "Complete attack chain: network input (HTTP URI) → REQUEST_URI environment variable → strcpy stack overflow → control flow hijacking. Need to verify stack offset accuracy (0x1030)."}
{"name": "sprintf_overflow-risk-fcn0000ac44", "file_path": "htdocs/fileaccess.cgi", "location": "fileaccess.cgi:0xaf64 fcn.0000ac44", "risk_score": 7.0, "confidence": 7.75, "description": "sprintf buffer overflow risk: The main function (fcn.0000ac44) uses sprintf to write user-controllable data ([src]) into a stack buffer (fp-0x2af4) with the format string \"%s?id=%s\". Trigger condition: Controlling [src] content through HTTP_COOKIE or REQUEST_URI. Security impact: 1) Excessive input length causes stack overflow 2) If [src] contains format specifiers (e.g., %n), it may trigger format string attacks. Boundary check: No input length restriction was found.", "code_snippet": "r0 = [src];\nr1 = \"%s?id=%s\";\nr2 = [src];\nsprintf(fp-0x2af4, r1, r2);", "link_identifiers": ["sprintf", "HTTP_COOKIE", "id=%s", "fcn.0000a40c", "var_10h"], "notes": "Verify if the data flow from HTTP_COOKIE to [src] is unobstructed. The target buffer size is unknown; it is recommended to subsequently validate the stack space at fp-0x2af4."}
{"name": "REDACTED_SENSITIVE_DATA", "file_path": "htdocs/fileaccess.cgi", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 7.8, "confidence": 7.25, "description": "A high-risk authentication mechanism vulnerability was discovered in fileaccess.cgi: 1) Uses hardcoded path /tmp/auth_session_%d to store authentication credentials 2) Only supports limited index range of 0-127. Attackers can obtain valid credentials by traversing the /tmp directory or brute-forcing indexes to achieve authentication bypass. Trigger condition: When accessing fileaccess.cgi without providing valid session credentials. Successful bypass grants direct access to file operation functions.", "link_identifiers": ["/tmp/auth_session_", "REDACTED_SENSITIVE_DATA", "REDACTED_SENSITIVE_DATA", "lockf64", "strcmp", "REMOTE_USER", "auth="], "notes": "Verify the permissions of the /tmp directory and the actual existence of files; the source of the environment variable '0x5428|0x30000' is unverified; this vulnerability serves as the entry point of the attack chain, and bypassing it can trigger a stack overflow vulnerability (refer to stack-buffer-overflow-fileaccess-0000ac44)."}
{"name": "stack-buffer-overflow-fileaccess-0000ac44", "file_path": "htdocs/fileaccess.cgi", "location": "fileaccess.cgi:0x0000ac44 (fcn.0000ac44)", "risk_score": 9.2, "confidence": 8.75, "description": "Critical sprintf stack overflow vulnerability discovered: 1) Copies tainted data (puVar6-0x1068) to fp-0x2aac buffer using 'id=%s' format 2) Performs self-referencing concatenation to fp-0x1000 buffer using '%s?id=%s' format. Neither 4096-byte buffer implements length validation. Trigger conditions: a) After authentication bypass b) Injecting oversized data into tainted source (puVar6-0x1068) c) Meeting branch condition to trigger sprintf call. Enables return address overwrite for arbitrary code execution.", "link_identifiers": ["fcn.0000ac44", "sprintf", "puVar6+0+-0x1068", "id=%s", "%s?id=%s", "dest", "fcn.0000a40c", "strncmp"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "stack-protection-missing-fileaccess-0000ac44", "file_path": "htdocs/fileaccess.cgi", "location": "fileaccess.cgi:0x0000ac44 (fcn.0000ac44)", "risk_score": 7.0, "confidence": 7.9, "description": "Stack protection mechanism missing: The function fcn.0000ac44 prologue lacks canary loading instructions, and the epilogue lacks canary verification. The prologue only includes `push {fp, lr}` and `sub sp` to allocate space, while the epilogue directly restores the stack pointer and returns. Combined with the sprintf vulnerability, this significantly increases the success rate of overflow exploitation.", "link_identifiers": ["fcn.0000ac44", "push", "sub sp", "pop", "fp", "lr", "pc"], "notes": "This issue is located in a function with a stack overflow vulnerability (see stack-buffer-overflow-fileaccess-0000ac44), collectively forming a complete attack chain"}
{"name": "REDACTED_SENSITIVE_DATA", "file_path": "htdocs/fileaccess.cgi", "location": "REDACTED_SENSITIVE_DATA", "risk_score": 6.5, "confidence": 4.5, "description": "The exact origin of the environment variable '0x5428|0x30000' remains unverified. This variable was utilized in an authentication bypass vulnerability, though its setting location and contamination path were not traced. Analysis is required to determine whether it originates from externally controllable sources (e.g., HTTP headers, configuration files, or IPC) to confirm whether attackers could manipulate the authentication logic.", "link_identifiers": ["0x5428|0x30000", "REDACTED_SENSITIVE_DATA", "env_get"], "notes": "REDACTED_SENSITIVE_DATA"}
{"name": "unresolved-dataflow-fileaccess-0000ac44", "file_path": "htdocs/fileaccess.cgi", "location": "fileaccess.cgi:0x0000ac44 (fcn.0000ac44)", "risk_score": 7.0, "confidence": 5.75, "description": "Pollution source (puVar6-0x1068) complete data flow not traced. This buffer serves as the input point for a stack overflow vulnerability. The following must be determined: 1) Whether it originates from network request bodies/parameters 2) Whether it has undergone filtering function processing 3) Whether other components (such as nvram_get or file reading) influence its content.", "link_identifiers": ["puVar6+0+-0x1068", "fcn.0000ac44", "data_flow"], "notes": "REDACTED_SENSITIVE_DATA"}
