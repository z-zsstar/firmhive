{"name": "XSS-file_access_show_content_update_tree", "location": "file_access.asp:show_content function (approximately lines 350-400) and update_tree function (approximately lines 250-280)", "description": "In the 'file_access.asp' file, user-controlled folder and file names are not escaped when output to HTML, leading to a reflected cross-site scripting (XSS) vulnerability. Attackers can create malicious folders or files (for example, names containing JavaScript code). When other logged-in users browse the file manager, the malicious script will execute in their browsers. This may lead to session hijacking, unauthorized operations, or data theft. Trigger conditions include: users accessing the file management page and viewing folders or files containing malicious names. The vulnerability exists in multiple functions where user input is directly concatenated into HTML strings.", "link_identifiers": ["folders[i].name", "files[i].name", "/dws/api/ListDir", "/dws/api/ListFile", "/dws/api/AddDir"], "code_snippet": "// In the show_content function:\ncontent_msg += '<tr class=listCtx onclick=\"ctxClick(\\''+rPath+folders[i].name+'\\', \\''+ulId+'/'+folders[i].name+'\\', \\'1\\')\">';\ncontent_msg += \"<td class=listName><img src=\"+extIcon+\">&nbsp;\"+files[i].name+\"</td>\";\n\n// In the update_tree function:\nbranches += '<li><span class=folder>'+dispName+'</span>'+\n    '<ul id=\"'+ulId+'/'+dispName+'\"'+\n    ' url=\"req_subfolder(\\''+rPath+reqPath+'\\', \\''+ulId+'/'+dispName+'\\', \\''+volId+'\\')\"'+\n    ' clr=\"req_ctx(\\''+rPath+reqPath+'\\', \\''+ulId+'/'+dispName+'\\', \\''+volId+'\\')\">'+\n    '</ul></li>';", "risk_score": 6.5, "confidence": 8.5, "notes": "The vulnerability is highly exploitable because an attacker only needs to create a malicious folder or file (via the upload or create folder function) to trigger the XSS. User interaction is required (browsing the file manager), but as a logged-in user, the risk is significant. It is recommended to perform HTML escaping on user input. Subsequent verification can check if the backend API filters input.", "file_path": "wa_www/file_access.asp"}
{"name": "FileUpload-API_UploadFile", "location": "file_access.asp:btn_upload function and dlg_upload_ok function (approximately lines 450-500)", "description": "The file upload function is processed via the '/dws/api/UploadFile' API, but the client-side code does not validate file types, relying solely on backend checks. An attacker could potentially upload malicious files (such as a webshell). If the backend does not strictly restrict file types or paths, it could lead to remote code execution. Trigger condition: An attacker uses the upload function to submit a malicious file and tricks a user or the system into accessing that file. The exploitation method depends on the backend configuration, but based on the client-side code, the lack of client-side validation increases the risk.", "link_identifiers": ["/dws/api/UploadFile", "wfa_file", "form1"], "code_snippet": "function btn_upload()\n{\n    $('#wfa_file').val('');\n    $('#wfa_tok').val('');\n    $('#upload_form').show();\n    upload_count = 0;\n    clearInterval(polling_id);\n    $('#dlg_upload').dialog('open');\n}\n\nfunction dlg_upload_ok(obj)\n{\n    if ($('#wfa_file').val() == '') {\n        alert('Select a file');\n        return;\n    }\n    var rand = gen_rand_num(32);//generate 32 bytes random number\n    var arg1 = '/dws/api/UploadFile?id='+session_id+rand;\n    $('#wfa_id').val(session_id);\n    $('#wfa_path').val(cur_path);\n    $('#wfa_volid').val(cur_volId);\n    $('#wfa_tok').val(rand+hex_hmac_md5(session_tok, arg1));\n    document.getElementById('form1').action = '/dws/api/UploadFile';\n    document.getElementById('form1').target = 'upload_target';\n    $('#form1').submit();\n    $(obj).dialog(\"close\");\n    setTimeout('delay_refresh_ctx()', 1000);\n}", "risk_score": 7.0, "confidence": 7.0, "notes": "The risk depends on the backend implementation. If the backend allows execution of uploaded files (such as PHP files), it could lead to a serious vulnerability. It is recommended to check the backend code to confirm file type validation and storage path security. The attack chain is complete, but it requires a corresponding backend vulnerability to be fully exploited.", "file_path": "wa_www/file_access.asp"}
{"name": "PathTraversal-API_ListDir_GetFile", "location": "file_access.asp: req_subfolder function (approximately lines 150-180) and fileClick function (approximately lines 320-350)", "description": "Path parameters (such as 'path' and 'volid') are used directly in multiple API calls (such as '/dws/api/ListDir', '/dws/api/GetFile') without apparent client-side validation. If the backend does not properly sanitize the input, it may lead to path traversal attacks, allowing attackers to access sensitive system files. Trigger condition: An attacker manipulates the 'path' parameter (for example, using '../') to access restricted directories. Exploitation method: By modifying the 'path' value in AJAX requests, attempt to read or download system files.", "link_identifiers": ["path", "volid", "/dws/api/ListDir", "/dws/api/GetFile", "req_subfolder", "fileClick"], "code_snippet": "function req_subfolder(path, ulId, volId) \n{\n    var param = {\n        url: '/dws/api/ListDir',\n        arg: 'id='+session_id+'&path='+urlencode(path)+'&volid='+volId\n    };\n    // ...\n}\n\nfunction fileClick(path, filename, volId)\n{\n    var rand = gen_rand_num(32);//generate 32 bytes random number\n    var arg1 = '/dws/api/GetFile?id='+session_id+rand;\n    $('#get_wfa_id').val(session_id);\n    $('#get_wfa_path').val(urlencode(path));\n    $('#get_wfa_volid').val(volId);\n    $('#get_wfa_file').val(urlencode(filename));\n    $('#get_wfa_tok').val(rand+hex_hmac_md5(session_tok, arg1));\n    document.getElementById('form2').target = 'upload_target';\n    $('#form2').submit();\n}", "risk_score": 6.0, "confidence": 6.5, "notes": "Vulnerability exploitability depends on the backend not performing strict path validation. The urlencode function may not be sufficient to prevent path traversal. It is recommended to check the backend API implementation. The attack chain may be incomplete and requires backend vulnerability verification.", "file_path": "wa_www/file_access.asp"}
{"name": "XSS-category_asp_file_list", "location": "category.asp: show_media_list function and show_media_list2 function (specific line numbers unknown, but based on content, located in the code segment that outputs filenames)", "description": "A stored XSS vulnerability exists in the file list display functionality. The filename (returned from the '/dws/api/ListCategory' API) is directly output into the HTML in the 'show_media_list' and 'show_media_list2' functions without HTML escaping. An attacker can upload a file with a filename containing a malicious script (e.g., `<script>alert('XSS')</script>.mp3`). When an authenticated user visits the 'category.asp' page, the malicious script will execute in their browser. Since session cookies ('id' and 'key') are accessible via JavaScript (no HttpOnly flag), an attacker could steal session tokens and hijack the user's session. Trigger condition: Attacker uploads a file with a malicious filename; User browses the file list. Exploitation method: Execute arbitrary JavaScript code via XSS, potentially leading to session theft, privilege escalation, or further attacks.", "link_identifiers": ["media_info.files[i].name", "session_id", "session_tok", "/dws/api/ListCategory", "/dws/api/GetFile"], "code_snippet": "In the show_media_list function:\nstr += \"<div>\" + file_name + \"<br>\" + get_file_size(obj.size) + \", \" + m_time + \"</div>\"\nIn the show_media_list2 function:\nbg_str += \"<div>\" + file_name + \"<br>\" + get_file_size(obj.size) + \", \" + m_time + \"</div>\"\nThe filename 'file_name' is directly concatenated into the HTML string without using an escape function.", "risk_score": 7.5, "confidence": 8.5, "notes": "The vulnerability relies on the backend API allowing malicious filenames to be uploaded; it is recommended to verify if the backend filters filenames. Related files: Upload functionality might be in other scripts (e.g., 'webfile.js'). Future analysis direction: Check the file upload mechanism and backend API implementation to confirm filename controllability. This vulnerability is exploitable in an authenticated context, and the attack chain is complete.", "file_path": "wa_www/category.asp"}
{"name": "XSS-login_asp_json_ajax", "location": "login.asp: ~line 80-120 (check function), pandoraBox.js: ~line 600-650 (json_ajax function)", "description": "A reflected cross-site scripting (XSS) vulnerability exists in the login authentication mechanism of 'login.asp'. The vulnerability allows an attacker to inject and execute arbitrary JavaScript code via the username field, leading to session cookie theft and account hijacking. The attack triggers when a user submits a malicious username that causes the server to return an HTML error response containing the unsanitized username. The client-side 'json_ajax' function in 'pandoraBox.js' handles such errors by writing the raw response to the document using 'document.write', executing any embedded scripts. This requires the user to attempt login with the malicious username and fail, which can be achieved through social engineering. The stolen cookies ('uid', 'id', 'key') can then be used to impersonate the user and access their account.", "link_identifiers": ["username input field in login.asp", "dws/api/Login endpoint", "json_ajax function in pandoraBox.js", "document.cookie"], "code_snippet": "From login.asp:\n```javascript\nfunction check() {\n    // ...\n    var username = $(\"#username\").val();\n    var password = $(\"#password\").val();\n    // First AJAX call to get challenge\n    var param = { url: 'dws/api/Login', arg: '' };\n    var data = json_ajax(param);\n    // Second AJAX call with username and hashed password\n    param.arg = 'id=' + username + '&password=' + digs;\n    var data = json_ajax(param);\n    // ...\n}\n```\nFrom pandoraBox.js:\n```javascript\nfunction json_ajax(param) {\n    // ...\n    var ajax_param = {\n        type: \"POST\",\n        async: false,\n        url: param.url,\n        data: param.arg,\n        dataType: \"json\",\n        success: function(data) {\n            if (data['status'] != 'fail') {\n                myData = data;\n                return;\n            }\n            alert('Error: ' + drws_err[data['errno']]);\n            // ...\n        },\n        error: function(xhr, ajaxOptions, thrownError) {\n            if (xhr.status == 200) {\n                try {\n                    setTimeout(function() {\n                        document.write(xhr.responseText);\n                    }, 0);\n                } catch (e) {}\n            } else {}\n        }\n    };\n    // ...\n}\n```", "risk_score": 6.0, "confidence": 8.0, "notes": "This vulnerability requires the server to reflect the username in error responses without proper sanitization, which is a common practice. The attack depends on user interaction (entering a malicious username) and a failed login attempt. While the user is a non-root user, session hijacking could lead to unauthorized access to the user's privileges. Further verification should include testing the 'dws/api/Login' endpoint with malicious input to confirm server-side reflection. Additional analysis of other pages may reveal more severe vulnerabilities, but this is the most exploitable issue found in 'login.asp'.", "file_path": "wa_www/login.asp"}
{"name": "buffer-overflow-main", "location": "get_set:0x00400d44 main (specifically at the ncc_socket_recv call around 0x00400e00 based on decompilation context)", "description": "A stack-based buffer overflow occurs in the main function when ncc_socket_recv is called. The function sets uStack_a48 to 0x100 (256 bytes) but provides auStack_a50, a stack buffer of only 4 bytes. This mismatch allows an attacker to send more than 4 bytes of data, overflowing the buffer and corrupting adjacent stack variables, including the return address. The vulnerability is triggered by sending crafted network data to the service. As the program may run with elevated privileges (e.g., via CGI or network service), successful exploitation could lead to arbitrary code execution. The attack chain is: network input → ncc_socket_recv with oversized data → buffer overflow → control of execution flow.", "link_identifiers": ["ncc_socket_recv", "auStack_a50", "uStack_a48"], "code_snippet": "// From main function decompilation\nuStack_a48 = 0x100; // Size set to 256 bytes\nuStack_a44 = 0x310;\nuStack_a40 = 0;\niStack_a3c = 0;\npcStack_a38 = NULL;\niStack_a3c = (**(loc._gp + -0x7fc4))(acStack_434); // strlen call\npcStack_a38 = acStack_434;\niVar3 = (**(loc._gp + -0x7f70))(uStack_a4c, &uStack_a48, auStack_a50); // ncc_socket_recv call\n// auStack_a50 is defined as uchar auStack_a50 [4]; (4-byte buffer)\n// But uStack_a48 is 0x100, allowing up to 256 bytes to be written", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability is verified through decompilation evidence. Exploitation depends on the service's accessibility and privileges. Further analysis could involve testing the network protocol and identifying exact offset for overwriting the return address. No other exploitable issues were found in helper functions.", "file_path": "sbin/get_set"}
{"name": "buffer-overflow-fcn.00401658", "location": "iwpriv:0x00401658 fcn.00401658", "description": "A buffer overflow vulnerability was identified in the 'iwpriv' binary within the function fcn.00401658 when processing ioctl commands of type 0x6000. The vulnerability arises from the use of a strcpy-like function to copy user-controlled data from command-line arguments into a fixed-size stack buffer (auStack_10b4 of 127 bytes) without length validation. An attacker with valid login credentials (non-root user) can trigger this by providing a specially crafted long string as part of the command-line arguments for a specific ioctl command. This could lead to stack buffer overflow, allowing overwrite of adjacent stack data including return addresses, potentially resulting in arbitrary code execution or denial of service. The vulnerability is triggered when the command-line arguments activate the type 0x6000 handling path in the code.", "link_identifiers": ["argv", "ioctl commands", "auStack_10b4"], "code_snippet": "// From decompilation of fcn.00401658\nif (uVar15 == 0x6000) {\n    ppuVar16 = apuStack_1034;\n    for (iVar2 = 0; iVar2 < uVar3; iVar2 = iVar2 + 1) {\n        pcVar21 = loc._gp;\n        if (iVar2 != 0) {\n            uVar4 = (**(loc._gp + -0x7fb4))(param_5);\n            (**(loc._gp + -0x7ef0))(\"           %.*s\", uVar4, \"                \");\n        }\n        iVar17 = ppuVar16 + 2;\n        ppuVar16 = ppuVar16 + 4;\n        (**(pcVar21 + -0x7f48))(iVar17, auStack_10b4);  // Vulnerable strcpy-like call\n        (**(loc._gp + -0x7f1c))(auStack_10b4);\n    }\n    return 0;\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "The function at offset -0x7f48 from loc._gp is likely strcpy based on the two-argument call and the presence of strcpy in the import table. The buffer auStack_10b4 is only 127 bytes, and user input from command-line arguments can exceed this size. Further analysis is needed to confirm the exact exploitation scenario, including the availability of the binary to non-root users and the stack layout for successful code execution. Additional functions like fcn.00400f1c and fcn.00401154 should be examined for similar vulnerabilities.", "file_path": "bin/iwpriv"}
{"name": "command-injection-main", "location": "iapp:0x004021ec and 0x00402220 (main function)", "description": "A command injection vulnerability was discovered in the 'iapp' program, allowing attackers to execute arbitrary commands through malicious interface names. The program uses system calls to execute routing commands (such as 'route delete' and 'route add'), where the interface name is directly obtained from command-line arguments and embedded into the command string via sprintf, without any input filtering or validation. Attackers can provide interface names containing shell metacharacters (such as semicolons or backticks) to inject and execute arbitrary commands. Since the program typically runs with root privileges (such as when creating /var/run/iapp.pid), successful exploitation could lead to complete system control. Trigger condition: When an attacker has valid login credentials and can execute the iapp command, providing a malicious interface name (e.g., 'wlan0; malicious_command'). The exploitation method is straightforward and direct, requiring no complex memory manipulation.", "link_identifiers": ["Command-line argument (interface name)", "Global variable storing interface name", "system command string"], "code_snippet": "0x004021ec: 8f99805c lw t9, -sym.imp.sprintf(gp)\n0x004021f0: 00602821 move a1, v1 ; Command string 'route delete -net 224.0.0.0 netmask 240.0.0.0 dev %s'\n0x004021f4: afa30158 sw v1, (var_158h)\n0x004021f8: 02803021 move a2, s4 ; Interface name (from global variable)\n0x004021fc: 0320f809 jalr t9 ; Call sprintf to construct command\n0x00402200: 02602021 move a0, s3 ; Buffer address\n0x00402208: 8f9980dc lw t9, -sym.imp.system(gp)\n0x0040220c: 0320f809 jalr t9 ; Call system to execute command\n0x00402210: 02602021 move a0, s3 ; Command string buffer", "risk_score": 9.0, "confidence": 9.0, "notes": "This vulnerability requires the program to run with root privileges, which is common in network services. Attackers can directly control the input through command-line arguments, and the exploitation chain is complete and verifiable. It is recommended to strictly validate and filter interface names, or use secure functions like execve instead of system. Further analysis should check if similar issues exist in other input points (such as network packets and FIFO files).", "file_path": "bin/iapp"}
{"name": "Client-JS-Injection-deviceinfo.js", "location": "deviceinfo.js:1 DeviceInfo()", "description": "The 'deviceinfo.js' file is globally writable (permissions: rwxrwxrwx) and is dynamically loaded by 'features.js' using $.getScript in a client-side JavaScript context. An attacker with non-root login credentials can modify this file to inject malicious JavaScript code, which will execute in the browser of any user who accesses the web page that relies on 'features.js'. This could lead to client-side attacks such as session hijacking or configuration tampering within the web interface. However, the vulnerability is limited to client-side execution and does not provide a direct path to system-level privilege escalation or remote code execution on the device. The trigger condition is when the web page loading 'features.js' is accessed, and the exploitation requires the attacker to have write access to the file, which is already available due to the permissions.", "link_identifiers": ["/config/deviceinfo.js", "/config/features.js"], "code_snippet": "// From deviceinfo.js\nfunction DeviceInfo()\n{\n\tthis.bridgeMode = true;\n\tthis.featureVPN = true;\n\t// ... other properties\n}\n\n// From features.js\n$.getScript(\"/config/deviceinfo.js\", function(){\n\tDeviceInfo.prototype = new CommonDeviceInfo();\n\tDeviceInfo.prototype.constructor = DeviceInfo;\n\tvar currentDevice = new DeviceInfo();\n\tsessionStorage.setItem('currentDevice', JSON.stringify(currentDevice));\n});", "risk_score": 3.0, "confidence": 8.0, "notes": "This finding is based on direct evidence of file permissions and code usage. The risk is low because the exploitation is confined to the client-side and does not escalate privileges on the device. Further analysis could involve checking if the web server or other server-side components use these files, but based on the current code, it appears to be client-only. No additional input sources or cross-component interactions were identified in this analysis.", "file_path": "www/config/deviceinfo.js"}
{"name": "Sensitive-Data-Exposure-key_file.pem", "location": "key_file.pem:1 (file content)", "description": "The file 'key_file.pem' contains an unencrypted RSA private key and certificate, exposing highly sensitive information. The issue manifests as the private key being readable by non-root users, triggered when an attacker has filesystem access and can read the file. Constraints include the file being located in an accessible directory and having improper permission settings. Potential attack methods include using the private key for identity impersonation (such as SSH login or TLS connection decryption), man-in-the-middle attacks, or privilege escalation. The relevant technical detail is that the private key is stored in plaintext, lacking encryption or access control.", "link_identifiers": ["key_file.pem"], "code_snippet": "-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQDLLKEQqDuuLDhF7s8TqHGofvXWMJNopCgbHyGRGt9s3bB+2A7a\nrnNjzTlN5MOGwWE/ELXjm0fQDLIiIBgalke5StNqF5i3FHteMN16fdd83BaM2/L6\nU3kyYQ9K6m5GXeoOt6x3mP0xJf1ADovPc59reepPL3wi4eSMXQOpnl0gUwIDAQAB\nAoGAVA97+DNSteZPxgdfH8gCdm9I8TyZ0KKSgV4o+is/I4C5ZFGqG6ovzav8OJEc\noKVjwb79MlVtqdOG4/2ZW26v72nh/V9OtIpNdHcaulkoJglMwq/w/xIgEwctS6c1\nse/UlM8DEH/WBYtMMJ6/nwJwDB6x8+WD7Hm+vjwVozuUOSkCQQDwBW4AD+FN97RP\nNwSBS64qyhFB7IstT7EPCarbnqPTbEGM39y/PKgPT5wUIS3Zkih09OizsZuroJpS\nXAXhlAXHAkEA2LM8NtdNibGWjzA5PhLCUf225UjTN0ccjSZLKqjW4N/G4hVy6jtL\n9noENq/zir85dTIaIxUpVy9fhjHuq7YhFQJBAJavUffIAHKqaBCzQajKknValqsE\njfvMZCREtXdbiQ5akGyYvkVxFzFFkX8xtU86axvCBbWKc2i0Uy4Rh7+u5lECQBcl\nTdEtvgJvDX3N0M9ogYjwaJCk7qqA1fPdmzm7PvhV7pBHajbKjpqM/dY5hPHU6vYx\nm8kTgY7maHWU78E3euECQH1AJSESOXzLGcsPPkY0a0M2SWPU+W2SSoxhHnbmG1vG\nKuBYPVK1emsIxwVdGlE13EEaXn9qiK8OcQNKzbEqrww=\n-----END RSA PRIVATE KEY-----\n-----BEGIN CERTIFICATE-----\nMIICoTCCAgqgAwIBAgIJAMu7EW1f923hMA0GCSqGSIb3DQEBBQUAMEAxCzAJBgNV\nBAYTAlRXMQ8wDQYDVQQIEwZUQUlXQU4xDzANBgNVBAcTBlRBSVBFSTEPMA0GA1UE\nChMGRC1MaW5rMB4XDTEzMTExMTAxMjMwNFoXDTIzMTEwOTAxMjMwNFowQDELMAkG\nA1UEBhMCVFcxDzANBgNVBAgTBlRBSVdBTjEPMA0GA1UEBxMGVEFJUEVJMQ8wDQYD\nVQQKEwZELUxpbmswgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMssoRCoO64s\nOEXuzxOocah+9dYwk2ikKBsfIZEa32zdsH7YDtquc2PNOU3kw4bBYT8QteObR9AM\nsiIgGBqWR7lK02oXmLcUe14w3Xp913zcFozb8vpTeTJhD0rqbkZd6g63rHeY/TEl\n/UAOi89zn2t56k8vfCLh5IxdA6meXSBTAgMBAAGjgaIwgZ8wHQYDVR0OBBYEFIvH\n8ES2FWMrzwH0fIj2nJf1nIhGMHAGA1UdIwRpMGeAFIvH8ES2FWMrzwH0fIj2nJf1\nnIhGoUSkQjBAMQswCQYDVQQGEwJUVzEPMA0GA1UECBMGVEFJV0FOMQ8wDQYDVQQH\nEwZUQUlQRUkxDzANBgNVBAoTBkQtTGlua4IJAMu7EW1f923hMAwGA1UdEwQFMAMB\nAf8wDQYJKoZIhvcNAQEFBQADgYEAc3dlDo8BCZHN6iwUjAojGQKuEok8hNFgnTh+\nDI3HZDEGWajn8ytgqFMJvSqMq94mx4KsMUCyqsAfiNlyI22DgrAYGG8aAVOLEZIV\nAT1opv500zQA6gVA4UXecjVv6QjPe8uJRY7BljP1SLg5XRgyKrHsyzedzN5p9nuN\nKajGJc0=\n-----END CERTIFICATE-----", "risk_score": 8.5, "confidence": 9.0, "notes": "This finding is based on file content analysis; the exposed private key can be directly exploited. It is recommended to further verify file permissions (e.g., using 'ls -l key_file.pem') and how system components use this private key to confirm the completeness of the attack chain. Related files may include service configuration files that use this private key.", "file_path": "etc/key_file.pem"}
{"name": "PrivEsc-ShadowSample", "location": "shadow.sample:1", "description": "The shadow.sample file contains the root user's password hash (MD5 format: $1$KEKJV2R0$TFJ4jy7waGKrjdNHwPGzV.), and the file permissions are set to 777 (-rwxrwxrwx), allowing any user (including non-root users) to read it. An attacker (a logged-in non-root user) can easily read the file, extract the hash value, and use offline cracking tools (such as John the Ripper or hashcat) to attempt to crack the password. If the password strength is weak, the attacker may obtain the root password, thereby escalating privileges to root. The trigger condition is that the attacker has file read permissions, with no additional conditions required. Exploitation methods include directly reading the file and using cracking tools for dictionary or brute-force attacks.", "link_identifiers": ["shadow.sample"], "code_snippet": "root:$1$KEKJV2R0$TFJ4jy7waGKrjdNHwPGzV.:14587:0:99999:7:::", "risk_score": 8.0, "confidence": 8.0, "notes": "Further verification of the password hash strength is needed to assess the cracking difficulty. It is recommended to check the permissions of other similar files in the system (such as /etc/shadow) to prevent similar information leaks. This finding is related to permission management issues and may affect overall system security.", "file_path": "etc/shadow.sample"}
{"name": "XSS-FileFolderDisplay", "location": "folder_view.asp: function show_folder_content (approx. lines 300-400) and function get_sub_tree (approx. lines 350-400)", "description": "A Cross-Site Scripting (XSS) vulnerability exists in the file list and folder tree display. File names and folder names (user-controlled input) are not HTML-escaped when displayed and are directly inserted into innerHTML and event handlers. An attacker can create or upload file names or folder names containing malicious scripts (for example: <script>alert('XSS')</script>). When other users view the file list or navigate the folder tree, the script will execute in their browser. This may lead to session theft, privilege escalation, or other malicious actions. Trigger condition: After the attacker uploads a file or creates a folder, the victim views the relevant page. Exploitation method: The attacker uses valid login credentials to upload a malicious file and tricks an administrator or other user into accessing the file management page.", "link_identifiers": ["file_name", "folder_name", "APIGetFileURL", "show_folder_content", "get_sub_tree", "current_path", "current_volid"], "code_snippet": "// In the show_folder_content function\ncell_html = \"<input type=\\\"checkbox\\\" id=\\\"\" + sum + \"\\\" name=\\\"\" + file_name + \"\\\" value=\\\"1\\\" class=\\\"chk\\\" onclick=\\\"shiftkey(event);\\\" />\"\n                + \"<a href=\\\"\" + APIGetFileURL(path,volid,file_name) + \"\\\" target=\\\"_blank\\\">\"\n                + \"<div>\" + file_name + \"<br>\" + get_file_size(obj.size) + \", \" + m_time + \"</div></a>\";\n// In the get_sub_tree function\nmy_tree += \"<li id=\\\"\" + li_id + \"\\\" class=\\\"tocollapse\\\">\"\n        + \"<a href=\\\"#\\\" title=\\\"\" + obj.name + \"\\\" \" \n        + \"onClick=\\\"click_folder('\" + li_id + \"', '\" + current_volid + \"', '\" + obj.mode + \"')\\\">\"\n        + obj.name + \"</a></li>\"\n        + \"<li></li>\"\n        + \"<li><span id=\\\"\" + li_id + \"-sub\\\"></span></li>\";", "risk_score": 7.0, "confidence": 8.0, "notes": "This is a stored XSS vulnerability. The attack chain is complete and verifiable from the front-end code. It is recommended to add input validation and output encoding on the backend. Related files: May affect all pages using the same display logic. Subsequent checks should examine the backend API implementation to ensure path traversal and file upload vulnerabilities are mitigated.", "file_path": "wa_www/folder_view.asp"}
{"name": "command-injection-upgrade_firmware", "location": "bulkagent:0x40379c upgrade_firmware", "description": "A command injection vulnerability exists in the 'upgrade_firmware' function, where user-controlled input from network packets is unsafely incorporated into a 'system' call. Attackers can exploit this by sending crafted firmware upgrade commands containing shell metacharacters, leading to arbitrary command execution as the user running 'bulkagent'. The vulnerability is triggered when the command type 0x7eff or 0x7f00 is processed, calling 'upgrade_firmware' with attacker-controlled data. The function uses 'snprintf' to build a command string but does not validate or escape the input, allowing injection into the 'bulkUpgrade' command.", "link_identifiers": ["ipaddr_server", "/var/tmp/", "bulkUpgrade"], "code_snippet": "In upgrade_firmware (0x40379c):\n- Constructs command using snprintf: 'bulkUpgrade -f \"%s%s\" -force' with user-controlled strings\n- Calls system() with the constructed command\nEvidence from control_command (0x404118) shows command type 0x7eff/0x7f00 leads to upgrade_firmware call with network data.", "risk_score": 9.0, "confidence": 9.0, "notes": "The attack requires network access to the bulkagent service. As a non-root user, exploitation can lead to privilege escalation if bulkagent runs with elevated privileges. Recommend immediate input sanitization and avoiding system() with user input.", "file_path": "sbin/bulkagent"}
{"name": "BufferOverflow-callback_ccp_hnap", "location": "ncc2:0x0047b3b0 callback_ccp_hnap", "description": "A potential buffer overflow vulnerability exists in the HNAP request handler (callback_ccp_hnap) where user-controlled input from network requests is copied into fixed-size stack buffers without proper bounds checking. Specifically, the function uses a string copy operation (likely strcpy) to copy data from the input parameter (param_2+0x41) into a 128-byte buffer (auStack_4b0) and a 1024-byte buffer (auStack_430). The lack of length validation before copying allows an attacker to overflow the buffer by sending a crafted HNAP request with excessive data. This could lead to arbitrary code execution if the stack is executable or via return-oriented programming (ROP) in the MIPS architecture. The vulnerability is triggered when processing HNAP requests, which are accessible to authenticated users via network interfaces.", "link_identifiers": ["HNAP protocol", "SOAP action parameters", "network interface"], "code_snippet": "// Decompiled code from callback_ccp_hnap\nuchar auStack_4b0 [128]; // 128-byte buffer on stack\nuchar auStack_430 [1024]; // 1024-byte buffer on stack\n// ...\n// Copy user input from param_2+0x41 into auStack_4b0 without bounds check\n(**(iVar10 + -0x7f18))(auStack_4b0, param_2 + 0x41); // Likely strcpy equivalent\n// Similar copies to auStack_430 and other buffers occur later in the function", "risk_score": 7.5, "confidence": 8.0, "notes": "The evidence is based on decompilation analysis showing unchecked copy operations. However, further validation is needed to confirm the exact function used (e.g., strcpy) and to test exploitability in a real environment. The binary is for MIPS architecture, and exploitation may require specific techniques due to platform constraints. Additional input points like CGI handlers should be investigated for similar issues.", "file_path": "sbin/ncc2"}
{"name": "NULL-Pointer-Dereference-pptp_inbound_pkt", "location": "nf_nat_pptp.ko:Unknown line number sym.pptp_inbound_pkt function", "description": "A NULL pointer dereference vulnerability was discovered in the sym.pptp_inbound_pkt function. The code calls (*NULL)(), and when processing specific PPTP inbound packets, if the value of a field in the packet (uVar1, possibly corresponding to PPTP message type or other identifier) is 0xb (11) or 0xc to 0xf (12-15), it will cause a kernel crash (denial-of-service). An attacker, as a non-root user with valid login credentials, can trigger this vulnerability by sending malicious PPTP packets over the network (using TCP port 1723 or GRE). The vulnerability trigger condition depends on the packet content, lacking proper input validation and boundary checks. The potential exploitation method is only DoS; no privilege escalation or other more severe attack chains have been discovered.", "link_identifiers": ["PPTP packet field (uVar1)", "TCP port 1723", "GRE protocol"], "code_snippet": "uVar1 = *in_a3;\nif (uVar1 != 0xb) {\n    if (uVar1 < 0xc) {\n        if (uVar1 != 8) {\n            return true;\n        }\n        halt_baddata();\n    }\n    if (2 < uVar1 - 0xd) {\n        halt_baddata();\n    }\n}\niVar2 = (*NULL)();\nreturn iVar2 != 0;", "risk_score": 5.0, "confidence": 7.0, "notes": "This vulnerability only leads to denial-of-service; no complete attack chains such as privilege escalation have been discovered. Further validation of the PPTP packet format is needed to confirm the specific meaning of uVar1. It is recommended to analyze other functions (such as sym.pptp_outbound_pkt) to look for similar issues. Since it is a kernel module, the vulnerability may affect system stability, but the exploitation conditions are limited.", "file_path": "lib/modules/2.6.30.9/kernel/net/ipv4/netfilter/nf_nat_pptp.ko"}
{"name": "Command-Injection-set_timeZone", "location": "libapmib.so:0x5990 (system call in set_timeZone)", "description": "The `set_timeZone` function in libapmib.so contains a command injection vulnerability due to improper sanitization of user-controlled input from the NTP_TIMEZONE MIB setting (ID 0x99). The function retrieves the timezone string via `apmib_get`, processes it with `gettoken` to extract the first token (using space as delimiter), and then uses this token in a `sprintf` format string (e.g., 'GMT%s:30%s' or 'GMT%s%s') that is incorporated into a shell command executed via `system`. The command constructed is 'echo %s >/var/TZ', where the first %s is the formatted string containing the user-controlled token. An attacker with valid login credentials can set the NTP_TIMEZONE value to a string containing shell metacharacters (e.g., '; malicious_command #') to break out of the intended command and execute arbitrary commands. The vulnerability is triggered when `set_timeZone` is called, which typically occurs during timezone configuration updates via MIB settings. The function includes multiple `strcmp` checks against hardcoded timezone strings, but if no match is found, it falls back to a default path where the user input is still used unsanitized. The lack of input validation allows command injection regardless of the strcmp outcomes.", "link_identifiers": ["NTP_TIMEZONE (MIB ID 0x99)", "DAYLIGHT_SAVE (MIB ID 0x11a)", "apmib_set", "apmib_get", "set_timeZone", "/var/TZ"], "code_snippet": "Relevant code from set_timeZone disassembly:\n0x5990: lw t9, -sym.imp.system(gp)\n0x5994: jalr t9  # Executes the command string\n\nPreceding code constructs the command:\n0x5980: lw t9, -sym.imp.sprintf(gp)\n0x5984: jalr t9  # Formats 'echo %s >%s' with user input\n0x5988: addiu a1, a1, -0x6e38  # 'echo %s >%s' string\n0x598c: move a0, s0  # Command buffer\n0x5990: jalr t9  # Calls system\n\nThe user input is derived from:\n0x5848: lw t9, -sym.gettoken(gp)\n0x584c: jalr t9  # Gets first token of timezone string\n0x5850: move a2, zero  # Delimiter space\n0x5854: move a0, s0  # Input buffer from apmib_get(0x99)", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability requires that set_timeZone is called by a process after the MIB value is set. This is likely triggered through configuration interfaces (e.g., web UI or CLI) accessible to authenticated users. The process executing set_timeZone may run with elevated privileges (e.g., root), leading to full system compromise. Further analysis should identify all callers of set_timeZone in the system to confirm exploitability in context. The use of strcpy and sprintf in this function also indicates potential for buffer overflows, but command injection is the immediately exploitable issue.", "file_path": "lib/libapmib.so"}
