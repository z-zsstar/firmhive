{"name": "XSS-wirelessScan-fillAcc", "location": "wireless_extra.js: wirelessScan function and fillAcc function", "description": "XSS vulnerability exists in the wireless network scan result display function. When a user performs a wireless scan, parameters such as SSID, MAC address, and channel in the scan results are inserted into the DOM via innerHTML without HTML escaping. An attacker can set a malicious SSID containing JavaScript code; when a logged-in user visits the scan page and performs a scan, the XSS payload will automatically execute. Specific manifestations: 1) In the wirelessScan function, scan result data like SSID, MAC, and channel are directly used for innerHTML; 2) In the fillAcc function, SSID and other parameters are also inserted directly without escaping. Trigger condition: An attacker broadcasts a malicious SSID, and the victim uses the device's wireless scan function. Exploitation method: The injected JavaScript can steal session cookies, modify device configuration, redirect the user, or perform other malicious actions.", "link_identifiers": ["/goform/ApclientScan", "/goform/WrlExtraGet", "wireless_extra.js"], "code_snippet": "// In the wirelessScan function:\nnc=document.createElement('td');\nnr.appendChild(nc);\nnc.innerHTML = str[0];  // str[0] is the SSID, inserted directly\nnc.className = \"td-fixed\";\nnc.title = decodeSSID(str[0]);\n\n// In the fillAcc function:\nvar ssid = siblings[0].innerHTML;  // Retrieved directly from the DOM\n// ...\n$(\"#remoteSsid\").val(ssid);  // Set value, but previously inserted via innerHTML\n// Multiple innerHTML uses unescaped data", "risk_score": 7.5, "confidence": 8.5, "notes": "This is a reflected XSS vulnerability that requires user interaction (performing a scan). Since the attacker already possesses login credentials, the vulnerability can be used for privilege escalation or persistent attacks. It is recommended to perform HTML escaping on all user input before using innerHTML. Further verification is needed to check if the backend filters SSID length and content, but the lack of escaping on the client side is certain. Related files: May affect other pages that use the scan function.", "file_path": "webroot/js/privatejs/wireless_extra.js"}
{"name": "XSS-subForm", "location": "gozila.js: ~line 650 (subForm function)", "description": "An XSS vulnerability exists in the `subForm` function. The HTML generated by `genForm` only escapes double quote characters but does not handle other HTML special characters (such as `<`, `>`). When an attacker controls configuration values (via form input) and injects malicious scripts, the `subForm` function uses `innerHTML` to insert unescaped HTML into the DOM, leading to script execution. Trigger condition: An attacker, as a logged-in user, modifies form field values (e.g., via browser developer tools) and triggers a `subForm` call (e.g., by submitting the form). Exploitation method: Inject `<script>alert('XSS')</script>` or similar payloads to steal session cookies or perform administrative actions. The vulnerability relies on bypassing client-side validation, but as a logged-in user, the attacker can directly manipulate form data.", "link_identifiers": ["CA (Configuration Array)", "Form field names (processed via form2Cfg)", "Hidden input fields generated by genForm"], "code_snippet": "function subForm(f1, a, d, g) {\n    var msg = genForm('OUT', a, d, g);\n    /*DEMO*/\n    if (!confirm(msg))\n        return;\n    /*END_DEMO*/\n\n    var newElem = document.createElement(\"div\");\n    newElem.innerHTML = msg;\n    f1.parentNode.appendChild(newElem);\n    f = document.OUT;\n    f.submit();\n}\n\n// Related functions genForm and frmAdd:\nfunction genForm(n, a, d, g) {\n    frmHead(n, a, d, g);\n    var sub = 0;\n    for (var i = 0; i < CA.length; i++) {\n        if (CA[i].v != CA[i].o) {\n            frmAdd(\"SET\" + sub, String(CA[i].i) + \"=\" + CA[i].v);\n            sub++;\n        }\n    }\n    if (frmExtraElm.length)\n        OUTF += frmExtraElm;\n    frmExtraElm = '';\n    frmEnd();\n    return OUTF;\n}\n\nfunction frmAdd(n, v) {\n    set1 = \"<input type=hidden name=\" + n + \" value=\\\"\";\n    v = v.replace(/\\\"/g, \"&quot;\");\n    var r = new RegExp(set1 + \".*\\n\", \"g\");\n    if (OUTF.search(r) >= 0)\n        OUTF = OUTF.replace(r, (set1 + v + \"\\\">\\n\"));\n    else\n        OUTF += (set1 + v + \"\\\">\\n\");\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "This vulnerability requires the attacker to have obtained login credentials, but as a non-root user, they can exploit this vulnerability to escalate privileges or compromise device security. It is recommended to further verify if the backend performs additional input filtering and to check other places where `innerHTML` is used (such as the `setpage` and `decodeSSID` functions). Subsequent analysis should focus on the backend processing flow of form submissions to confirm the complete attack chain.", "file_path": "webroot/js/gozila.js"}
{"name": "Command-Injection-formexeCommand", "location": "httpd:0x0046eefc sym.formexeCommand", "description": "In the `formexeCommand` function, the user-provided 'cmdinput' HTTP parameter is directly used to construct system commands, lacking input validation and escaping. Attackers can inject shell metacharacters (such as ; & |) to execute arbitrary commands. Trigger condition: The attacker sends an HTTP request to the `formexeCommand` processing endpoint, providing a 'cmdinput' parameter containing malicious commands. Constraint: The attacker requires valid login credentials but does not need root privileges. Potential attacks include privilege escalation, file system access, or network reconnaissance. The code logic compares user input with predefined commands (cd, ls, cat, echo, pwd, ping); if it is not a predefined command, the user input is executed directly.", "link_identifiers": ["cmdinput", "/tmp/cmdTmp.txt", "websGetVar", "doSystemCmd", "formexeCommand"], "code_snippet": "// Get user input\nuVar1 = (**(iVar4 + -0x78cc))(*&uStackX_0,*(iVar4 + -0x7fd8) + -0x3bc,*(iVar4 + -0x7fd8) + -0x3b0); // websGetVar gets 'cmdinput'\n(**(iVar4 + -0x71b0))(auStack_2308,uVar1); // Copy to buffer\n// After checking predefined commands, for non-predefined commands:\n// str._s____tmp_cmdTmp.txt\n(**(iVar4 + -0x7860))(*(iVar4 + -0x7fd8) + -0x388,auStack_2308); // Build command string\n// Finally executed via doSystemCmd", "risk_score": 8.0, "confidence": 9.0, "notes": "The vulnerability exploitation chain is complete: from the HTTP input point ('cmdinput') to the dangerous operation (doSystemCmd). httpd typically runs with root privileges, so command execution may gain root access. It is recommended to further verify the specific URL endpoint of `formexeCommand`, but code analysis shows a clear vulnerability pattern.", "file_path": "bin/httpd"}
{"name": "Command-Injection-wps_save", "location": "libwifi.so:0x00022950 sym.wps_save", "description": "The 'wps_save' function in 'libwifi.so' contains a command injection vulnerability due to unsanitized user input being passed directly to 'doSystemCmd'. The function takes three arguments (arg_c8h, arg_cch, arg_d0h), where 'arg_d0h' is used in formatted strings for 'doSystemCmd' calls without validation. An attacker can inject arbitrary commands by controlling 'arg_d0h', such as through semicolons or backticks, leading to command execution in the context of the process using this library. Trigger conditions include calling 'wps_save' with malicious 'arg_d0h', which could be achieved via network interfaces, IPC, or other components that invoke this function. The vulnerability allows full command execution, potentially leading to privilege escalation or system compromise if the process has elevated privileges.", "link_identifiers": ["wps_save", "doSystemCmd", "arg_d0h", "nvram set"], "code_snippet": "0x00022950: lw a1, (arg_d0h)  ; Load user-controlled arg_d0h\n0x00022954: lw t9, -sym.imp.doSystemCmd(gp)  ; Load doSystemCmd function\n0x0002295c: jalr t9  ; Call doSystemCmd with format string 'nvram set %s_wps_mode=enabled' and a1\nSimilar calls at 0x000229c8, 0x00022a24, etc., where arg_d0h is used in doSystemCmd without sanitization.", "risk_score": 8.5, "confidence": 9.0, "notes": "This vulnerability requires that 'wps_save' is callable with user-controlled input, which may be possible through web interfaces, API endpoints, or command-line tools. Further analysis is needed to identify specific call paths and interfaces that expose this function. The library is stripped, but exported functions are accessible. Assumes the attacking user has valid login credentials and can trigger the function call. Recommended to check for input validation in callers and implement sanitization of arguments passed to 'wps_save'.", "file_path": "lib/libwifi.so"}
{"name": "buffer-overflow-ufilter-url-parsing", "location": "ufilter:0x004042c0 fcn.004042c0, ufilter:0x00404450 fcn.00404450", "description": "A buffer overflow vulnerability exists in the 'ufilter' binary within the URL and file type parsing functions. The vulnerability arises when processing command-line arguments for URL filtering, specifically in functions that handle comma-separated lists of URLs and file types. The functions fcn.004042c0 and fcn.00404450 use strcpy and memcpy to copy user-provided strings into a fixed-size buffer (64 bytes per entry, with up to 16 entries) without proper bounds checking. If an attacker provides a string longer than 64 bytes, it can overflow the buffer, potentially overwriting adjacent memory, including return addresses or function pointers. This can lead to arbitrary code execution or denial of service. The vulnerability is triggered when a non-root user executes 'ufilter' with the URL filter module and provides maliciously long URLs or file types via the 'set' command.", "link_identifiers": ["command-line arguments", "sym.set_url", "fcn.004042c0", "fcn.00404450", "/dev/ufilter"], "code_snippet": "In fcn.004042c0:\n0x00404354      2000c58f       lw a1, (var_20h)  ; Load user input string\n0x00404358      bc81998f       lw t9, -sym.imp.strcpy(gp)  ; Call strcpy\n0x0040435c      00000000       nop\n0x00404360      09f82003       jalr t9  ; Execute strcpy without bounds check\n\nIn fcn.00404450:\n0x004044e4      2000c58f       lw a1, (var_20h)  ; Load user input string\n0x004044e8      bc81998f       lw t9, -sym.imp.strcpy(gp)  ; Call strcpy\n0x004044ec      00000000       nop\n0x004044f0      09f82003       jalr t9  ; Execute strcpy without bounds check", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability is directly exploitable via command-line arguments, and the attack chain is verifiable through code analysis. However, actual exploitation may require specific conditions, such as the binary being executable by non-root users or having sufficient privileges. Further analysis could involve testing for privilege escalation if 'ufilter' runs with elevated permissions. The functions fcn.004042c0 and fcn.00404450 are called from sym.set_url, which handles URL filter settings. Additional input points like other filter modules (e.g., MAC filtering) should be investigated for similar issues.", "file_path": "usr/sbin/ufilter"}
{"name": "StackBufferOverflow-upnp_device_attach", "location": "libupnp.so:0x7700 sym.upnp_device_attach", "description": "Stack-based buffer overflow in the sym.upnp_device_attach function due to use of strcpy without bounds checking. The function copies a string from UPnP device data (external input) to a fixed-size stack buffer (at sp+0xa0). When a crafted UPnP message contains a device string longer than 212 bytes, it overflows the buffer and overwrites the saved return address (at sp+0x174), enabling arbitrary code execution. Trigger condition: attacker sends a malicious UPnP device announcement or similar message. Exploitation requires the attacker to control the device string content and length to overwrite the return address with shellcode or ROP chain addresses.", "link_identifiers": ["UPnP device description messages", "network interface"], "code_snippet": "0x000076f8      lw t9, -sym.imp.strcpy(gp)\n0x000076fc      addiu a1, s3, 4             ; source: device data string\n0x00007700      jalr t9                     ; call strcpy\n0x00007704      move a0, s5                ; destination: stack buffer at sp+0xa0", "risk_score": 8.0, "confidence": 8.0, "notes": "The stack buffer has a fixed size, and the distance to the return address is 212 bytes, making overflow straightforward. Assumes no stack protections (e.g., ASLR) are enabled in the firmware environment. Recommended to verify input source in upnp_ifattach and network handling functions. No other exploitable vulnerabilities found in strcpy/strcat usage after full analysis.", "file_path": "usr/lib/libupnp.so"}
{"name": "command-injection-igd_osl_nat_config", "location": "igd:0x00402084 igd_osl_nat_config (function entry), igd:0x0040226c (strcat call appends user input), igd:0x00402190 (_eval call executes command)", "description": "A command injection vulnerability was discovered in the 'igd' binary, allowing attackers to execute arbitrary commands via the UPnP AddPortMapping operation. The vulnerability originates from the igd_osl_nat_config function not properly sanitizing the user-supplied NewInternalClient parameter when constructing the 'igdnat' command string. Attackers can inject malicious command separators (such as semicolons or backticks) into the NewInternalClient field, causing the _eval function to execute additional commands. Trigger conditions include: an attacker sending a malicious UPnP request to the /control?WANIPConnection endpoint, invoking the AddPortMapping operation, and setting a malicious NewInternalClient value. An example exploitation method is setting NewInternalClient to '127.0.0.1; malicious_command', thereby executing arbitrary commands on the device with service privileges (possibly root).", "link_identifiers": ["NewInternalClient", "/control?WANIPConnection", "igdnat", "router_disable", "igd_port", "/tmp/igd.pid"], "code_snippet": "Key code snippets from the igd_osl_nat_config function:\n- 0x004020f4: sprintf builds the base command 'igdnat -i %s -eport %d -iport %d -en %d'\n- 0x0040226c: strcat appends ' -client ' and the user-controlled s1->1c field (NewInternalClient)\n- 0x00402190: _eval executes the final command string, output redirected to /dev/console\nComplete command example: 'igdnat -i eth0 -eport 80 -iport 8080 -en 1 -client 127.0.0.1; malicious_command'", "risk_score": 7.5, "confidence": 8.0, "notes": "This vulnerability requires the attacker to have access to the UPnP service (typically listening on the local network). It is recommended to verify the specific implementation of the _eval function to confirm command execution behavior. Additionally, the multiple uses of strcpy in the igd_portmap_add function may potentially cause buffer overflows, but the command injection attack chain is more direct and easier to exploit. Subsequent analysis should focus on whether other UPnP operations (such as DeletePortMapping) also have similar issues.", "file_path": "usr/sbin/igd"}
{"name": "Permission-Vulnerability-Shadow", "location": "File: shadow (Full path: /etc/shadow)", "description": "In the '/etc/shadow' file, an MD5 password hash for the root user ($1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1) was found, and the file permissions are set to 777 (-rwxrwxrwx), allowing any non-root user to read, write, and execute. Specific manifestation: After logging in as a non-root user, an attacker can directly access this file to read the password hash. Trigger condition: The attacker possesses valid login credentials (non-root user) and performs a file read operation. Constraints and boundary checks: The file lacks proper access control and has no permission verification. Potential attacks and exploitation methods: The attacker can read the hash and perform offline brute-force attacks (MD5 hashes are vulnerable, especially if the password is weak); upon success, they can obtain root privileges; or they can directly modify the file content (such as clearing the root password) to escalate privileges. Related code logic or technical details: The file is a system password storage file, which should typically be restricted to root read-only, but the permissions are misconfigured here.", "link_identifiers": ["/etc/shadow"], "code_snippet": "File content: root:$1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1:14319::::::", "risk_score": 8.5, "confidence": 8.0, "notes": "This finding is based on clear evidence from the file content and permissions. The attack chain is complete: non-root user reads hash → offline cracking → obtains root privileges. The MD5 hash may be easily cracked, but actual exploitability depends on password strength; it is recommended to further verify password complexity or check for other protection mechanisms (such as hash salting). Associated files: No other direct associations, but it may affect system authentication components. Subsequent analysis direction: Check the permissions of other sensitive files (such as passwd), or analyze the authentication process to confirm the scope of the vulnerability impact.", "file_path": "var/etc/shadow"}
{"name": "Privilege-Escalation-passwd", "location": "passwd", "description": "The passwd file contains encrypted passwords for multiple default user accounts (admin, support, user, nobody) all with UID 0 (root privileges). This exposes a privilege escalation vulnerability: an attacker with non-root user credentials can read the passwd file (typically world-readable) and perform offline password cracking to obtain root access. The attack chain is: 1) Attacker logs in as a non-root user; 2) Attacker reads /etc/passwd; 3) Attacker extracts password hashes; 4) Attacker uses tools like John the Ripper to crack weak passwords; 5) If successful, attacker gains root privileges. Trigger conditions include weak or default passwords, and no shadow password protection. Potential exploitation involves brute-force or dictionary attacks on the hashes.", "link_identifiers": ["passwd"], "code_snippet": "admin:6HgsSsJIEOc2U:0:0:Administrator:/:/bin/sh\nsupport:Ead09Ca6IhzZY:0:0:Technical Support:/:/bin/sh\nuser:tGqcT.qjxbEik:0:0:Normal User:/:/bin/sh\nnobody:VBcCXSNG7zBAY:0:0:nobody for ftp:/:/bin/sh", "risk_score": 7.5, "confidence": 7.0, "notes": "The risk score is based on the complete attack chain and clear security impact (privilege escalation). Confidence is moderated as password strength is unverified; if passwords are default or weak, exploitation is highly likely. Recommend further analysis of password hashes for common defaults, checking for /etc/shadow file existence, and reviewing authentication mechanisms. This finding should be prioritized for password policy enforcement and shadow password implementation.", "file_path": "etc_ro/passwd"}
{"name": "vulnerability-shadow", "location": "shadow:1 (file path)", "description": "The 'shadow' file was found to be readable by all users (permissions 777), containing the root user's MD5 password hash ($1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1). An attacker (non-root user) can directly read this file, obtain the password hash, and attempt to obtain the root password through offline cracking (using tools such as John the Ripper). Once successful, the attacker can escalate privileges to root and gain full control of the device. The trigger condition is simple: the attacker has valid login credentials (non-root user) and can access the file system. Constraint: password strength affects cracking difficulty, but MD5 hash is relatively weak and easy to crack common passwords. Potential attack methods include direct file reading and the use of password cracking tools.", "link_identifiers": ["shadow"], "code_snippet": "File content: root:$1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1:14319::::::\nFile permissions: -rwxrwxrwx", "risk_score": 8.0, "confidence": 9.0, "notes": "This finding is based on direct evidence: the file is readable and contains sensitive hashes. It is recommended to further verify password strength or check other related files (such as passwd) to confirm the complete attack surface. The attack chain is complete: from non-root user reading the file to potential privilege escalation.", "file_path": "etc_ro/shadow"}
{"name": "File-Permission-shadow_private", "location": "shadow_private:1", "description": "The file 'shadow_private' has permissions set to 777, allowing any user to read it. It contains the root user's password hash (MD5: $1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1). An attacker (non-root user) can easily read this file, extract the hash, and use offline tools (such as John the Ripper) to crack the password. If the password is weak, the attacker may obtain root privileges, achieving privilege escalation. The trigger condition is simple: the attacker only needs to execute a read command (e.g., 'cat shadow_private'). Constraints include password complexity and the effectiveness of cracking tools, but the misconfigured permissions make the attack feasible.", "link_identifiers": ["shadow_private"], "code_snippet": "root:$1$OVhtCyFa$7tISyKW1KGssHAQj1vI3i1:14319::::::", "risk_score": 8.5, "confidence": 9.0, "notes": "This vulnerability stems from incorrect file permission configuration. It is recommended to immediately change the file permissions to root-only read (e.g., 600) and check if the system uses this file for authentication. Subsequent verification of password strength can assess the actual risk, but current evidence indicates a complete attack chain.", "file_path": "etc_ro/shadow_private"}
{"name": "BufferOverflow-return_web_disable_page", "location": "u_filter.ko:0x08004f68 sym.return_web_disable_page", "description": "A buffer overflow vulnerability exists in the 'return_web_disable_page' function when generating HTTP redirect responses. The function uses 'sprintf' to format a response string that includes user-controlled URL data from network packets without proper length validation. Specifically, the format string 'HTTP/1.1 302 Moved Temporarily\\r\\nLocation: http://%s/disable.asp\\r\\nContent-Type: text/html; charset=iso-8859-1\\r\\nContent-length: %d\\r\\n\\r\\n%s' incorporates the user-provided URL via the '%s' specifier. The buffer 's2' (pointing to skb data) has limited size, and excessive input can overflow it, corrupting kernel heap memory. Attackers with network access can craft long URLs to trigger this overflow, potentially leading to code execution or denial-of-service. The vulnerability is triggered when a URL matches the filter criteria, causing 'url_filter' to call 'return_web_disable_page'.", "link_identifiers": ["URL data from network packets", "skb->data buffer", "sprintf format string"], "code_snippet": "0x08004f5c      0000053c       lui a1, $LC3                ; RELOC 32 $LC3 @ 0x080059b8\n0x08004f60      21306002       move a2, s3\n0x08004f64      21204002       move a0, s2\n0x08004f68      09f82002       jalr s1                      ; sprintf(s2, $LC3, s3, v0, s7)\n; $LC3: \"HTTP/1.1 302 Moved Temporarily\\r\\nLocation: http://%s/disable.asp\\r\\nContent-Type: text/html; charset=iso-8859-1\\r\\nContent-length: %d\\r\\n\\r\\n%s\"", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability requires the attacker to send a crafted network packet with a long URL that triggers the URL filter. The skb buffer management might mitigate some risks, but the lack of input sanitization in sprintf makes exploitation plausible. Further analysis is needed to determine exact buffer sizes and exploitation feasibility. Associated functions: sym.url_filter, sym.set_url_filter.", "file_path": "lib/modules/u_filter.ko"}
{"name": "WeakHash-passwd_private", "location": "File: passwd_private", "description": "The file 'passwd_private' contains the root user's password hash (MD5 format: $1$nalENqL8$jnRFwb1x5S.ygN.3nwTbG1), exposing sensitive authentication information. An attacker, as a logged-in non-root user, may be able to read this file (since files similar to /etc/passwd are typically readable by all users), extract the hash, and use offline tools (such as John the Ripper or Hashcat) to crack it. If the password is weak (e.g., a common password), cracking may succeed, allowing the attacker to obtain the root password and escalate privileges. The trigger condition is that the attacker has file read permissions; lack of boundary checks includes the use of a weak hash algorithm (MD5 is vulnerable to collision and rainbow table attacks) and potentially lax file permission settings. Potential attack methods include directly cracking the hash and then switching to the root user via su or login mechanisms.", "link_identifiers": ["passwd_private"], "code_snippet": "root:$1$nalENqL8$jnRFwb1x5S.ygN.3nwTbG1:0:0:root:/:/bin/sh", "risk_score": 7.5, "confidence": 8.0, "notes": "Evidence is based on file content analysis; further verification is needed regarding file permissions (e.g., using 'ls -l passwd_private' to confirm non-root user read permissions) and the actual password strength (e.g., through cracking tests). It is recommended to upgrade to a stronger hash algorithm (such as bcrypt or SHA-512) and restrict file access permissions to root user only. This finding may be related to other authentication components, such as login daemons.", "file_path": "etc_ro/passwd_private"}
{"name": "StackBufferOverflow-CommandInjection-vpnUsrLoginAddRoute", "location": "libvpn.so:0x000031e4 sym.vpnUsrLoginAddRoute", "description": "The function 'sym.vpnUsrLoginAddRoute' in 'libvpn.so' contains a stack buffer overflow and command injection vulnerability due to improper handling of input from login files. The function reads data from files in '/tmp/pptp/logininfo%d' or '/tmp/l2tp/logininfo%d' using sscanf with the format \"%[^;];%[^;];%[^;];%[^;];%s\", writing string data to fixed-size buffers, including a 4-byte uint variable (&uStack_84), causing stack overflow. The overflowed data is then used in system commands executed via 'doSystemCmd', such as 'ip rule add' and 'ip route add', without sanitization, allowing command injection if input contains shell metacharacters. An attacker with valid login credentials can exploit this by creating a malicious login file in the world-writable /tmp directory and triggering the VPN login process, leading to arbitrary command execution as the process user (likely root or a privileged user).", "link_identifiers": ["/tmp/pptp/logininfo%d", "/tmp/l2tp/logininfo%d", "vpn.ser.pptpserver", "vpn.ser.l2tpserver", "vpn.ser.pptpdWanid", "vpn.ser.l2tpdWanid", "lan.ip", "lan.mask"], "code_snippet": "iVar1 = (**(iStack_1a8 + -0x7f5c)) (auStack_140,\"%[^;];%[^;];%[^;];%[^;];%s\" + *(iStack_1a8 + -0x7fe0),auStack_c0,&uStack_84, acStack_180,auStack_ac,auStack_98);\n...\n(**(iStack_1a8 + -0x7f4c)) (\"ip rule add to %s table wan%d prio %d\" + *(iStack_1a8 + -0x7fe0),&uStack_84, uStackX_4, \"t mangle %s POSTROUTING -o %s -j TCPMSS -p tcp --syn \\t\\t\\t--set-mss %d\");", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability requires the function to be called with a user-controlled parameter for the login file index. Cross-references show this function is called from other VPN-related processes, likely during user authentication. Further analysis should verify the caller context and test exploitability with specific input. The use of 'doSystemCmd' with unsanitized input is a common pattern in other functions like 'sym.set_vpn_nat', suggesting broader issues.", "file_path": "lib/libvpn.so"}
{"name": "BufferOverflow-connect_pppol2tp", "location": "pppol2tp.so:0x1a78 connect_pppol2tp", "description": "In the 'connect_pppol2tp' function, the local buffer 'auStack_34' (size 18 bytes) is passed to a function call that uses 'uStack_38' (set to 38 bytes) as the length parameter, causing a stack buffer overflow. Trigger condition: An attacker sends malicious data exceeding 18 bytes via a PPPoL2TP socket. Missing boundary check: The function does not validate if the input length fits the buffer size. Potential exploitation: The overflow can overwrite the return address or critical stack data, allowing an attacker to execute arbitrary code. Complete attack chain: An attacker, as an authenticated user with socket access, can send malicious data to trigger the overflow, achieving privilege escalation or code execution.", "link_identifiers": ["PPPoL2TP socket descriptor", "global variable at offset 0x2850"], "code_snippet": "uint dbg.connect_pppol2tp(void)\n{\n    ...\n    uchar auStack_34 [18];\n    uStack_38 = 0x26;\n    ...\n    (**(iStack_40 + -0x7fd0))(uVar4,auStack_34,&uStack_38); // Buffer overflow: 38 bytes written to 18-byte buffer\n    ...\n}", "risk_score": 8.5, "confidence": 8.0, "notes": "The vulnerability requires the attacker to have access to the PPPoL2TP socket, potentially via a network service or IPC. It is recommended to further verify the socket initialization logic and the source of global variables. Related function: disconnect_pppol2tp. Subsequent analysis direction: Check components that call this function (such as the pppd daemon) to confirm input sources and exploit feasibility.", "file_path": "lib/pppol2tp.so"}
