{"name": "Permission-Vulnerability-leafp2p.sh", "location": "leafp2p.sh:Entire file", "description": "The leafp2p.sh file has improper permission settings, allowing all users (including non-root users) to write to it (permissions: -rwxrwxrwx). This enables attackers to directly modify the script content and insert malicious code (such as a reverse shell or adding users). When the script is executed as an initialization script with root privileges (for example, during system startup or triggered via '/etc/init.d/leafp2p.sh start'), the malicious code will run with root privileges, leading to privilege escalation. Trigger condition: After an attacker modifies the script, the system reboots or the service restarts. Exploitation method is simple: Non-root users use a text editor or commands (such as echo) to insert malicious code, then wait for or trigger execution.", "link_identifiers": ["leafp2p.sh", "/etc/init.d/leafp2p.sh", "leafp2p_sys_prefix"], "code_snippet": "#!/bin/sh /etc/rc.common\n\nSTART=50\n\nnvram=/usr/sbin/nvram\nSYS_PREFIX=$(${nvram} get leafp2p_sys_prefix)\nCHECK_LEAFNETS=${SYS_PREFIX}/bin/checkleafnets.sh\n\nPATH=${SYS_PREFIX}/bin:${SYS_PREFIX}/usr/bin:/sbin:/usr/sbin:/bin:/usr/bin\n\nstart()\n{\n    ${CHECK_LEAFNETS} &\n}\n\nstop()\n{\n    killall checkleafnets.sh 2>/dev/null\n    killall -INT leafp2p 2>/dev/null\n    killall checkleafp2p.sh 2>/dev/null\n}\n\n[ \"$1\" = \"start\" ] && start\n[ \"$1\" = \"stop\" ] && stop", "risk_score": 8.0, "confidence": 9.0, "notes": "The file permission vulnerability is directly exploitable and does not rely on nvram variable control. The attack chain is complete: non-root user modifies the file → execution with root privileges. It is recommended to fix the file permissions to be writable only by root (e.g., 755). Subsequent checks should examine the permissions of other initialization scripts.", "file_path": "etc/init.d/leafp2p.sh"}
{"name": "command-injection-addgroup", "location": "busybox:0x2ab20 sym.imp.system call site", "description": "A potential command injection vulnerability was discovered in busybox, involving the implementation of the 'addgroup' command. An attacker as a non-root user (with valid login credentials) can control the group name through command-line arguments, which is used to construct dynamic command strings and executed via the system function. Specifically, the system function is called at address 0x2ab20, with parameters formatted by the fcn.0002a278 function using vasprintf, with the format string 'addgroup -g %d %s'. If the group name is not properly validated (e.g., contains semicolons, backticks, or other command separators), the attacker may inject and execute arbitrary commands. Trigger condition: The user executes the busybox addgroup command and provides a malicious group name. Exploitation method: For example, executing 'busybox addgroup -g 1000 \"; malicious_command\"' may lead to malicious command execution. The code logic shows a lack of input filtering and boundary checks, directly passing user input to the system call.", "link_identifiers": ["NVRAM/ENV: No direct association", "File path: None", "IPC socket path: None", "Custom shared function symbols: fcn.0002a278, sym.imp.system"], "code_snippet": "0x0002ab14      fc009fe5       ldr r0, str.addgroup__g__d___s_ ; [0x2ac18:4]=0x5af41 str.addgroup__g__d___s_\n0x0002ab18      d6fdffeb       bl fcn.0002a278\n0x0002ab20      1983ffeb       bl sym.imp.system ; int system(const char *string)\n\nfcn.0002a278 code:\n0x0002a278     .string \"setuid\" ; len=6\n0x0002a27c      07402de9       push {r0, r1, r2, lr}\n0x0002a280      14208de2       add r2, var_14h\n0x0002a284      0d00a0e1       mov r0, sp\n0x0002a288      10109de5       ldr r1, [var_10h]\n0x0002a28c      04208de5       str r2, [var_4h]\n0x0002a290      0785ffeb       bl sym.imp.vasprintf\n0x0002a294      000050e3       cmp r0, 0\n0x0002a298      010000aa       bge 0x2a2a4\n0x0002a29c      10009fe5       ldr r0, str.memory_exhausted ; [0x5aa38:4]=0x6f6d656d ; \"memory exhausted\"\n0x0002a2a0      c1f3ffeb       bl fcn.000271ac\n0x0002a2a4      00009de5       ldr r0, [sp]\n0x0002a2a8      0e40bde8       pop {r1, r2, r3, lr}\n0x0002a2ac      10d08de2       add sp, sp, 0x10\n0x0002a2b0      1eff2fe1       bx lr", "risk_score": 7.5, "confidence": 7.0, "notes": "This finding is based on binary analysis, showing a complete data flow from user input to the system call. However, further verification is needed to confirm whether the input source (such as command-line arguments) is indeed user-controllable, and whether the busybox context allows non-root users to execute the addgroup command. Recommended follow-up analysis: Check busybox configuration and permissions, verify input validation mechanisms, and test actual exploitation scenarios. Related functions: fcn.0002a278 is used for string formatting and is called in multiple places, potentially indicating similar issues in other commands.", "file_path": "bin/busybox"}
{"name": "buffer-overflow-main", "location": "ookla:0x0001415c dbg.main", "description": "A stack-based buffer overflow vulnerability exists in the main function of the 'ookla' binary. When the program is executed with two command-line arguments (argc=2), the second argument (argv[1]) is processed using strlen to determine its length and then copied into a stack-allocated buffer of 256 bytes via memcpy without any bounds checking. If the input string exceeds 256 bytes, it overflows the buffer, allowing an attacker to overwrite adjacent stack data, including the saved return address (LR register). This can lead to arbitrary code execution under the context of the user running the binary. The vulnerability is triggered by running './ookla --configurl=<long_string>' where <long_string> is longer than 256 bytes. The lack of stack canaries or other protections in the binary makes exploitation feasible. Potential attacks include executing shellcode or ROP chains to gain control of the process flow. However, since the binary runs with the user's own privileges (non-root), exploitation does not escalate privileges but can be used to execute arbitrary code as the user.", "link_identifiers": ["argv[1] (command-line argument)", "--configurl parameter"], "code_snippet": "From disassembly:\n0x00014140      ldr r3, [var_124h]          ; Load argv[1]\n0x00014144      bl sym.imp.strlen           ; Get length of argv[1]\n0x00014148      mov r3, r0\n0x0001415c      bl sym.imp.memcpy           ; Copy to stack buffer without bounds check\n\nFrom decompilation:\nif (*(puVar4 + -0x118) == 2) {\n    uVar3 = *(*(puVar4 + -0x11c) + 4);     // argv[1]\n    uVar1 = sym.imp.strlen(uVar3);\n    sym.imp.memcpy(puVar4 + iVar2 + -0x11c, uVar3, uVar1); // Overflow here\n}", "risk_score": 7.5, "confidence": 8.5, "notes": "The exact offset to the return address requires further calculation based on stack layout, but evidence confirms the buffer overflow can overwrite the saved LR. The binary has no stack canaries or PIE, making exploitation easier. Attackers must have login access to run the binary. Recommended actions include adding input validation, using bounded functions like strncpy, or enabling stack protections. Further analysis could involve identifying ROP gadgets or testing exploitability in the firmware environment.", "file_path": "bin/ookla"}
{"name": "command-injection-amule.sh-start", "location": "amule.sh:start function (approximately lines 4-25) and script main logic (approximately lines 33-35)", "description": "A command injection vulnerability was discovered in the 'amule.sh' script. When the script is called with 'start' or 'restart' arguments, the user-provided second argument ($2) is used as the working directory (emule_work_dir), but this variable is not quoted in multiple commands, leading to shell command injection. Trigger condition: An attacker calls the script and provides an existing directory path, but the path contains shell metacharacters (such as semicolons, backticks) to inject arbitrary commands. Constraint: The directory must exist to bypass the initial check '[ ! -d $emule_work_dir ]', but an attacker can create a maliciously named directory. Potential attack method: Provide a path such as '/tmp/foo; malicious_command', where '/tmp/foo' is an existing directory, but the entire string executes the malicious command during command expansion. In the code logic, the variable $emule_work_dir is used directly in cp, sed, and amuled commands, lacking input validation and escaping.", "link_identifiers": ["Script argument $2", "emule_work_dir variable"], "code_snippet": "start() {\n\temule_work_dir=$1\n\t[ ! -d $emule_work_dir ] && {\n\t\techo \"emule work dir haven't been prepared exit...\" && exit\n\t}\n\tcp /etc/aMule/amule.conf $emule_work_dir\n\tcp /etc/aMule/remote.conf $emule_work_dir\n\tcp /etc/aMule/config/*  $emule_work_dir\n\t[ ! -f $emule_work_dir/amule.conf -o ! -f $emule_work_dir/remote.conf ] && {\n\t\techo \"Can't get amule configuration exit...\" && exit\n\t}\n\tchmod 777 $emule_work_dir/amule.conf\n\tdir=$(echo $emule_work_dir | sed 's/\\//\\\\\\//g')\n\tcat $emule_work_dir/amule.conf | sed -i \"s/^TempDir.*/TempDir=$dir\\/Temp/\" $emule_work_dir/amule.conf\n\tcat $emule_work_dir/amule.conf | sed -i \"s/^IncomingDir.*/IncomingDir=$dir\\/Incoming/\" $emule_work_dir/amule.conf\n\tcat $emule_work_dir/amule.conf | sed -i \"s/^OSDirectory.*/OSDirectory=$dir\\//\" $emule_work_dir/amule.conf\n\techo \"amule daemon is starting...\"\n\tamuled -c $emule_work_dir &\n}\n[ $1 = \"start\" ] && start $2\n[ $1 = \"restart\" ] && restart $2", "risk_score": 7.5, "confidence": 8.5, "notes": "Attack chain is complete: from user-controlled parameter $2 to command execution. But the running privileges are unknown: if the script runs with root privileges, the risk is higher; if it runs with user privileges, there is no privilege escalation. It is recommended to further analyze how the script is called (e.g., via cron, service, or user interaction) and check if the amuled binary has other vulnerabilities. Related files: configuration files under /etc/aMule/.", "file_path": "etc/aMule/amule.sh"}
{"name": "BufferOverflow-fcn.00017360", "location": "acos_service:0x17360 function fcn.00017360", "description": "In the 'routerinfo' command handler function (fcn.00017360), multiple buffer overflow vulnerabilities exist due to the unsafe use of strcpy, sprintf, and strcat functions when processing user-controlled environment variables. Specifically: when executing the 'routerinfo' command, the program retrieves environment variables DNS1, DNS2, and IFNAME via getenv and directly copies them to stack buffers (e.g., puVar13 + -0x234) without boundary checks. DNS1 is copied using strcpy, DNS2 is appended using sprintf, and IFNAME is concatenated using strcat. An attacker can overflow the buffer by setting these environment variables to long strings (exceeding 224 bytes), overwriting the return address or critical data on the stack, leading to arbitrary code execution or denial of service. Trigger condition: the attacker, as a logged-in user, executes the 'routerinfo' command via the command line or network interface, with malicious environment variables pre-set. Exploitation method: carefully craft the environment variable content to overwrite the return address and jump to shellcode.", "link_identifiers": ["DNS1", "DNS2", "IFNAME", "acos_service", "fcn.00017360"], "code_snippet": "// DNS1 processing\niVar1 = sym.imp.getenv(*0x1796c); // getenv(\"DNS1\")\nif (iVar1 != 0) {\n    uVar5 = sym.imp.getenv(*0x1796c);\n    sym.imp.strcpy(puVar13 + -0x234, uVar5);\n}\n// DNS2 processing\niVar1 = sym.imp.getenv(*0x17970); // getenv(\"DNS2\")\nif (iVar1 != 0) {\n    iVar3 = sym.imp.strlen(puVar13 + -0x234);\n    iVar1 = *0x17974;\n    if (*(puVar13 + -0x234) == '\\0') {\n        iVar1 = *0x1795c;\n    }\n    uVar5 = sym.imp.getenv(*0x17970);\n    sym.imp.sprintf(puVar13 + -0x234 + iVar3, *0x17978, iVar1, uVar5);\n}\n// IFNAME processing\niVar9 = sym.imp.getenv(*0x17960); // getenv(\"IFNAME\")\nif (iVar9 != 0) {\n    iVar9 = iVar1;\n}\nuVar2 = fcn.0001730c(iVar9);\n// ... initialize puVar8 ...\nsym.imp.strcat(puVar8, iVar9);", "risk_score": 8.5, "confidence": 8.0, "notes": "The vulnerability relies on control of environment variables, which an attacker can set via shell or network services. Stack layout analysis shows the buffer is adjacent to critical data, but specific exploitation requires offset adjustment. Dynamic testing is recommended to confirm code execution. The related function fcn.0001730c may involve other operations, but the current vulnerability is independently exploitable.", "file_path": "sbin/acos_service"}
{"name": "CommandInjection-fcn.0001cd64", "location": "acos_service:0x1cea8 function fcn.0001cd64", "description": "In the 'burnethermac' command handler function (fcn.0001cd64), there exists a command injection vulnerability due to the insecure use of sprintf and system functions when processing user-provided command line arguments. Specifically: when specific NVRAM configuration conditions are met (checked via acosNvramConfig_match) and the number of command line arguments is not 3, the program uses sprintf to insert user-controlled arguments (from offsets 4 and 8 of param_2) into the hardcoded format string 'ifconfig %s add %s/%s', and then executes the resulting command string via system. The lack of input validation and escaping allows attackers to inject shell metacharacters (such as ;, `, &) to execute arbitrary commands. Trigger condition: an attacker, as a logged-in user, invokes the 'burnethermac' command and passes malicious parameters (e.g., a MAC address or IP parameter containing a command injection sequence). Exploitation method: inject parameters such as '; malicious_command' to execute arbitrary system commands, achieving privilege escalation or system control.", "link_identifiers": ["burnethermac", "param_2", "acosNvramConfig_match", "system", "sprintf", "acos_service"], "code_snippet": "else if (param_1 != 3 && param_1 + -3 < 0 == SBORROW4(param_1,3)) {\n    iVar1 = puVar7 + -0x100;\n    uVar5 = *(param_2 + 4);\n    uVar2 = *(param_2 + 8);\n    *(puVar7 + -0x108) = *(param_2 + 0xc);\n    sym.imp.sprintf(iVar1, *0x1cfe4, uVar5, uVar2);  // *0x1cfe4 points to 'ifconfig %s add %s/%s'\n    sym.imp.printf(*0x1cfe8, iVar1);  // *0x1cfe8 points to 'command = '%s''\n    sym.imp.system(iVar1);  // Execute command string\n    return 0;\n}", "risk_score": 9.0, "confidence": 9.0, "notes": "The vulnerability directly leads to arbitrary command execution; the attack chain is complete and verifiable. The NVRAM configuration condition might be manipulated through other means, but parameter control is direct. The related function fcn.0001c638 might provide alternative paths, but the current vulnerability is sufficient for exploitation. It is recommended to restrict command execution or implement input filtering.", "file_path": "sbin/acos_service"}
{"name": "file-permission-/etc/group", "location": "etc/group", "description": "The 'group' file has global read and write permissions (-rwxrwxrwx), allowing any user (including non-root users) to modify group configuration. An attacker can edit this file to add themselves to a privileged group (such as root or admin), potentially gaining elevated privileges. Trigger condition: After an attacker modifies the file, the system reads this file during user login, permission checks, or when using group-related commands (such as 'su' or 'sudo'). Exploitation method: An attacker uses a text editor or command (such as 'echo') to directly modify the file content, adding their username to the privileged group line, and then activates the new permissions by logging in again or executing privileged commands. This vulnerability provides a direct path to privilege escalation without requiring additional vulnerabilities.", "link_identifiers": ["/etc/group"], "code_snippet": "File content:\nroot::0:0:\nnobody::0:\nadmin::0:\nguest::0:\n\nFile permissions: -rwxrwxrwx", "risk_score": 8.5, "confidence": 8.0, "notes": "This finding is based on direct evidence from file permissions and content. It is recommended to further verify whether the system actually uses this file for group authentication (for example, by checking authentication logs or testing the behavior after modification). Related files may include /etc/passwd or authentication daemons. Subsequent analysis should check the writability of other configuration files and the system's group management mechanism.", "file_path": "etc/group"}
{"name": "BufferOverflow-fcn.0000a530", "location": "KC_PRINT:0xabac and KC_PRINT:0xb25c in function fcn.0000a530", "description": "A buffer overflow vulnerability exists in the function fcn.0000a530 due to the use of strcpy without bounds checking. The vulnerability is triggered when handling network requests that cause an error condition, leading to the copying of network-controlled data into a fixed-size buffer of 48 bytes. Specifically, at addresses 0xabac and 0xb25c, strcpy is called with a source buffer (piVar7 + -0x478) that contains data read from the network via recv or similar functions, and a destination buffer (*piVar7 + 0x6d) that is limited to 48 bytes. An attacker can send a malicious network packet with more than 48 bytes to overflow the destination buffer, potentially overwriting adjacent heap memory and leading to arbitrary code execution. The attack requires the attacker to trigger the error path in the network handling logic, which is achievable by sending malformed IPP or raw TCP packets.", "link_identifiers": ["Network interface: IPP on port 631", "IPC socket paths: Raw TCP sockets", "File paths: /dev/usblp%d, /proc/printer_status", "NVRAM/ENV variables: Not directly involved, but printer status files may be accessed"], "code_snippet": "Relevant code from decompilation:\nAt 0xabac: sym.imp.strcpy(*piVar7 + 0x6d, piVar7 + 0 + -0x478);\nAt 0xb25c: sym.imp.strcpy(*piVar7 + 0x6d, piVar7 + 0 + -0x478);\nThe destination buffer is memset to 0 for 0x30 bytes (48 bytes) earlier in the code, indicating its fixed size.", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability is in an error handling path, which may be less frequently executed but is still reachable via network requests. The destination buffer is on the heap, and exploitation could involve heap corruption. Further analysis is recommended to determine the exact structure layout and potential mitigations (e.g., ASLR). The attack chain is viable for an attacker with network access and valid credentials, as the service listens on accessible ports.", "file_path": "usr/bin/KC_PRINT"}
{"name": "strcpy Buffer Overflow Vulnerability", "location": "upnpd:0x1f910 fcn.0001f8b8", "description": "In function fcn.0001f8b8, the insecure `strcpy` function is used to copy network data to a stack buffer, lacking boundary checks. When an attacker sends an overly long UPNP request (such as M-SEARCH or NOTIFY), it can trigger a stack overflow, overwrite the return address, and control program flow. Trigger condition: param_1 (user input) length exceeds the target buffer size. Potential attack method: Overwrite the return address to execute arbitrary code.", "link_identifiers": ["param_1", "upnpd", "fcn.0001f8b8"], "code_snippet": "sym.imp.strcpy(iVar5, param_1);  // iVar5 points to stack buffer, param_1 is user input", "risk_score": 6.5, "confidence": 7.0, "notes": "The vulnerability can be triggered remotely, but requires the attacker to possess valid login credentials. Target buffer size and return address offset need further verification to confirm the complete attack chain. Dynamic analysis is recommended.", "file_path": "usr/sbin/upnpd"}
{"name": "strncpy Buffer Overflow Vulnerability", "location": "upnpd:0x171e4 fcn.000171e4", "description": "In function fcn.000171e4, `strncpy` is used to copy user input to a stack buffer, but the length parameter (0x3ff) exceeds the buffer size (1020 bytes), causing an overflow of 3 bytes. This may overwrite critical data on the stack (such as the return address). Trigger condition: param_1 length >= 1020 bytes. Potential attack method: Overwrite the return address with carefully crafted input to achieve code execution.", "link_identifiers": ["param_1", "iVar7", "auStack_42c", "fcn.000171e4", "strncpy"], "code_snippet": "sym.imp.strncpy(iVar7, param_1, 0x3ff);  // iVar7 points to a 1020-byte stack buffer auStack_42c, but the copy length is 1023 bytes", "risk_score": 6.5, "confidence": 7.0, "notes": "The vulnerability is called in the response generation logic, with the input source being network requests. Exploitability depends on the calling context; it is recommended to trace the caller to confirm the complete attack chain.", "file_path": "usr/sbin/upnpd"}
{"name": "command-injection-arm-linux-base-unicode-release-2.8", "location": "arm-linux-base-unicode-release-2.8:372 (Global Script)", "description": "A command injection vulnerability was discovered in the 'arm-linux-base-unicode-release-2.8' script. The script accepts user input for the --exec-prefix and --prefix options. These values are used to construct the wxconfdir variable and are executed within a command substitution for a cd command. If a user passes a malicious string (such as a payload containing command substitution), it can lead to arbitrary command execution. Trigger condition: An attacker runs the script specifying a malicious --exec-prefix, for example: './arm-linux-base-unicode-release-2.8 --exec-prefix=\"$(malicious_command)\"'. The script does not validate or filter the input, allowing an attacker to inject and execute arbitrary commands. Potential attack methods include executing system commands, file operations, etc., but since the attacker is a non-root user, the impact scope is limited. The relevant code logic involves parsing command line options, constructing path variables, and executing shell commands.", "link_identifiers": ["--exec-prefix", "--prefix", "exec_prefix", "prefix", "wxconfdir"], "code_snippet": "wxconfdir=\"${exec_prefix}/lib/wx/config\"\ninstalled_configs=`cd \"$wxconfdir\" 2> /dev/null && ls | grep -v \"^inplace-\"`", "risk_score": 6.5, "confidence": 8.0, "notes": "The vulnerability is practically exploitable with a complete attack chain: user input -> variable assignment -> command execution. It is recommended to further verify the exploitation effectiveness in a real environment and check if other code paths using wxconfdir (such as lines 859, 864, 882, 887) have similar issues. Related file: 'inplace-arm-linux-base-unicode-release-2.8' is sourced from this script but is not vulnerable itself. Subsequent analysis direction: Check other input points of the script (such as --utility) and command execution points.", "file_path": "lib/wx/config/inplace-arm-linux-base-unicode-release-2.8"}
{"name": "PrivateKey-Exposure-client.key", "location": "client.key", "description": "The file 'client.key' contains a valid RSA private key with permissions set to 777 (-rwxrwxrwx), allowing any user (including non-root users) to read it. An attacker (a non-root user with valid login credentials) can directly access and steal this private key without any additional verification or boundary checks. Potential attacks include: using the private key for identity impersonation (e.g., in SSL/TLS or SSH contexts), decrypting sensitive communications, or launching man-in-the-middle attacks. The trigger condition is simple: the attacker only needs to execute a file read command (such as `cat client.key`). The exploitation method is direct, with a high probability of success, because the private key content is complete and valid.", "link_identifiers": ["client.key"], "code_snippet": "-----BEGIN RSA PRIVATE KEY-----\nMIICXgIBAAKBgQDA96PAri2Y/iGnRf0x9aItYCcK7PXGoALx2UpJwEg5ey+VfkHe\nwN8j1d5dgreviQandkcTz9fWvOBm5Y12zuvfUEhYHxMOQxg4SajNZPQrzWOYNfdb\nyRqJ3fyyqV+IrMgBhlQkKttkE1myYHW4D8S+IJcThmCRg5vQVC37R+IE7wIDAQAB\nAoGAVe6x9L9cPPKHCBfJ7nKluzFDkcD+nmpphUwvofJH95kdEqS8LreTZ0D5moj4\nxenulaq9clwvkUhhYlE9kzgIn48JmuUClVGJJofRRzkQGv66TNNeqLlwgDP27pLB\ntcz6EkiCk8/fgwgjhpLNNfFpXGGl0UYOZ5woWOVeijoxOWECQQDf2LYHMdSrFBR6\n6yXw5uKxHh4t9O5KmT4NfmcJT5Dmzh+C/fAWuxLXT6P0l5a3wEjqsjK14g/k+Ti2\nV8GJRR1RAkEA3K9wSFa+j9h93b3ztfxAJbUDCcttw+U8BXtIMsGxmCL+QufsdozD\nBe5U7MKJdSU0Q+sLmoHynqBxVvMPuxduPwJBANsPsdQIqB9kX0aLqW3ABklfOBmx\ngSHwJhH+icdK3nuBbMU8ziDwotejUMilMRJSUwmbqpTkzrk+TInmB7jWsoECQQCv\nEx9oxCh5xa5U9BUcEvpw76Fxa8mw13M+hgdI/RD/OQOt4IBfrFwroGAPVGXoYZON\nLjMOaHkqDu7bpAiezH/RAkEAwaCYC4SOG3mPsrKrglRcND56fLwYhEVSXpIVLQYt\nvHRpCko9xSyTeQnppREcofe1gHUFluzXS9Wj+0nDDhXZGA==\n-----END RSA PRIVATE KEY-----", "risk_score": 8.5, "confidence": 9.0, "notes": "This is an actually exploitable vulnerability with a complete attack chain: non-root user logs in → reads the private key → misuses the private key (e.g., for decryption or impersonation). It is recommended to immediately fix the file permissions (e.g., set to root-read-only) and check if any services in the system depend on this private key to assess potential impact. Subsequent analysis should focus on permission issues with other sensitive files (such as certificates, configuration files).", "file_path": "usr/local/share/foxconn_ca/client.key"}
{"name": "FileRisk-server.key", "location": "server.key", "description": "The file 'server.key' is a PEM RSA private key file with permissions set to -rwxrwxrwx, allowing any user (including non-root users) to read, write, and execute. An attacker (a non-root user but with valid login credentials) can access the file system and read the private key, which can be used to decrypt encrypted communications, impersonate the server, or conduct man-in-the-middle attacks. The trigger condition is that the attacker has file system access; no additional conditions are needed due to the lax permissions. Potential exploitation methods include decrypting HTTPS traffic after obtaining the private key, forging server certificates, or launching man-in-the-middle attacks.", "link_identifiers": ["server.key"], "code_snippet": "-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQC3TYAabx6bUyBsLPiJ8hzYbup8l28jniriODdoSJ69NR2ODWH6\nmAI4au9lm2LHctb6VzqXT6B6ldCxMZkzvGOrZqgQXmILBETHTisiDjmPICktwUwQ\naSBGT4JfjP+OoYNIHgNdbTPpz4XIE5ZKfK84MmeS34ud+kJI5PfgiDd4jQIDAQAB\nAoGAXb1BdMM8yLwDCa8ZzxnEzJ40RlD/Ihzh21xaYXc5zpLaMWoAoDGaeRWepbyI\nEG1XKSDwsq6i5+2zktpFeaKu6PtOwLO4r49Ufn7RqX0uUPys/cwnWr6Dpbv2tZdL\nvtRPu71k9LTaPt7ta76EgwNePe+C+04WEsG3yJHvEwNX86ECQQDqb1WXr+YVblAM\nys3KpE8E6UUdrVDdou2LvAIUIPDBX6e13kkWI34722ACaXe1SbIL5gSbmIzsF6Tq\nVSB2iBjZAkEAyCoQWF82WyBkLhKq4G5JKmWN/lUN0uuyRi5vBmvbWzoqwniNAUFK\n6fBWmzLQv30plyw0ullWhTDwo9AnNPGs1QJAKHqY2Nwyajjl8Y+DAR5l1n9Aw+MN\nN3fOdHY+FaOqbnlJyAldrUjrnwI+DayQUukqqQtKeGNa0dkzTJLuTAkr4QJATWDt\ndqxAABRShfkTc7VOtYQS00ogEPSqszTKGMpjPy4KT6l4oQ6TnkIZyN9pEU2aYWVm\ncM+Ogei8bidOsMnojQJBAKyLqwjgTqKjtA7cjhQIwu9D4W7IYwg47Uf68bNJf4hQ\nTU3LosMgjYZRRD+PZdlVqdMI2Tk5/Pm3DPT0lmnem5s=\n-----END RSA PRIVATE KEY-----", "risk_score": 9.0, "confidence": 9.0, "notes": "Further verification is needed to confirm whether this private key is being used for actual services (e.g., web server or TLS configuration) to determine the direct impact of exploitation. It is recommended to check related configuration files or service logs. This finding is associated with the system's cryptographic components; subsequent analysis should focus on services that use this private key.", "file_path": "usr/local/share/foxconn_ca/server.key"}
{"name": "CommandInjection-openvpn_plugin_func_v1", "location": "openvpn-plugin-down-root.so:0x00000b88 sym.openvpn_plugin_func_v1 (specifically where system(iVar9) is called)", "description": "A command injection vulnerability exists in the OpenVPN down-root plugin where environment variables are used to build and execute shell commands without proper sanitization. The plugin function `openvpn_plugin_func_v1` retrieves environment variables via `get_env`, builds a command line using `build_command_line` which uses unsafe `strcat` operations, and then executes it via `system`. An attacker with valid login credentials can potentially set malicious environment variables that are incorporated into the command, leading to arbitrary command execution. The vulnerability is triggered when the plugin processes down script commands, typically during OpenVPN session termination.", "link_identifiers": ["param_4 (environment variables array)", "get_env function", "build_command_line function", "system call"], "code_snippet": "// From sym.openvpn_plugin_func_v1 decompilation\nwhile (*param_4 != 0) {\n    sym.imp.putenv();\n    param_4 = param_4 + 1;\n}\n// ...\niVar9 = sym.build_command_line(puVar14 + -0x18);\n// ...\nsym.imp.system(iVar9);\n\n// From sym.build_command_line decompilation\nsym.imp.strcat(puVar4, *piVar6); // Unsafe concatenation", "risk_score": 8.5, "confidence": 8.0, "notes": "The attack chain requires the attacker to control environment variables passed to the plugin, which might be achievable through OpenVPN configuration or other means. The plugin runs with OpenVPN's privileges, which could be root. Further analysis of OpenVPN main binary is recommended to confirm how environment variables are set and passed to plugins. The use of `strcat` without bounds checking also poses a risk of buffer overflow, but command injection is more immediately exploitable.", "file_path": "usr/local/lib/openvpn/plugins/openvpn-plugin-down-root.so"}
{"name": "StackOverflow-updateFwFilterRules", "location": "libacos_shared.so:0x123fc (updateFwFilterRules)", "description": "The 'updateFwFilterRules' function contains a stack buffer overflow vulnerability due to the use of 'strcpy' to copy NVRAM data into a fixed-size stack buffer (approximately 8192 bytes) without length validation. Attackers with valid login credentials (non-root users) can exploit this by modifying NVRAM variables (e.g., firewall rule configurations) through network interfaces (e.g., HTTP API) to inject malicious data exceeding the buffer size. This overflow can overwrite saved registers and the return address, enabling arbitrary code execution. Trigger conditions include updating firewall rules via user-triggered actions (e.g., configuration changes). The vulnerability is feasible as NVRAM variables are user-writable, and the function is called during rule updates, providing a direct path from input to dangerous operation.", "link_identifiers": ["NVRAM variables for firewall rules (e.g., accessed via acosNvramConfig_get)", "acosNvramConfig_get", "acosNvramConfig_set"], "code_snippet": "// Vulnerable code from decompilation:\nuVar1 = loc.imp.acosNvramConfig_get(*(iVar10 + -0x40b4) + iVar6);\nloc.imp.strcpy(iVar4, uVar1); // iVar4 points to stack buffer at iVar10 + -0x4094\n\n// Buffer initialization:\nloc.imp.memset(iVar10 + -0x4090, 0, 0x1ffc); // Buffer size 8188 bytes\n// strcpy target iVar4 = iVar10 + -0x4094 (4 bytes before buffer start)", "risk_score": 8.5, "confidence": 8.0, "notes": "This finding is based on evidence from r2 decompilation and cross-reference analysis. The attack chain is verifiable: user input flows from NVRAM (controllable via authenticated requests) to 'strcpy' without bounds checks. Further validation could include identifying the exact NVRAM variable names and testing exploitability in a real environment. Other functions like 'getTokens' and 'config_nvram_list' use 'strcpy' but lack evidence of user input control, so they are not considered exploitable at this time.", "file_path": "usr/lib/libacos_shared.so"}
{"name": "Format-String-OpenVPN-Management", "location": "openvpn:0x0001a970 sym.man_read → 0x000220b0 sym.man_kill → 0x0004ce60 sym.openvpn_getaddrinfo → 0x00012ce0 sym.x_msg_va", "description": "A format string vulnerability exists in the OpenVPN management interface's 'kill' command handler. When an authenticated user (non-root) sends a 'kill' command with a malicious argument (e.g., containing format specifiers like %x or %n), the input is propagated through the code and used as the format string in `vsnprintf` if address resolution via `getaddrinfo` fails. This failure can be forced by providing an invalid address, allowing an attacker to read memory, write to arbitrary locations, or potentially execute code. The attack chain is: user input → `sym.man_read` (reads from management socket) → `sym.man_kill` (processes 'kill' command) → `sym.getaddr` → `sym.openvpn_getaddrinfo` (fails) → `sym.x_msg` → `sym.x_msg_va` → `vsnprintf` with tainted format string. Trigger conditions include authenticated access to the management interface and sending a crafted 'kill' command. Constraints: The vulnerability is only exploitable if the management interface is enabled and accessible to the user.", "link_identifiers": ["management socket path (typically /var/run/openvpn.sock or similar)", "sym.man_read", "sym.man_kill", "sym.getaddr", "sym.openvpn_getaddrinfo", "sym.x_msg", "sym.x_msg_va", "vsnprintf"], "code_snippet": "From sym.man_read (decompiled):\n  - recv(*(param_1 + 0x22c), puVar15 + -0x158, 0x100, 0x4000) reads user input into buffer.\n  - sym.man_kill(param_1, *(puVar15 + -0x54)) is called with tainted data.\n  From sym.man_kill analysis:\n  - Tainted data passed to sym.getaddr → sym.openvpn_getaddrinfo.\n  - On getaddrinfo failure: sym.x_msg(uVar3, *(puVar8 + -0x30), param_2, uVar2) where param_2 is tainted.\n  - sym.x_msg calls sym.x_msg_va, which uses vsnprintf with tainted data as format string.", "risk_score": 8.5, "confidence": 9.0, "notes": "This vulnerability is exploitable by authenticated users with access to the management interface, aligning with the attack scenario where the attacker has valid login credentials but is non-root. Mitigation involves validating and sanitizing user input before using it in format strings or disabling the management interface if not needed. Further analysis could explore other management commands for similar issues, but this finding represents the most critical attack path.", "file_path": "usr/local/sbin/openvpn"}
