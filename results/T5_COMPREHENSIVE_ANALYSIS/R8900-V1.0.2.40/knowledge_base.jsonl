{"name": "XSS-refresh_plex_status", "location": "plex_media.htm: Location in JavaScript function `refresh_plex_status` where `innerHTML` is set (specifically when setting the content of the `plex_usb` element)", "description": "A stored cross-site scripting (XSS) vulnerability was discovered in 'plex_media.htm'. An attacker, as a non-root user with valid login credentials, can exploit this vulnerability by adding a network drive and setting the device name to malicious JavaScript code (e.g., `<script>alert('xss')</script>`). When a user visits the 'plex_media.htm' page, the JavaScript function `refresh_plex_status` retrieves device information from `plex_status.xml` and uses `innerHTML` to directly set the page element content, leading to the execution of malicious code. Trigger conditions include: the attacker successfully adding a malicious network drive, and the victim visiting or refreshing the 'plex_media.htm' page. Exploitation methods include stealing session cookies, modifying device settings, or performing other malicious actions. The vulnerability arises from a lack of input filtering for the device name and output escaping, allowing attackers to inject arbitrary scripts.", "link_identifiers": ["plex_net_scan.htm", "plex_media", "http_loginname", "/tmp/plex_reset_result", "apply.cgi"], "code_snippet": "In the `refresh_plex_status` function:\nif(names[sel_num].childNodes[0].nodeValue == \"plex_device_name_null_mark\")\n    usb_msg = 'USB'+(sel_num+1)+' , '+types[sel_num].childNodes[0].nodeValue+' , '+'$plex_total'+t_size[sel_num].childNodes[0].nodeValue+' , '+'$plex_free'+f_size[sel_num].childNodes[0].nodeValue;\nelse\n    usb_msg = 'USB'+(sel_num+1)+' , '+types[sel_num].childNodes[0].nodeValue+' , '+names[sel_num].childNodes[0].nodeValue+' , '+'$plex_total'+t_size[sel_num].childNodes[0].nodeValue+' , '+'$plex_free'+f_size[sel_num].childNodes[0].nodeValue;\ndocument.getElementById(\"plex_usb\").innerHTML=usb_msg;\nThe device name `names[sel_num].childNodes[0].nodeValue` is used directly in `innerHTML` without escaping, allowing XSS.", "risk_score": 7.5, "confidence": 8.5, "notes": "This vulnerability requires the attacker to be able to add a network drive, but as an authenticated user, this is a permitted operation. The attack chain is complete: from the input point (network drive name) to the dangerous operation (script execution). It is recommended to further analyze `plex_net_scan.htm` to confirm the input validation situation and check if server-side components (such as `apply.cgi`) have other vulnerabilities. Additionally, other similar `innerHTML` setting points (such as the `plex_status` element) may have the same issue and should be comprehensively reviewed.", "file_path": "www/plex_media.htm"}
{"name": "Command-Injection-fcn.00012eb4", "location": "busybox:0x12eb4 fcn.00012eb4", "description": "The function at address 0x12eb4 (fcn.00012eb4) uses the system() function to execute commands constructed from directory entries and parameters. Specifically, it reads directory entries via readdir64, constructs a path using fcn.0004244c, and passes it to system() without adequate validation. An attacker with control over the directory contents or parameters could inject arbitrary commands. The function also sets an environment variable using setenv, which might influence command execution. This could be triggered through a BusyBox applet that handles user input, such as one processing scripts or configurations.", "link_identifiers": ["sym.imp.system", "sym.imp.readdir64", "sym.imp.setenv", "fcn.0004244c"], "code_snippet": "uint fcn.00012eb4(uint *param_1) {\n    // ... (setenv and directory processing)\n    iVar2 = sym.imp.readdir64(iVar1);\n    if (iVar2 != 0) {\n        uVar3 = fcn.0004244c(*0x12f9c, param_1[1], iVar2 + 0x13);\n        iVar4 = sym.imp.system(uVar3);  // First system call\n        // ...\n    }\n    uVar3 = fcn.0004244c(*0x12fa0, param_1[1]);\n    sym.imp.system();  // Second system call\n    // ...\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "The function fcn.00012eb4 is likely part of a BusyBox applet (e.g., related to script execution or directory processing). Further analysis is needed to identify the exact applet and its usage context. The attack requires the attacker to influence the directory contents or parameters, which might be achievable through file uploads or manipulated environment variables. Verification of the applet's exposure to user input is recommended for full exploit chain validation.", "file_path": "bin/busybox"}
{"name": "BufferOverflow-datalib-fcn.0000937c", "location": "datalib:0x94a4 fcn.0000937c strcpy call", "description": "A buffer overflow vulnerability was discovered in 'datalib', originating from the use of strcpy in function fcn.0000937c to copy user-controlled strings without adequately validating the size of the destination buffer. This function is called by fcn.000095a0, which parses key-value pair strings (in the format 'key=value') from NVRAM or configuration input. An attacker, as an authenticated user, can set long configuration values (such as wl_ssid, wl_wpa_psk, or other NVRAM variables) through the web interface or CLI, triggering a buffer overflow. The overflow may overwrite adjacent memory, including the return address or function pointers, leading to arbitrary code execution. Vulnerability trigger conditions include: providing a string longer than the target buffer; constraints include a global buffer size limit (0x20000 bytes), but the strcpy operation disregards specific boundaries. Potential attack methods include submitting malicious long strings through the configuration update mechanism, exploiting the overflow to control program flow.", "link_identifiers": ["wl_ssid", "wl_wpa_psk", "http_username", "http_passwd", "wan_pppoe_username", "wan_pppoe_passwd", "defaults_config", "/dev/mtd_config"], "code_snippet": "// From fcn.0000937c\nsym.imp.strcpy(puVar6 + 3, param_1); // Key copy\npuVar1 = sym.imp.strcpy(iVar7, param_2); // Value copy\n// From fcn.000095a0\nfcn.0000937c(puVar2, puVar3); // Called for each key-value pair\n", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability requires the attacker to possess valid login credentials (non-root user), but configuration updates via the web interface are a common operation. The attack chain is complete: from user input (NVRAM variables) to dangerous operations (strcpy). It is recommended to further validate the layout of the global buffer and the consequences of the overflow, for example through dynamic testing or debugging. Related functions include fcn.000095a0 and fcn.0000937c. Subsequent analysis should focus on other input points (such as recvfrom) and similar dangerous functions (such as sprintf).", "file_path": "bin/datalib"}
{"name": "PrivEsc-setup.sh", "location": "setup.sh: start case (lines executing scripts with relative paths)", "description": "The 'setup.sh' script executes multiple external scripts using relative paths (e.g., ./iqos-setup.sh, ./dc_monitor.sh) in the 'start' and 'restart' cases. The current directory and all files have permissions 'drwxrwxrwx' and '-rwxrwxrwx', making them writable by any user, including non-root attackers. The script performs privileged operations (e.g., insmod, iptables, mknod), indicating it is designed to run as root. An attacker can modify any of the executed scripts (e.g., iqos-setup.sh, dc_monitor.sh) to inject malicious commands, which will run with root privileges when 'setup.sh' is triggered (e.g., during system startup or service restarts). This provides a direct path to privilege escalation.", "link_identifiers": ["./iqos-setup.sh", "./dc_monitor.sh", "./wred-setup.sh", "./clean-cache.sh", "./lic-setup.sh", "./setup.sh"], "code_snippet": "Examples from script:\n- ./$iqos_setup restart  # where $iqos_setup='iqos-setup.sh'\n- ./dc_monitor.sh &\n- ./$wred_setup &  # where $wred_setup='wred-setup.sh'\n- ./clean-cache.sh > /dev/null 2>&1 &\n- In 'restart' case: $0 stop and $0 start  # self-referential execution", "risk_score": 9.0, "confidence": 8.5, "notes": "The risk is high due to the clear attack chain: writable directory + relative path execution + privileged context. However, direct evidence of root execution (e.g., process ownership) is inferred from privileged commands. Further verification is recommended on how 'setup.sh' is triggered in the system (e.g., via init scripts or services). Associated files include iqos-setup.sh, dc_monitor.sh, etc., which should be secured with proper permissions.", "file_path": "iQoS/R9000/TM/setup.sh"}
{"name": "Permission-OpenVPN-Script", "location": "init.d/openvpn (File Permissions)", "description": "The script 'openvpn' has global write permissions (rwxrwxrwx), allowing any user (including non-root users) to modify its content. If the script is executed with root privileges (e.g., during system startup or via service management commands), an attacker can inject malicious code by modifying the script, thereby gaining root access. Trigger conditions include: 1) A non-root user modifies the script; 2) The script is subsequently executed with root privileges (such as during system reboot or service restart). Exploitation method: An attacker writes arbitrary commands (e.g., a reverse shell or file operations) into the script and then waits for or triggers execution. Constraints: The attacker needs to be able to trigger script execution, which may depend on system configuration (e.g., whether non-root users are allowed to control services).", "link_identifiers": ["file_path:./openvpn"], "code_snippet": "Not applicable (file permission issue), but permission evidence: -rwxrwxrwx 1 user user 4762 Jul 13 2017 openvpn", "risk_score": 7.5, "confidence": 8.0, "notes": "Risk score is based on file permissions and potential execution context (the script may run as root during startup). Confidence is high because file permission evidence is clear, but the completeness of the attack chain depends on execution triggers (further verification of system configuration is needed, such as service management permissions). It is recommended to check whether non-root users can execute or restart this service (e.g., via /etc/init.d/openvpn). Related files: May involve service management mechanisms or cron jobs. Follow-up analysis direction: Verify the script's execution context and system permission configuration.", "file_path": "etc/init.d/openvpn"}
{"name": "PathTraversal-wpa_supplicant_setup_vif", "location": "wpa_supplicant.sh:Unknown line number (in function wpa_supplicant_setup_vif)", "description": "In the 'wpa_supplicant.sh' script, the 'ifname' variable is obtained from the configuration system and directly used to construct the 'ctrl_interface' path, which is subsequently used in the 'rm -rf $ctrl_interface' command. The lack of input validation allows for path traversal attacks: if an attacker sets 'ifname' to a malicious value (such as '../../etc'), the 'ctrl_interface' path may resolve to a system directory (like '/etc'), causing 'rm -rf' to delete critical files. Trigger conditions include an attacker modifying wireless configuration through a configuration interface (such as Web UI or CLI) and triggering script execution (like restarting a network interface). Exploitation methods include setting 'ifname' to path traversal sequences (such as '../../etc' or '/'), leading to arbitrary file deletion, potentially completely destroying the system.", "link_identifiers": ["ifname", "ctrl_interface", "/var/run/wpa_supplicant-$ifname", "config_get"], "code_snippet": "ctrl_interface=\"/var/run/wpa_supplicant-$ifname\"\nrm -rf $ctrl_interface", "risk_score": 9.5, "confidence": 9.0, "notes": "Attack chain is complete: entry point ('ifname' in configuration system) -> data flow (directly used to construct path) -> dangerous operation ('rm -rf'). Assumes the script runs with root privileges and the attacker can control 'ifname' through the configuration interface. Further validation is needed for the 'prepare_key_wep' function (not defined in the script) and whether other configuration variables introduce additional risks. It is recommended to check configuration system permissions and input filtering mechanisms.", "file_path": "lib/wifi/wpa_supplicant.sh"}
{"name": "CommandInjection-statistic_mac80211", "location": "mac80211.sh:statistic_mac80211", "description": "In the statistic_mac80211 function, the ifname configuration value is used unquoted in the ifconfig command, allowing command injection. An attacker can set a malicious ifname (e.g., 'wlan0; malicious_command') by modifying the wireless interface configuration. When statistic_mac80211 is called (e.g., via status monitoring or statistics queries), the shell will parse the semicolon in ifname and execute the injected command. Since scripts typically run with root privileges, the injected command will execute with root privileges. Trigger conditions include: an attacker modifying the ifname configuration and triggering the execution of statistic_mac80211 (e.g., via Web UI or CLI requests for statistics).", "link_identifiers": ["ifname"], "code_snippet": "config_get ifname \"$vif\" ifname\n[ -n \"$ifname\" ] || {\n    [ $i -gt 0 ] && ifname=\"wlan${phy#phy}-$i\" || ifname=\"wlan${phy#phy}\"\n}\ntx_packets_tmp=`ifconfig $ifname | grep \"TX packets\" | awk -F: '{print $2}' | awk '{print $1}'`\nrx_packets_tmp=`ifconfig $ifname | grep \"RX packets\" | awk -F: '{print $2}' | awk '{print $1}'`\ntx_bytes_tmp=`ifconfig $ifname | grep bytes: | awk -F: '{print $3}' | awk '{print $1}'`\nrx_bytes_tmp=`ifconfig $ifname | grep bytes: | awk -F: '{print $2}' | awk '{print $1}'`", "risk_score": 8.0, "confidence": 9.0, "notes": "Attack chain is complete: from configuration input (ifname) to command execution. Requires an attacker to be able to modify wireless configuration (e.g., /etc/config/wireless) and trigger function execution. By default, non-root users may not be able to directly modify configuration, but if there is misconfiguration (such as incorrect file permissions) or through other services (like Web UI), it might be exploitable. It is recommended to check configuration file permissions and access controls.", "file_path": "lib/wifi/mac80211.sh"}
{"name": "CommandInjection-wigigstainfo_mac80211", "location": "mac80211.sh:wigigstainfo_mac80211", "description": "In the wigigstainfo_mac80211 function, the ifname configuration value is used in the iw command without quotes, allowing command injection. An attacker can set a malicious ifname (e.g., 'wlan0; malicious_command') by modifying the wireless interface configuration settings. When wigigstainfo_mac80211 is called (e.g., through a client information query), the shell will parse the semicolon in ifname and execute the injected command. Since the script usually runs with root privileges, the injected command will execute with root privileges. Trigger conditions include: the attacker modifies the ifname configuration and triggers wigigstainfo_mac80211 execution (e.g., through status checks or user requests).", "link_identifiers": ["ifname"], "code_snippet": "config_get ifname \"$vif\" ifname\niw $ifname station dump | \\\n    sed '/^\\s*$/N; /\\nStation/s/\\(\\nStation\\)/\\n\\1/' \\\n    >> $tmpfile", "risk_score": 8.0, "confidence": 9.0, "notes": "The attack chain is complete: from configuration input (ifname) to command execution. Requires the attacker to be able to modify the wireless configuration and trigger function execution. Similar to statistic_mac80211, exploitability depends on the ability to modify configuration. The function may be called periodically by network management tools or triggered on demand, increasing the opportunity for exploitation.", "file_path": "lib/wifi/mac80211.sh"}
{"name": "CommandInjection-enable_mac80211", "location": "mac80211.sh:enable_mac80211", "description": "In the enable_mac80211 function, the txantenna and rxantenna configuration values are used without quotes in the iw phy set antenna command, allowing command injection. An attacker can set malicious txantenna or rxantenna values (e.g., 'all; malicious_command') by modifying the wireless device configuration. When enable_mac80211 is called (e.g., during wireless interface activation or reconfiguration), the shell will parse the semicolon in the variable and execute the injected command. Since the script runs with root privileges, the injected command will execute with root privileges. Trigger conditions include: the attacker modifies the txantenna or rxantenna configuration and triggers enable_mac80211 execution (e.g., through interface activation or configuration reload).", "link_identifiers": ["txantenna", "rxantenna"], "code_snippet": "config_get txantenna \"$device\" txantenna all\nconfig_get rxantenna \"$device\" rxantenna all\niw phy \"$phy\" set antenna $txantenna $rxantenna >/dev/null 2>&1", "risk_score": 7.5, "confidence": 8.5, "notes": "The attack chain is complete: from configuration input (txantenna/rxantenna) to command execution. Requires the attacker to be able to modify wireless device configuration and trigger enable_mac80211 execution (e.g., via /etc/init.d/network reload). Since enable_mac80211 typically runs during interface startup, the trigger frequency is low, but it is still exploitable. It is recommended to use quotes for all configuration variables to prevent word splitting and command injection.", "file_path": "lib/wifi/mac80211.sh"}
{"name": "CommandInjection-liblicop.so-sym.__read_cmd", "location": "liblicop.so:0x3024 sym.__read_cmd", "description": "A command injection vulnerability was discovered in 'liblicop.so', with a complete attack chain and practical exploitability. Attackers can trigger command execution through controllable input. Specific details:\n- **Input Point**: Parameters of exported functions (such as 'sym.get_dev_key'), possibly from external calls (such as network interfaces or IPC).\n- **Data Flow**: Input is passed through 'sym.__check_model' to 'sym.__read_cmd', where the command string is not validated or escaped.\n- **Dangerous Operation**: 'sym.__read_cmd' uses popen to execute system commands; if the input contains malicious commands (such as semicolons or backticks), it can lead to arbitrary command execution.\n- **Trigger Condition**: Attackers need to be able to call the relevant exported functions and control the input string (for example, by modifying NVRAM variables or sending malicious requests).\n- **Exploitation Method**: Injecting commands such as '; rm -rf /' or '`cat /etc/passwd`' can lead to privilege escalation or system damage.\n- **Code Logic**: 'sym.__read_cmd' checks if the input starts with 'r* ' to decide whether to use fopen or popen, but the command string comes directly from the input without filtering.", "link_identifiers": ["sym.get_dev_key", "sym.__check_model", "sym.__read_cmd", "sym.imp.popen"], "code_snippet": "0x00003024      26f7ffeb       bl sym.imp.popen            ; file*popen(const char *filename, const char *mode)\n; Preceding code: input string passed via parameter, unvalidated\n0x0000300c      30301be5       ldr r3, [var_30h]           ; 0x30\n0x00003010      003093e5       ldr r3, [r3]\n0x00003014      0300a0e1       mov r0, r3                  ; const char *filename\n0x00003018      ec319fe5       ldr r3, [0x0000320c]        ; [0x320c:4]=0x1fb8\n0x0000301c      03308fe0       add r3, pc, r3\n0x00003020      0310a0e1       mov r1, r3                  ; const char *mode\n; Here, r0 contains the command string, directly used for popen", "risk_score": 8.5, "confidence": 9.0, "notes": "Attack chain is complete: input point (exported function) → data flow (sym.__check_model) → dangerous operation (popen). Further validation of the calling context of the exported functions is needed, but based on code evidence, the vulnerability is exploitable. It is recommended to check the components in the firmware that call the exported functions of 'liblicop.so' to confirm the actual attack surface.", "file_path": "iQoS/R9000/tm_key/liblicop.so"}
{"name": "CommandInjection-wps-hostapd-update-uci", "location": "wps-hostapd-update-uci (script), approximate lines based on content: command substitution around 'qca_hostapd_config_file=/var/run/hostapd-`echo $IFNAME`.conf' and 'local parent=$(cat /sys/class/net/${IFNAME}/parent)'", "description": "The script handles WPS events and takes IFNAME and CMD as arguments. Multiple instances of command substitution using IFNAME without sanitization allow arbitrary command execution. For example, if IFNAME is set to a string like 'ath0; id; #', it injects and executes the 'id' command during the evaluation of backticks or $(). The script has world-executable permissions, so a non-root user with valid login credentials can directly run it with controlled inputs. Trigger conditions include invoking the script with malicious IFNAME values, leading to command execution under the user's context. Constraints: The exploit requires the user to have access to execute the script, which is permitted due to permissions. Potential attacks include running arbitrary commands to disclose information, manipulate files, or escalate privileges if combined with other vulnerabilities. The code logic involves unsafe usage of IFNAME in shell command evaluations.", "link_identifiers": ["IFNAME", "CMD", "/var/run/hostapd-*", "/sys/class/net/${IFNAME}/parent", "hostapd_cli", "uci", "/bin/config"], "code_snippet": "Example vulnerable code snippets:\n  - `qca_hostapd_config_file=/var/run/hostapd-\\`echo $IFNAME\\`.conf`\n  - `local parent=$(cat /sys/class/net/${IFNAME}/parent)`\nThese allow command injection if IFNAME contains shell metacharacters like semicolons.", "risk_score": 7.0, "confidence": 9.0, "notes": "The script may be invoked by other processes (e.g., hostapd or hotplug events) with higher privileges, which could increase impact, but this requires further cross-context analysis. Recommend reviewing how the script is triggered in the system and sanitizing all inputs. Additional analysis of related files (e.g., those calling this script) could reveal broader attack surfaces.", "file_path": "lib/wifi/wps-hostapd-update-uci"}
{"name": "stack-buffer-overflow-fcn.000086e8", "location": "priority:0x000088f4 fcn.000086e8", "description": "In the 'set_info' command processing of the 'priority' binary, there exists a stack buffer overflow vulnerability. Trigger condition: When an attacker runs the program in 'set_info' mode and provides a malicious priority value, the program uses sprintf to write the formatted string '{%d}' to a fixed-size stack buffer (only 10 bytes). If the string generated by the priority value exceeds 10 bytes (for example, when the priority is 1000000000, the string is '{1000000000}', length 12 bytes), it causes a stack buffer overflow. The overflow may overwrite saved registers (including the return address lr), allowing the attacker to control the program flow and execute arbitrary code. Exploitation method: The attacker runs 'priority set_info <MAC> <malicious priority>' as a logged-in user, where the malicious priority is carefully crafted to overflow the buffer and inject shellcode or overwrite the return address.", "link_identifiers": ["Command line argument argv[2] (MAC address)", "Command line argument argv[3] (priority value)", "File path /TM/qos.conf"], "code_snippet": "0x000088f4      0d00a0e1       mov r0, sp                  ; char *s\n0x000088f8      68ffffeb       bl sym.imp.sprintf          ; int sprintf(char *s, const char *format, ...)\n; The format string is \"{%d}\", the argument is the priority value r4, the target buffer is sp (size only 10 bytes)", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability is located at the sprintf call in the 'set_info' branch. Further verification of practical exploit feasibility is needed, such as testing specific priority values to confirm the overflow length and overwrite effect. It is recommended to check if stack protection (like CANARY) is enabled in the binary, but it is not obviously visible from the decompiled code. The associated function fcn.00008b88 is responsible for file reading, and no direct vulnerability was found. The attack chain is complete: input point (command line arguments) → data flow (sprintf) → dangerous operation (stack overflow).", "file_path": "iQoS/R9000/TM/priority"}
{"name": "Command-Injection-wifi_updown", "location": "wifi script, function wifi_updown", "description": "In the `wifi_updown` function, `eval` is used to execute dynamically generated command strings, where `$driver` and `$iftype` come from the configuration file. If an attacker can modify the wireless configuration (such as through the web interface), injecting shell metacharacters (such as semicolons or backticks) can lead to arbitrary command execution. Trigger condition: The script runs with root privileges when WiFi is enabled or disabled. Exploitation method: A non-root user modifies the `driver` or `iftype` value in the configuration to a malicious string (e.g., 'a; malicious_command'). When `eval` executes, the injected command runs with root privileges. Boundary check: The script does not filter or validate `$driver` or `$iftype`.", "link_identifiers": ["NVRAM/ENV: wireless configuration variables (driver, iftype)", "File path: /etc/config/wireless", "IPC: UCI configuration system", "Function symbol: pre_${driver}, ${1}_$iftype"], "code_snippet": "for driver in ${DRIVERS}; do (\n    if eval \"type pre_${driver}\" 2>/dev/null >/dev/null; then\n        eval \"pre_${driver}\" ${1}\n    fi\n); done\nfor device in ${2:-$DEVICES}; do (\n    config_get iftype \"$device\" type\n    if eval \"type ${1}_$iftype\" 2>/dev/null >/dev/null; then\n        eval \"${1}_$iftype\" '$device' || echo \"$device($iftype): ${1} failed\"\n    else\n        echo \"$device($iftype): Interface type not supported\"\n    fi\n); done", "risk_score": 7.5, "confidence": 8.0, "notes": "The attack chain relies on non-root users being able to modify wireless configuration, which may be possible in OpenWrt through the web interface or UCI commands. It is recommended to verify the write permissions and authentication mechanisms of configuration files. Related files: /lib/wifi (defines DRIVERS).", "file_path": "sbin/wifi"}
{"name": "Command-Injection-QoSControl-update", "location": "QoSControl: function update (approx lines after 'line=`cat /tmp/Trend_Micro.db | grep netgear-detection`')", "description": "A command injection vulnerability exists in the update function. An attacker can control the $version variable by tampering with the contents of the /tmp/Trend_Micro.db file. This variable is not properly quoted in the unzip command. When QoSControl update (or related functions like auto_update, boot) is called, the script parses /tmp/Trend_Micro.db and executes `unzip -o /tmp/$version -d /tm_pattern/`. If $version contains shell metacharacters (such as a semicolon), the attacker can inject arbitrary commands. Trigger condition: The attacker must first create or modify the /tmp/Trend_Micro.db file (since /tmp is typically globally writable), and then call QoSControl update. Exploitation method: Embed malicious commands in $version (e.g., 'malicious;id;'), causing the commands to execute with the privileges of the script's running user (possibly root), achieving privilege escalation.", "link_identifiers": ["/tmp/Trend_Micro.db", "trend_micro_enable", "auto_update", "first_boot_qos"], "code_snippet": "line=`cat /tmp/Trend_Micro.db | grep netgear-detection`\nif [ \"x$line\" != \"x\" ] ; then\n\tversion=`echo $line |awk -F \" \" '{print $9}'`\n\t...\n\tcurl ftp://updates1.netgear.com/sw-apps/dynamic-qos/trend/r9000/$version -o /tmp/$version 2>/dev/null\n\t...\n\tunzip -o /tmp/$version -d /tm_pattern/", "risk_score": 9.0, "confidence": 8.5, "notes": "Assumes the QoSControl script runs with root privileges (common for firmware management scripts). Further validation of the security of other components like /TM/priority and /tm_pattern/sample.bin is needed, but this vulnerability exists independently. It is recommended to check script execution permissions and /tmp directory access controls.", "file_path": "iQoS/R8900/TM/QoSControl"}
{"name": "Buffer-Overflow-set_info", "location": "priority:0x00008798 fcn.000086e8", "description": "In the 'set_info' command of the 'priority' program, there exists a stack buffer overflow vulnerability. When the program processes the user-provided MAC address parameter (argv[2]), it uses the sprintf function to format 'mac=%s' into a stack buffer. This buffer has a size of 25 bytes, but the length of the user-input MAC address is not restricted, leading to an overflow. Trigger condition: an attacker executes the 'priority set_info <MAC> <priority>' command, where <MAC> is a long string (exceeding 21 bytes). The overflow can overwrite the saved return address (lr register), allowing control flow hijacking and code execution. Potential attack methods include injecting shellcode or a ROP chain, provided the system lacks ASLR or stack protection (common in embedded devices). Constraints: the program must be executed by a user, and argc >= 4.", "link_identifiers": ["argv[2] (MAC address parameter)", "/TM/qos.conf"], "code_snippet": "0x00008798: add r0, src                 ; char *s (buffer at sp+0x0c)\n0x0000879c: bl sym.imp.sprintf          ; int sprintf(char *s, const char *format, ...)\n; Format string: \"mac=%s\" at address 0x8db8\n; User input: r6 (argv[2])", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability has been verified through disassembly, and the exploit chain is complete: user-controlled input -> sprintf buffer overflow -> return address overwrite -> code execution. It is recommended to further test exploit feasibility and check system protection mechanisms (such as ASLR, NX). Related file: /TM/qos.conf (the configuration file written by the program).", "file_path": "iQoS/R8900/TM/priority"}
{"name": "CommandInjection-fcn.0000ce90", "location": "sample.bin:0xcefc (fcn.0000ce90)", "description": "The analysis of 'sample.bin' revealed a potential command injection vulnerability in the function fcn.0000ce90, which constructs a command string using sprintf and executes it via system. The function is called from fcn.0000d904, which handles user-provided actions via the '-a' option. The input string is not sanitized before being used in the command, allowing an attacker to inject arbitrary commands. The attack chain involves: 1) A non-root user providing a malicious action string with command injection payloads via the '-a' option. 2) The string being passed to fcn.0000ce90 without validation. 3) The sprintf function building a command that includes the user input. 4) The system function executing the malicious command. This could lead to remote code execution or privilege escalation if the injected commands are executed with sufficient privileges. The vulnerability is triggered when specific actions like 'set_app_patrol' are used, but further analysis is needed to confirm the exact trigger conditions.", "link_identifiers": ["action", "set_app_patrol", "/TM/QoSControl set_priority"], "code_snippet": "0x0000cee8      24109fe5       ldr r1, str._TM_QoSControl_set_priority__s__d ; [0xf0b0:4]=0x2f4d542f ; \"/TM/QoSControl set_priority %s %d\" ; const char *format\n0x0000ceec      0520a0e1       mov r2, r5\n0x0000cef0      04008de2       add r0, string              ; char *s\n0x0000cef4      8cefffeb       bl sym.imp.sprintf          ; int sprintf(char *s, const char *format, ...)\n0x0000cef8      04008de2       add r0, string              ; const char *string\n0x0000cefc      3cefffeb       bl sym.imp.system           ; int system(const char *string)", "risk_score": 7.5, "confidence": 7.0, "notes": "The vulnerability requires further validation to confirm the complete data flow from user input to the system call. The function fcn.0000ce90 is called from fcn.0000d904, which is associated with actions like 'set_app_patrol'. Additional analysis of the action handlers is recommended to identify all potential input points. The exploitability depends on the permissions of the 'sample.bin' process when executed by a non-root user.", "file_path": "iQoS/R8900/tm_pattern/sample.bin"}
{"description": "The script uses `eval` on the `mode` variable without proper sanitization, which could lead to command injection if the `mode` value is controlled by an attacker. The `mode` is obtained from a configuration system using `config_get`, and if an attacker can set it to a malicious string (e.g., including shell metacharacters), it might execute arbitrary commands with root privileges (assuming the script runs as root). The `type` check might limit some injections, but it could be bypassed if the attacker can define a function or craft the input appropriately. Trigger condition: Attacker controls the `powerctl mode` configuration value. Potential attack: Command injection to escalate privileges or perform unauthorized actions.", "link_identifiers": ["powerctl mode (NVRAM or UCI configuration variable)"], "location": "powerctl: approximately lines 40-46, in the start() function", "code_snippet": "start() {\n\tconfig_load system\n\tconfig_get mode powerctl mode \"auto\"\n\n\tif eval \"type ipq806x_power_${mode}\" 2>/dev/null >/dev/null; then\n\t\teval ipq806x_power_${mode}\n\telse\n\t\techo \"\\\"${mode}\\\" power mode not supported\"\n\tfi\n}", "risk_score": 5.0, "confidence": 6.0, "notes": "The exploitability depends on whether a non-root user can modify the 'powerctl mode' configuration. Further analysis is needed to verify the configuration source (e.g., UCI, NVRAM) and access controls. If the configuration is writable by non-root users or through exposed services, this could be a viable attack chain. Recommend investigating how the configuration is set and if there are any IPC or network interfaces that allow mode modification.", "file_path": "etc/init.d/powerctl"}
{"name": "CommandInjection-setup_interface_dhcp", "location": "net-wan: function setup_interface_dhcp (approximate line numbers 100-110, based on script content)", "description": "In multiple functions of the 'net-wan' script, configuration values obtained from NVRAM via `$CONFIG get` are used unquoted in shell command execution, creating a command injection vulnerability. Specifically, in the `setup_interface_dhcp` function, the `u_hostname` variable (from the `wan_hostname` or `Device_name` configuration) is directly used in the `udhcpc` command's `-h` option. If an attacker sets `wan_hostname` to a malicious value (such as 'example.com; malicious_command'), when the script executes, the shell will parse and execute the injected command. The attack trigger condition is when an attacker modifies the NVRAM configuration value via the Web interface or API, and then triggers the WAN interface to reconnect (e.g., by restarting the network service). The exploitation method is simple and can achieve root privileges because the script runs as root.", "link_identifiers": ["wan_hostname", "Device_name", "wan_dhcp_ipaddr", "wan_dhcp_oldip", "wan_domain", "/www/cgi-bin/firewall.sh", "udhcpc"], "code_snippet": "setup_interface_dhcp()\n{\n\tlocal mtu\n\tlocal u_hostname\n\tlocal u_wan_domain=$($CONFIG get wan_domain)\n\n\tmtu=$($CONFIG get wan_dhcp_mtu)\n\tifconfig $WAN_IF mtu ${mtu:-1500}\n\t\n\tif [ \"x$($CONFIG get wan_hostname)\" != \"x\" ];then\n\t\tu_hostname=$($CONFIG get wan_hostname)\n\telse\n\t\tu_hostname=$($CONFIG get Device_name)\n\tfi\n\tif [ \"$changing_mode\" = \"1\" ]; then\n\t\tudhcpc -b -i $WAN_IF -h $u_hostname -r $($CONFIG get wan_dhcp_ipaddr) -N $($CONFIG get wan_dhcp_oldip) ${u_wan_domain:+-d $u_wan_domain} &\n    \telse\n\t\tudhcpc -b -i $WAN_IF -h $u_hostname -r $($CONFIG get wan_dhcp_ipaddr) -N $($CONFIG get wan_dhcp_oldip) ${u_wan_domain:+-d $u_wan_domain}\n    \tfi\t\n}", "risk_score": 9.0, "confidence": 9.0, "notes": "The attack chain is complete and verifiable: attacker modifies NVRAM configuration -> command injection during script execution -> gains root privileges. Further verification is needed on whether the `$CONFIG` command indeed retrieves values from NVRAM and if attackers can modify them, but based on common firmware behavior, this is reasonable. It is recommended to check if other similar functions (like `setup_interface_ppp`) have the same issue.", "file_path": "etc/init.d/net-wan"}
{"description": "The 'hotplug2' binary contains a command injection vulnerability where user-controlled command-line arguments are used directly in exec* functions without sanitization. In function fcn.00009270, command-line arguments are parsed using strcmp and strdup, and stored in global variables. Specifically, puVar1[8] is set from a command-line argument and later used in sym.imp.execlp(uVar9, uVar9, iVar11) where uVar9 is puVar1[8]. This allows an attacker to inject arbitrary commands by crafting malicious arguments. As a non-root user with login credentials, the attacker can execute hotplug2 with controlled arguments to run arbitrary commands with their privileges. The binary has permissions -rwxrwxrwx, making it executable by any user, and no setuid bit is set, so it runs with the user's privileges. This vulnerability is directly exploitable via command-line invocation.", "link_identifiers": ["puVar1[8]", "sym.imp.execlp", "command-line arguments"], "location": "hotplug2:0x00009270 fcn.00009270", "code_snippet": "// From fcn.00009270 decompilation\niVar13 = sym.imp.strcmp(iVar12,*0x9840);\nif (iVar13 != 0) {\n    iVar13 = sym.imp.strcmp(iVar12,*0x9844);\n    if (iVar13 == 0) {\n        iVar11 = iVar15 + 0;\n        if (iVar11 == 0) break;\n        uVar9 = sym.imp.strdup(piVar8[1]);\n        puVar1[8] = uVar9; // User-controlled argument stored\n        piVar8 = piVar14;\n    }\n    // ... other cases\n}\n// Later in the code\nif (iVar11 != 0) {\n    sym.imp.waitpid(iVar11,puVar19 + 0xfffff5fc,0);\n    goto code_r0x000095dc;\n}\nsym.imp.execlp(uVar9,uVar9,iVar11); // Direct use in execlp", "risk_score": 7.5, "confidence": 9.0, "notes": "This vulnerability requires the user to have execution access to hotplug2, which is granted by the file permissions. No privilege escalation is achieved, but arbitrary command execution as the user is possible. Further analysis could reveal if network input or environment variables also lead to command injection, but the command-line argument path is already verifiable and exploitable.", "file_path": "sbin/hotplug2"}
{"name": "BufferOverflow-fcn.0000cf18", "location": "sample.bin:0xcf50 fcn.0000cf18", "description": "In function fcn.0000cf18, after using config_get to retrieve a configuration value, it is copied to a fixed-size buffer via strcpy, lacking boundary checks. An attacker can inject an overly long string by controlling configuration data (e.g., via NVRAM settings or a malicious configuration file), causing a buffer overflow that may overwrite adjacent memory and execute arbitrary code. Trigger condition: when the program processes configuration values (e.g., through specific operations or initialization). Constraint: buffer size is unknown, but the use of strcpy indicates no size limit. Potential attack method: an attacker, as a logged-in user, may modify configuration variables, passing a crafted input to hijack control flow.", "link_identifiers": ["config_get", "trend_micro_enable", "trendmicro_console_enable", "/tm_pattern/bwdpi.devdb.db"], "code_snippet": "uVar2 = sym.imp.config_get(puVar10 + -0xa4);\nsym.imp.strcpy(puVar10 + -0x84, uVar2);\n...\nsym.imp.strcpy(iVar6, uVar2);\n...\nsym.imp.strcpy(iVar7 + 0x18, uVar3);", "risk_score": 7.5, "confidence": 8.0, "notes": "Vulnerability exploitability depends on the source of configuration data (e.g., NVRAM variables). It is recommended to further analyze the call chain of config_get to confirm the input point. Associated file: /tm_pattern/bwdpi.devdb.db. Next steps: trace NVRAM variable settings and data flow to this function.", "file_path": "iQoS/R9000/tm_pattern/sample.bin"}
{"name": "command-injection-tcd-recvfrom", "location": "tcd:0x8fac fcn.00008fac", "description": "A command injection vulnerability exists in the main loop of 'tcd'. The program uses `recvfrom` to receive data from a network socket and checks the message type (nlmsg_type). If the message type is 0x905, it extracts a string from the received data (via the global pointer `*0x9244`) and uses `snprintf` to embed it into a 'tc %s' command string, which is then executed via `system`. An attacker can craft a malicious network message to control the embedded string, thereby injecting arbitrary commands. Trigger condition: The attacker sends a message of type 0x905, and the message content contains command injection characters (such as ';', '|', or '`'). Constraints: The buffer size is limited (0x103 bytes), but sufficient for common injections; there is a lack of input validation and escaping. Potential attacks: Command execution may lead to privilege escalation, information disclosure, or system control.", "link_identifiers": ["socket (recvfrom)", "NVRAM/ENV: *0x9244", "command: tc"], "code_snippet": "// Receive data from the network\nuVar2 = sym.imp.recvfrom(uVar3, 0x21dc | 0x10000, 0x110, 0);\n// Check message type and set global variable\nif (*(puVar5[-1] + 4) == 0x905) {\n    *(0x21d8 | 0x10000) = *0x9244;\n}\n// Build command string and execute\nsym.imp.snprintf(0x22ec | 0x10000, 0x103, \"tc %s\", *(0x21d8 | 0x10000));\nsym.imp.system(0x22ec | 0x10000);", "risk_score": 8.5, "confidence": 8.5, "notes": "The attack chain is complete: entry point (network socket) → data flow (global variable setting) → dangerous operation (system call). Further verification of socket initialization (e.g., in fcn.00008d7c) is needed to confirm attacker reachability. It is recommended to test actual exploitation, such as sending malicious messages to the process socket. Related files: May involve network configuration or other components, but the current analysis is limited to 'tcd'.", "file_path": "iQoS/R9000/TM/tcd"}
{"name": "CommandInjection-dni-wifi-config", "location": "dni-wifi-config: Main section (within the 'if [ -n \"$DNI_CONFIG\" ]; then' block)", "description": "In the 'dni-wifi-config' script, using `eval` to directly execute the output of `dniconfig get` (for example, for the `wl_hw_btn_state` configuration value) lacks input validation and filtering. If an attacker can control the configuration value, they can inject shell metacharacters (such as semicolons) to execute arbitrary commands. The trigger condition is when the script runs with root privileges (such as during system startup or WiFi configuration updates), and the configuration value contains malicious commands. An attacker as a non-root user but possessing login credentials might modify the configuration value through a management interface (like a Web GUI), completing the attack chain: modify configuration -> script execution -> command injection -> privilege escalation.", "link_identifiers": ["wl_hw_btn_state", "endis_wl_radio", "endis_wla_radio", "wlg1_endis_guestNet", "wla1_endis_guestNet"], "code_snippet": "eval wl_hw_btn_state=`dniconfig get wl_hw_btn_state`\n[ -z \"$wl_hw_btn_state\" ] && {\n    wl_hw_btn_state=on\n    dniconfig set wl_hw_btn_state=\"on\"\n}", "risk_score": 8.5, "confidence": 8.0, "notes": "Other similar uses of `eval` in the script (such as for onoff variables) might also be vulnerable, but the 'wl_hw_btn_state' location is the most direct. It is recommended to validate the input filtering and permission settings of the `dniconfig` command and check if the script runs with root privileges. Subsequent analysis can examine how the management interface modifies these configuration values.", "file_path": "etc/dni-wifi-config"}
{"description": "A command injection vulnerability was discovered in 'sample.bin', allowing attackers to inject malicious commands via the command line option '-a' and execute arbitrary system commands. The vulnerability is located in function fcn.0000ce90, which uses sprintf to construct the command string '/TM/QoSControl set_priority %s %d', where %s comes directly from user input (via offset 0x18 of parameter s1). The input is only compared against fixed strings ('HIGHEST', 'HIGH', 'MEDIUM'), but the input is not filtered or escaped, allowing additional commands to be injected if the input contains special characters (such as semicolons, backticks). An attacker, as an authenticated non-root user, can trigger the vulnerability by executing the binary and providing a malicious '-a' argument, potentially gaining command execution privileges (depending on the binary's permissions).", "link_identifiers": ["Command line argument: -a", "Environment variable: None", "NVRAM variable: None", "File path: /TM/QoSControl", "IPC socket: None", "Custom shared function symbol: fcn.0000ce90"], "location": "sample.bin:0x0000ce90 fcn.0000ce90", "code_snippet": "0x0000cee8      24109fe5       ldr r1, str._TM_QoSControl_set_priority__s__d ; [0xf0b0:4]=0x2f4d542f ; \"/TM/QoSControl set_priority %s %d\" ; const char *format\n0x0000ceec      0520a0e1       mov r2, r5\n0x0000cef0      04008de2       add r0, string              ; char *s\n0x0000cef4      8cefffeb       bl sym.imp.sprintf          ; int sprintf(char *s, const char *format, ...)\n0x0000cef8      04008de2       add r0, string              ; const char *string\n0x0000cefc      3cefffeb       bl sym.imp.system           ; int system(const char *string)", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability exploit chain is complete: input point (command line option '-a') → data flow (passed through main function fcn.00008dc8 to fcn.0000ce90) → dangerous operation (system call). The attacker needs execution privileges, and the binary may run with elevated permissions (e.g., setuid), increasing the risk. It is recommended to further verify the binary's permissions in the target environment and the input propagation path.", "file_path": "iQoS/R9000/TM/sample.bin"}
{"name": "Arbitrary-Memory-Write-fcn.00011090", "location": "fcn.00011090:0x00011090 (Key propagation points are located in sub-functions fcn.00010b2c:0x00010b2c and fcn.00010b8c:0x00010b8c)", "description": "In function fcn.00011090, the user-controlled input parameter param_1 propagates through sub-functions fcn.00010b2c and fcn.00010b8c, ultimately controlling the buffer pointer of sym.imp.vsnprintf, allowing arbitrary memory writes. The trigger condition is calling fcn.00011090 via an external interface (such as a network service or API) and passing a maliciously crafted param_1. An attacker can overwrite critical memory regions by manipulating the pointer value, leading to code execution, privilege escalation, or system crash. The code logic involves state machine parsing and dynamic memory allocation, with tainted data propagating through loops and conditional branches, lacking pointer validation. Constraints include the need to precisely control the pointer value to point to a valid memory address, and the attacker must have permission to call this function.", "link_identifiers": ["fcn.00011090", "fcn.00010b2c", "fcn.00010b8c", "fcn.00011f5c", "sym.imp.vsnprintf"], "code_snippet": "Relevant parts from the decompiled code of fcn.00011090:\n- iVar2 = fcn.00010b2c(*(piVar6[-8] + 0xc));  // Tainted data passed to fcn.00010b2c\n- iVar2 = fcn.00010b8c(*(piVar6[-8] + 0xc), piVar6 + -0x18);  // Tainted data passed to fcn.00010b8c\nFrom the taint propagation path, in fcn.00011f5c:\n- sym.imp.vsnprintf(*(puVar1 + -0x10), 0xff, *(puVar1 + 8), *(puVar1 + -8));  // Tainted data used as buffer parameter", "risk_score": 8.5, "confidence": 9.0, "notes": "Taint propagation was verified through FunctionDelegator analysis, showing a complete path from param_1 to vsnprintf. Further verification of the calling context of fcn.00011090 (e.g., whether it is called via HTTP service, IPC, or NVRAM interface) is needed to confirm the accessibility of the input point. It is recommended to analyze the components in the firmware that call this function and test the actual exploitation conditions. Associated files may include network daemons or configuration parsers.", "file_path": "bin/ookla"}
{"name": "Command-Injection-fcn.0000f064", "location": "net-cgi: function fcn.0000f064 addresses 0xf148, 0xf150, 0xf168, 0xf1ac, 0xf2cc, 0xf2d0", "description": "In function fcn.0000f064, there exists a command injection vulnerability from getenv(\"REMOTE_ADDR\") to the system call. Specific behavior: After the REMOTE_ADDR environment variable value is obtained, it is used to construct a shell command string (via snprintf and sprintf) without sufficient validation, and is ultimately executed through a system call. Trigger condition: When net-cgi processes a CGI request, the REMOTE_ADDR environment variable is set and contains malicious data (such as shell metacharacters). Constraint: No apparent boundary checks or input filtering. Potential attack: An attacker can inject arbitrary commands (e.g., '; rm -rf /') by forging the REMOTE_ADDR header in an HTTP request, leading to remote code execution. Code logic: getenv → store in memory → process via sub-function → format into buffer → construct command string → system execution.", "link_identifiers": ["REMOTE_ADDR", "/tmp/access_device_list"], "code_snippet": "Taint propagation path code:\n- 0x0000f148: bl sym.imp.getenv ; Get REMOTE_ADDR environment variable\n- 0x0000f150: str r0, [r6] ; Store to memory\n- 0x0000f168: bl fcn.0001cc48 ; Process REMOTE_ADDR value\n- 0x0000f1ac: bl sym.imp.snprintf ; Format into buffer\n- 0x0000f2cc: bl sym.imp.sprintf ; Construct command string \"echo %s >>/tmp/access_device_list\"\n- 0x0000f2d0: bl sym.imp.system ; Execute command", "risk_score": 9.0, "confidence": 9.0, "notes": "The REMOTE_ADDR environment variable is typically controlled by the HTTP request in a CGI context, making it easily manipulable by attackers. The associated function fcn.0001cc48 may involve further processing. It is recommended to verify the manipulability of this variable in actual deployments and check system permissions to assess the impact scope.", "file_path": "usr/sbin/net-cgi"}
{"name": "Arbitrary-Command-Execution-fcn.0003a08c", "location": "net-cgi: Function fcn.0003a08c address 0x3a0e8, Function fcn.000512cc address 0x513f4", "description": "In function fcn.0003a08c, there exists an arbitrary command execution vulnerability from getenv(\"HTTP_USER_AGENT\") to the execve call. Specific behavior: After the HTTP_USER_AGENT environment variable value is obtained, it is passed to the sub-function fcn.000512cc, and finally used as a path parameter for the execve call. Trigger condition: When net-cgi processes a CGI request, the HTTP_USER_AGENT environment variable is set and contains a malicious command path. Constraint: No input validation or path checking. Potential attack: An attacker can set the HTTP_USER_AGENT header to point to a malicious executable file path, causing execve to execute arbitrary code. Code logic: getenv → pass to sub-function → load into register → execve execution.", "link_identifiers": ["HTTP_USER_AGENT"], "code_snippet": "Taint propagation path code:\n- 0x0003a0e8: bl sym.imp.getenv ; Get HTTP_USER_AGENT environment variable\n- 0x0003a1c4: bl fcn.000512cc ; Pass tainted data as parameter\n- 0x000513e4: ldr r0, [var_0h] ; Load tainted data from stack into r0\n- 0x000513f4: bl sym.imp.execve ; Execute command in tainted data", "risk_score": 9.0, "confidence": 9.0, "notes": "The HTTP_USER_AGENT environment variable is typically fully controlled by the client, making it easy for an attacker to exploit. Need to verify if the execve call executes in a privileged context. The associated function fcn.000512cc might involve parameter processing. It is recommended to check system paths and file permissions to assess the impact scope.", "file_path": "usr/sbin/net-cgi"}
{"name": "StackBufferOverflow-priority_set_info", "location": "priority:0x0000879c fcn.000086e8", "description": "During the processing of the 'set_info' command in the 'priority' binary, there exists a stack buffer overflow vulnerability. When the user provides a MAC address parameter, the program uses `sprintf` to write the format string 'mac=%s' into a fixed-size stack buffer (28 bytes), but does not validate the input length. If the MAC address length exceeds 24 bytes (after deducting the 4 bytes for the 'mac=' prefix), it causes a buffer overflow, overwriting the return address and other saved registers on the stack. An attacker, as a logged-in non-root user, can trigger this vulnerability by executing the 'priority set_info \"<long_mac_address>\" \"<priority>\"' command, where <long_mac_address> is a carefully constructed long string (exceeding 24 bytes). The overflow allows control of the program counter (pc), thereby achieving arbitrary code execution, potentially escalating privileges or compromising system stability. The vulnerability trigger condition is simple, requiring only valid command-line parameters.", "link_identifiers": ["Command line argument (argv[2]: MAC address)", "File path: /TM/qos.conf"], "code_snippet": "// Key code snippet extracted from decompilation\nsprintf(puVar17 + -0x1c, \"mac=%s\", uVar11); // uVar11 is the user-provided MAC address\n// puVar17 + -0x1c points to the 28-byte stack buffer auStack_3c\n// No length check, directly uses sprintf", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability has been verified through code analysis; the stack layout shows the buffer is adjacent to saved registers and the return address. The attack chain is complete: from command line input to overflow to code execution. Further testing is recommended to confirm the offset and exploit stability. The associated file /TM/qos.conf might be overwritten, but the primary risk is code execution. Subsequent analysis should check if similar issues exist in other functions or input points.", "file_path": "iQoS/R8900/TM/priority"}
