{"name": "command-injection-cgiConfigNtp", "location": "httpd:0x41bc68 sym.cgiConfigNtp", "description": "A command injection vulnerability exists in the `cgiConfigNtp` function, which handles NTP configuration via CGI. The function reads a date-time string from the global variable `glbWebVar` at offset 0x9e8, formats it into a 'date -s' command using `sprintf`, and executes it via `system`. The input is parsed with `sscanf` using the format '%d.%d.%d-%d:%d:%d', but the original string is used directly in `sprintf` without sanitization. An attacker can inject arbitrary commands by including shell metacharacters (e.g., ';' or '&') in the input. The vulnerability is triggered when a user submits a malicious date-time string through the HTTP interface, such as via a POST request to the NTP configuration endpoint. The attack chain involves: 1. User input being stored in `glbWebVar` through CGI parsing in `web_main` or similar functions; 2. The `cgiConfigNtp` function processing the input and constructing a command string; 3. The command string being executed by `system`, leading to arbitrary command execution as the httpd process user.", "link_identifiers": ["glbWebVar", "CgiSetTable", "CgiGetTable"], "code_snippet": "0x0041bc64      24a5b354       addiu a1, a1, -0x4cac       ; 0x45b354 ; \"%d.%d.%d-%d:%d:%d\" ; arg2\n0x0041bc68      260409e8       addiu a0, s0, 0x9e8         ; arg1\n0x0041bc6c      0320f809       jalr t9                     ; sscanf\n0x0041bc80      8f99831c       lw t9, -sym.imp.sprintf(gp) ; [0x452180:4]=0x8f998010\n0x0041bc8c      24a5b368       addiu a1, a1, -0x4c98       ; 0x45b368 ; \"date -s %s\" ; arg2\n0x0041bc90      260609e8       addiu a2, s0, 0x9e8         ; arg3\n0x0041bc94      0320f809       jalr t9                     ; sprintf\n0x0041bca0      8f998938       lw t9, -sym.imp.system(gp)  ; [0x451200:4]=0x8f998010\n0x0041bca4      0320f809       jalr t9                     ; system", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability requires the attacker to have valid login credentials to access the NTP configuration functionality. The `glbWebVar` structure is populated from HTTP inputs, likely through `cgiSetVar` or similar functions. Further analysis could identify the exact HTTP endpoint and parameters. No additional vulnerabilities like buffer overflows were found in this function, but other CGI functions should be checked for similar issues.", "file_path": "bin/httpd"}
{"name": "BufferOverflow-vsf_read_only_check", "location": "vsftpd:0x41a338 and 0x41a400 (sym.vsf_read_only_check)", "description": "A buffer overflow vulnerability exists in the 'vsf_read_only_check' function due to the use of 'strcpy' to copy user-supplied data into a fixed-size stack buffer (128 bytes) without bounds checking. The function is called during FTP command processing (e.g., for file operations like RETR, STOR) in 'process_post_login'. An attacker with valid FTP credentials could trigger this by sending a crafted file path or argument longer than 127 bytes, potentially overwriting stack memory and leading to arbitrary code execution. The vulnerability requires the attacker to be authenticated but non-root, and exploitation depends on overcoming stack protections and controlling execution flow.", "link_identifiers": ["param_2 in sym.vsf_read_only_check", "FTP commands: RETR, STOR, CWD, etc.", "Call sites in sym.process_post_login"], "code_snippet": "From decompiled code:\n(**(loc._gp + -0x7fa8))(acStack_118, uVar1); // strcpy equivalent\nwhere acStack_118 is a 128-byte buffer and uVar1 is derived from param_2 (user input).", "risk_score": 6.5, "confidence": 6.0, "notes": "The vulnerability is plausible based on code analysis, but full exploitability requires verifying that user input flows to param_2 without length restrictions in all paths. Additional analysis is needed to confirm the attack chain, including testing under real conditions. Other functions like vsf_cmdio_get_cmd_and_arg have input length checks, which may mitigate some risks. Recommend further investigation into data flow from FTP commands to vsf_read_only_check.", "file_path": "bin/vsftpd"}
{"name": "BufferOverflow-sym.set_community", "location": "snmpd:0x004081b0 sym.set_community", "description": "A buffer overflow vulnerability exists in the SNMP community string handling function sym.set_community. The function uses strcpy to copy user-provided community strings from SNMP packets to a fixed-size buffer without bounds checking. An attacker with valid login credentials can send a crafted SNMP packet with a long community string (>72 bytes) to trigger the overflow. The buffer is located at a global address (0x42b040 + index * 0x48), and overflow could corrupt adjacent memory, potentially leading to denial of service or code execution. The vulnerability is triggered when processing SNMP set requests or other operations that modify community strings.", "link_identifiers": ["SNMP community string", "SNMP packets"], "code_snippet": "From decompilation:\n(**(loc._gp + -0x7fac))(param_2 * 0x48 + 0x42b040, *&uStackX_0);\nWhere -0x7fac is strcpy, param_2 is the community index (0-2), and *&uStackX_0 is the user-controlled community string. No length validation is performed before copying.", "risk_score": 6.5, "confidence": 7.0, "notes": "The attack chain involves sending a malicious SNMP packet to the snmpd service. Full exploitation requires overcoming potential mitigations (e.g., ASLR, stack canaries), which may not be present in this embedded environment. Further analysis is needed to determine the exact impact and exploitability. Related functions like fcn.004104b0 also use dangerous string operations but lack clear input paths.", "file_path": "bin/snmpd"}
{"description": "The file 'vsftpd_passwd' stores user passwords in plain text, including weak passwords (such as '1234', 'guest', 'test'), and contains permission flags (for example, '1' may indicate administrator privileges). Problem manifestation: After an attacker logs in as a non-root user, if the file is readable, they can directly obtain the passwords. Trigger condition: The attacker accesses the file path and reads its contents. Constraint: The file must have read permissions, and the vsftpd service must use this file for authentication. Potential attack: The attacker uses the obtained passwords (e.g., admin's '1234') to log into FTP or other services, escalate privileges to administrator, and perform dangerous operations. Code logic: The file format is username:password:flag:flag, separated by semicolons, with passwords unencrypted.", "link_identifiers": ["vsftpd_passwd", "admin:1234", "guest:guest", "test:test"], "location": "vsftpd_passwd", "code_snippet": "admin:1234:1:1;guest:guest:0:0;test:test:1:1;$", "risk_score": 6.0, "confidence": 7.0, "notes": "Evidence is based on file content analysis; further verification is needed for file permissions (e.g., whether it is globally readable) and vsftpd configuration (e.g., whether /etc/vsftpd.conf references this file). Subsequent analysis is recommended to check related configuration files and service status to confirm the feasibility of the attack chain.", "file_path": "etc/vsftpd_passwd"}
{"name": "Command-Injection-sym.smb_panic", "location": "libbigballofmud.so:0x6b89c (function sym.smb_panic)", "description": "In the sym.smb_panic function, the system function is called to execute a 'panic action' command. The command string is obtained through a dynamic function call (e.g., pcVar2 = (**(iVar9 + -0x5854))()), possibly from external configuration (such as NVRAM or environment variables). If an attacker can control this string (for example, by modifying the configuration), malicious commands can be injected. Trigger conditions include system panic events (such as service crashes), which an attacker may trigger through malicious requests. Full attack chain: user-controllable configuration → trigger panic → system execution, potentially leading to arbitrary command execution.", "link_identifiers": ["NVRAM", "environment variables", "sym.smb_panic", "sym.imp.system"], "code_snippet": "Decompiled code shows: char *pcVar2 = (**(iVar9 + -0x5854))(); ... uVar3 = (**(iVar9 + -0x5a90))(pcVar2); where the latter is a system call. Lacks input validation and filtering.", "risk_score": 7.5, "confidence": 8.0, "notes": "Further verification is needed for the specific source of the command string (such as configuration file paths and permissions). Related functions may include configuration parsing routines. It is recommended to check if NVRAM settings or environment variables can be modified by non-root users.", "file_path": "lib/libbigballofmud.so"}
{"name": "UAF-upnp_http_process", "location": "File: ./libwlupnp.so Function: fcn.00004b88 Address: 0x00004bb8; File: ./libwlupnp.so Function: sym.upnp_msg_deinit Address: 0x0000cc38, 0x0000cc20", "description": "A use-after-free vulnerability was discovered in the 'upnp_http_process' function, originating from an error path in HTTP request processing. Specific behavior: When processing an HTTP request, if iStack_28 < 0 (error condition), fcn.00004b88 is called, which in turn calls sym.upnp_msg_deinit. In sym.upnp_msg_deinit, a value is loaded from offset 0x20bc of a tainted pointer and passed to the free function. Trigger condition: An attacker sends a crafted HTTP request to the UPnP interface, triggering the error handling path. Constraint: The attacker must possess valid login credentials (non-root user). Potential attack: By precisely controlling the pointer value at offset 0x20bc, arbitrary memory freeing can be achieved, leading to use-after-free or double-free, potentially exploitable for code execution or privilege escalation. The code logic involves multiple layers of function calls, with tainted data propagating from the HTTP request structure to the free operation.", "link_identifiers": ["UPnP HTTP interface (network entry point)", "Function symbol: sym.upnp_http_process", "Function symbol: fcn.00004b88", "Function symbol: sym.upnp_msg_deinit", "Dangerous function: sym.imp.free"], "code_snippet": "Decompiled code snippet from upnp_http_process (error path):\nif (iStack_28 < 0) {\n    (*(fcn.00004b88 + *(iVar2 + -0x7fd8)))(*aiStackX_0); // Call fcn.00004b88\n    break;\n}\n\nTaint propagation from fcn.00004b88 to sym.upnp_msg_deinit:\n0x00004bb8: jalr t9 // Call sym.upnp_msg_deinit, taint in a0\n\nIn sym.upnp_msg_deinit:\n0x0000cc38: lw v0, 0x28(sp); lw v0, 0x20bc(v0); sw v0, 0x18(sp) // Load value from tainted pointer\n0x0000cc20: lw a0, 0x18(sp); lw v0, -0x7f98(gp); move t9, v0; jalr t9 // Call free", "risk_score": 8.0, "confidence": 9.0, "notes": "This finding is based on complete evidence of the taint propagation path, from the HTTP input point to the free operation. Recommended follow-up analysis: Verify the specific exploitation method for the use-after-free (e.g., constructing memory layout for code execution), check if similar issues exist in other UPnP-related functions. Associated file: ./libwlupnp.so.", "file_path": "lib/libwlupnp.so"}
{"name": "BOF-soap_process", "location": "File: ./libwlupnp.so Function: sym.soap_process Address: 0x00009dfc", "description": "A buffer overflow vulnerability was discovered in the 'soap_process' function, originating from a manual null terminator write operation during SOAP message parsing of the SOAPACTION header. Specific issue: After using the strcspn function to calculate the delimiter position, a null byte is directly written to the calculated address (sb zero, (v0)), without verifying if the address is within the buffer boundaries. Trigger condition: An attacker sends a crafted SOAP message where the SOAPACTION header does not contain the expected delimiter (such as quotes or spaces), causing strcspn to return the entire string length, resulting in the write position exceeding the buffer boundary. Constraint: The attacker must possess valid login credentials (non-root user). Potential attack: By writing a null byte out-of-bounds, it may cause memory corruption, which could be exploited to execute arbitrary code or cause a denial of service. The vulnerability involves a lack of boundary checks, and an attacker can trigger the overflow by controlling the content of the SOAPACTION header.", "link_identifiers": ["SOAPACTION Header", "Function Symbol: sym.soap_process", "Function Symbol: sym.upnp_msg_get", "Function Symbol: sym.upnp_msg_save", "Dangerous Operation: Out-of-Bounds Write"], "code_snippet": "Decompiled code snippet from soap_process:\n0x00009dd8      8f8280b0       lw v0, -sym.imp.strcspn(gp) ; Call strcspn\n0x00009ddc      0040c821       move t9, v0\n0x00009de0      0320f809       jalr t9\n0x00009de4      00000000       nop\n0x00009de8      8fdc0010       lw gp, (var_10h)\n0x00009dec      afc2001c       sw v0, (var_1ch)\n0x00009df0      8fc2001c       lw v0, (var_1ch)\n0x00009df4      8fc30020       lw v1, (var_20h)\n0x00009df8      00621021       addu v0, v1, v0\n0x00009dfc      a0400000       sb zero, (v0) ; Out-of-bounds write of null byte", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability depends on the buffer size returned by 'upnp_msg_get', which does not perform boundary checks. It is recommended to further analyze the buffer allocation mechanism and heap layout to confirm exploitation details. Related functions include 'action_process'. Subsequent analysis directions should include testing actual SOAP message triggers and evaluating the impact of memory corruption.", "file_path": "lib/libwlupnp.so"}
