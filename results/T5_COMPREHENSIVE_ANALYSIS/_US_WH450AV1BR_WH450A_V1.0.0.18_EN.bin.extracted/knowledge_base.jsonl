{"description": "A command injection vulnerability exists in the 'fromCheckTools' function of the httpd binary. The function handles network diagnostic commands (ping and traceroute) by taking user-controlled 'ipaddress' and 'selectcmd' parameters from HTTP requests and constructing system commands without proper sanitization. Specifically, when 'selectcmd' is 'ping', it executes 'ping -c 3 -s 16 [ipaddress] > /var/log.txt', and when 'selectcmd' is 'traceroute', it executes 'traceroute -n [ipaddress] > /var/log.txt'. The 'ipaddress' parameter is directly embedded into the command string, allowing an attacker to inject arbitrary commands using shell metacharacters (e.g., ;, &, |). An authenticated user can exploit this by sending a crafted HTTP request to the vulnerable endpoint, leading to remote code execution with the privileges of the httpd process (often root).", "link_identifiers": ["ipaddress (HTTP parameter)", "selectcmd (HTTP parameter)", "sym.fromCheckTools", "sym.imp.doSystemCmd"], "location": "httpd:0x44dd90 sym.fromCheckTools", "code_snippet": "// From decompiled sym.fromCheckTools\n// str.ping__c_3__s_16__s____var_log.txt_\n(**(iStack_4b8 + -0x7a6c))(*(iStack_4b8 + -0x7fe4) + -0xf4,pcVar4);\n// str.traceroute__n__s____var_log.txt_\n(**(iStack_4b8 + -0x7a6c))(*(iStack_4b8 + -0x7fe4) + -0xd0,pcVar4);\n// Where pcVar4 is user-controlled ipaddress", "risk_score": 9.0, "confidence": 9.0, "notes": "The vulnerability is highly exploitable as it requires only authenticated access and no special privileges. The attack chain is straightforward: user input flows directly to system command execution. Further analysis should verify the exact HTTP endpoint and test exploitation in a controlled environment. Other functions using doSystemCmd may have similar issues and should be reviewed.", "file_path": "bin/httpd"}
{"name": "XSS-wirelessBasic-SSID", "location": "status_wireless.asp: (script section, data.ssid definition), wireless_basic.asp: (form input for SSID), js/status.js: (innerHTML usage in wireless section)", "description": "A stored cross-site scripting (XSS) vulnerability exists due to improper handling of user-controlled SSID input. The attack chain begins in 'wireless_basic.asp', where an attacker can set the SSID field to a malicious payload (e.g., `'; alert('XSS'); //`). This input is submitted to '/goform/wirelessBasic' and stored in NVRAM. When 'status_wireless.asp' is loaded, the SSID value is retrieved via `<%get_wireless_basiclist('SSIDlist');%>` and embedded directly into a JavaScript string without encoding. The payload breaks out of the string context and executes arbitrary JavaScript code during page load. The vulnerability is triggered when any user with active session views 'status_wireless.asp', allowing code execution in their browser context. This can lead to session cookie theft, unauthorized actions, or privilege escalation if the user has higher privileges. Client-side validation in 'wireless_basic.asp' (regex `/^[^\\n\\r,;%&]+$/` and length checks) can be bypassed by sending direct POST requests or disabling JavaScript.", "link_identifiers": ["SSIDlist", "/goform/wirelessBasic", "status_wireless.asp", "wireless_basic.asp", "js/status.js"], "code_snippet": "From status_wireless.asp:\n```javascript\nssid: '<%get_wireless_basiclist(\"SSIDlist\");%>'.split('\\t',8),\n```\nFrom wireless_basic.asp:\n```html\n<input type=\"text\" name=\"ssid\" id=\"ssid\" size=\"20\" maxlength=\"32\" value=\"\" />\n```\nFrom js/status.js:\n```javascript\ntabTb.rows[i].insertCell(1).innerHTML = data[\"ssid\"][i];\n```", "risk_score": 7.5, "confidence": 8.0, "notes": "The attack requires the attacker to have permissions to modify wireless settings (assumed based on login credentials). Server-side validation for SSID input is not visible in the provided files and may be insufficient. Further analysis of server-side GoForm handlers (e.g., '/goform/wirelessBasic') could confirm exploitability. The vulnerability is stored XSS, affecting all users viewing the status page. Recommended mitigation includes output encoding in ASP and input validation on the server.", "file_path": "webroot/status_wireless.asp"}
{"name": "XSS-WDS-Scan-initScan", "location": "js/wl_wds.js: initScan function (approximately lines 50-70)", "description": "A cross-site scripting (XSS) vulnerability exists in the WDS scan functionality due to unsanitized user input from wireless scan results being directly inserted into the DOM. The vulnerability is triggered when an authenticated user scans for WDS APs via the 'Scan' button on the 'wireless_wds.asp' page. The 'initScan' function in 'js/wl_wds.js' processes the scan results from '/goform/WDSScan' and uses innerHTML to dynamically build table rows without sanitizing the SSID field. An attacker can set up a malicious wireless AP with a crafted SSID containing JavaScript code (e.g., '<script>alert(\"XSS\")</script>'). When the user scans, the malicious code executes in the user's browser context, potentially leading to session hijacking, credential theft, or other client-side attacks. The vulnerability bypasses client-side validation as the 'checkMAC' function only validates MAC address inputs, not SSID fields from scan results. Constraints include the need for the attacker to be within wireless range and the user to perform a scan while authenticated.", "link_identifiers": ["wireless_wds.asp", "js/wl_wds.js", "/goform/WDSScan", "wds_list", "ssid"], "code_snippet": "function initScan(scanInfo) {\n\t//scanInfo=\"Test_ssid,c8:3a:35:c8:cc:20,1,NONE,0;\";\n\tvar len = scanInfo.split(\"\\r\").length,\n\t\tstr1 = scanInfo.split(\"\\r\"),\n\t\ti = 0,\n\t\tinfos = '';\n\n\tdocument.getElementById(\"wdsScanTab\").style.display = \"\";\n\tvar tbl = document.getElementById(\"wdsScanTab\").getElementsByTagName('tbody')[0];\n\twhile (tbl.childNodes.length != 0) {\n\t\ttbl.removeChild(tbl.childNodes[0]);\n\t}\n\n\tfor (; i < len; i++) {\n\t\tvar str = str1[i].split(\"\\t\");\n\t\tif(str.length !== 5) continue;\n\t\tinfos += '<tr><td><input type=\"radio\" name=\"wlsSlt\" onclick=\"macAcc()\"/></td><td>' + str[0]\n\t\t\t+ '</td><td>' + str[1] + '</td><td>' + str[2] + '</td><td>' + str[3] + '</td><td>' + str[4] + '</td></tr>'; \n\t}\n\t$(tbl).html(infos);\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "The vulnerability is verifiable through code analysis, and the attack chain is complete: attacker controls SSID via malicious AP -> user scans -> XSS executes. However, server-side validation of '/goform/WDSScan' was not analyzed, which might mitigate the risk if sanitization occurs there. Additional analysis of server-side components (e.g., binaries handling '/goform' endpoints) is recommended to confirm exploitability. The user must be authenticated and perform a scan, which is a realistic scenario given the attack context.", "file_path": "webroot/wireless_wds.asp"}
{"description": "A stored cross-site scripting (XSS) vulnerability exists in the wireless client list display function. The attack chain is as follows: 1) An attacker uses valid login credentials to access 'wireless_basic.asp' and modifies the SSID field to contain malicious JavaScript code (e.g., `<script>alert('XSS')</script>`). 2) The data is submitted via the '/goform/wirelessBasic' endpoint and stored in the backend (likely NVRAM). 3) When a user visits 'status_wirelesslist.asp', the server-side function `get_wireless_basiclist` retrieves the SSID data from storage and embeds it into a JavaScript variable (e.g., `wirelessList`). 4) In 'js/status.js', the data is dynamically inserted into the page via `innerHTML`, causing the malicious script to execute. Trigger Condition: After an attacker modifies the SSID, any user accessing the wireless client list page. Constraints: Client-side validation (such as the regular expression `/^[^\\n\\r,;%&]+$/` in the `preSubmit` function) can be bypassed, allowing an attacker to send malicious data directly to the server. Potential attack methods: Stealing session cookies, executing arbitrary JavaScript, redirecting users to malicious websites.", "link_identifiers": ["SSID input field in wireless_basic.asp", "/goform/wirelessBasic", "get_wireless_basiclist", "wirelessList variable", "innerHTML in js/status.js"], "location": "Multiple files: wireless_basic.asp (SSID input), status_wirelesslist.asp (data embedding), js/status.js (data insertion via innerHTML)", "code_snippet": "// From wireless_basic.asp - SSID input field\n<input type=\"text\" name=\"ssid\" id=\"ssid\" size=\"20\" maxlength=\"32\" value=\"\" />\n\n// From status_wirelesslist.asp - data embedding\nwirelessList = '<%get_wireless_basiclist(\"WirelessEnablelist\");%>',\n\n// From js/status.js - dangerous innerHTML usage\nfor (var i = 0; i < str_len.length; i++) {\n    tabTb.rows[i].insertCell(1).innerHTML = mac[i]; // Direct insertion of unescaped data\n}", "risk_score": 7.0, "confidence": 7.5, "notes": "This attack chain is complete and verifiable: the entry point (SSID), data flow (backend storage), and dangerous operation (innerHTML) all exist. However, code verification for the backend handler (e.g., '/goform/wirelessBasic') is missing; it is recommended to further analyze the backend to confirm input filtering. Related files: wireless_basic.asp, status_wirelesslist.asp, js/status.js, public/gozila.js (contains client-side validation functions).", "file_path": "webroot/status_wirelesslist.asp"}
{"description": "The NetCtrlMsgHandle function in 'netctrl' processes incoming messages and uses the input string length as an index into a jump table of function pointers. The function checks that the length is not greater than 0x2b (43), ensuring the index is within bounds (0-43). However, the jump table at address 0x00411260 contains all invalid entries (0xffffffff), meaning any valid index would attempt to call an invalid function pointer, leading to a crash. This constitutes a denial-of-service vulnerability, as an attacker with valid login credentials could send a crafted message to trigger the crash. However, there is no evidence of arbitrary code execution or privilege escalation, as the bounds check prevents out-of-bounds access and the invalid pointers do not allow control over executed code. The vulnerability requires the attacker to be able to send messages to the 'netctrl' process, which likely involves IPC or network interfaces, but the exact mechanism is not detailed in the binary.", "link_identifiers": ["netctrl", "NetCtrlMsgHandle", "IPC communication"], "location": "netctrl:0x00403498 NetCtrlMsgHandle", "code_snippet": "// From decompilation:\nuVar2 = (**(iVar8 + -0x7f78))(param_2); // Get string length\nif (0x2b < uVar2) {\n    return 1; // Bounds check\n}\nuVar3 = (*(*(uVar2 * 4 + *(iVar8 + -0x7fe4) + 0x1260) + iVar8))(); // Jump table call\n\n// Jump table at 0x00411260 contains 0xffffffff for all entries", "risk_score": 3.0, "confidence": 7.0, "notes": "The jump table is uninitialized, leading to crashes but not code execution. Further analysis is needed to determine how messages are delivered to 'netctrl' (e.g., via IPC sockets or network interfaces). No other exploitable vulnerabilities were found in the analyzed functions. Recommend verifying the message delivery mechanism and checking for other input points in the system.", "file_path": "bin/netctrl"}
{"name": "stack-buffer-overflow-apmng_svr-main", "location": "apmng_svr:0x004036f4 main", "description": "In the main function of the 'apmng_svr' program, there exists a stack buffer overflow vulnerability. The program uses `recvfrom` to receive UDP packets and copies the data into a fixed-size buffer (100 bytes). Before copying, the program checks the length of the input string (via `strlen`), but the check condition allows inputs up to 300 bytes, while the target buffer is only 100 bytes. When the input data length exceeds 100 bytes, the `strcpy` operation causes a stack buffer overflow, overwriting the return address and other stack data. An attacker can craft a UDP packet with a length between 101 and 300 bytes and send it to port 20560, triggering the overflow and controlling the program execution flow to achieve arbitrary code execution. The vulnerability trigger condition is simple and requires no authentication, as the program listens on the network interface.", "link_identifiers": ["UDP port 20560", "socket", "recvfrom", "strcpy"], "code_snippet": "0x004036f4      0c82998f       lw t9, -sym.imp.strcpy(gp)  ; [0x407db0:4]=0x8f998010\n0x004036f8      00000000       nop\n0x004036fc      09f82003       jalr t9\n0x00403700      21208002       move a0, s4  ; Target buffer (100 bytes)\n0x00403704      2128c003       move a1, fp  ; Source data (user input)\n; Pre-check: strlen(fp) - 0xf < 0x11e (i.e., strlen(fp) < 301)\n0x004036cc      6080998f       lw t9, -sym.imp.strlen(gp)  ; [0x408030:4]=0x8f998010\n0x004036d0      00000000       nop\n0x004036d4      09f82003       jalr t9\n0x004036d8      2120c003       move a0, fp\n0x004036dc      21984000       move s3, v0  ; Input length\n0x004036e0      f1ff4224       addiu v0, v0, -0xf\n0x004036e4      1e01422c       sltiu v0, v0, 0x11e\n0x004036e8      6000bc8f       lw gp, (var_60h)\n0x004036ec      c6ff4010       beqz v0, 0x403608  ; If length exceeds 300, skip strcpy", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability exists in the general input handling path of the main function, affecting all received UDP packets. The program is an embedded binary for the MIPS architecture, which may lack mitigation measures such as ASLR or stack protection, increasing exploitability. It is recommended to further validate the exploit chain, for example by constructing a ROP chain or shellcode. Related functions include `recvfrom` and `strcpy`, with the input point coming from the network interface.", "file_path": "bin/apmng_svr"}
{"description": "A command injection vulnerability exists in 'tenda_wifid' where NVRAM variables '_ifname' and '_closed' are used unsanitized in system commands. The program retrieves these values via 'GetValue' and constructs commands like 'wl -i %s closed 1' using 'strcat_r' or similar functions, then executes them with 'doSystemCmd'. An attacker with valid login credentials (non-root) can set these NVRAM variables through vulnerable interfaces (e.g., web UI), allowing command injection by including shell metacharacters (e.g., semicolons) in the values. This can lead to arbitrary command execution with the privileges of the 'tenda_wifid' process, which may be elevated. The vulnerability is triggered when the daemon processes the NVRAM values in its main loop, which runs periodically.", "link_identifiers": ["NVRAM:_ifname", "NVRAM:_closed", "NVRAM:_maxassoc", "function:GetValue", "function:doSystemCmd", "function:strcat_r"], "location": "tenda_wifid:0x400a6c (GetValue call), 0x400a88 (doSystemCmd call) in main function", "code_snippet": "From decompilation at main:\npcVar5 = *(iVar7 + -0x7fcc); // strcat_r\nuVar1 = (*pcVar5)(&uStack_d0, iVar9 + 0xe10, auStack_78); // _ifname\n(*pcVar6)(uVar1, &uStack_c8); // Build string\n(**(iVar7 + -0x7fb4))(*(iVar7 + -0x7fe4) + 0xe18, &uStack_c8); // doSystemCmd with \"wl -i %s closed 1\"\n\nDisassembly around 0x400a60:\n0x400a60      lw t9, -0x7fcc(gp)\n0x400a64      nop\n0x400a68      jalr t9\n0x400a6c      nop\n0x400a70      lw t9, -0x7fa4(gp)\n0x400a74      nop\n0x400a78      jalr t9\n0x400a7c      nop\n0x400a80      lw t9, -0x7fb4(gp)\n0x400a84      nop\n0x400a88      jalr t9\n0x400a8c      nop", "risk_score": 8.5, "confidence": 8.0, "notes": "The attack chain requires the attacker to set NVRAM variables, which may be possible via web interfaces or other services. Further analysis could identify specific interfaces that allow NVRAM modification. The vulnerability is repeatable and has a high probability of exploitation if NVRAM access is granted. No buffer overflow was identified in this analysis, but command injection is confirmed.", "file_path": "bin/tenda_wifid"}
{"name": "BufferOverflow-handle_socket", "location": "cfmd:0x00401920 sym.handle_socket", "description": "In the handle_socket function, the read system call is used to read 1028 bytes of data from a socket into the stack buffer aiStack_818[65] (an int32_t array, 65*4=260 bytes), which is only 260 bytes, causing a stack buffer overflow. An attacker, as an authenticated non-root user, can overwrite the return address and execute arbitrary code by sending a crafted packet to /var/cfm_socket. Trigger condition: Sending more than 260 bytes of data to the socket. Exploitation method: Constructing a malicious payload to control program flow, achieving privilege escalation or system takeover.", "link_identifiers": ["/var/cfm_socket", "cfmd"], "code_snippet": "iVar1 = (**(iVar9 + -0x7f18))(param_1,aiStack_818);\nif (iVar1 != 0x404) { return 0; }", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability exists in the network input processing path and does not depend on other components. It is recommended to check whether socket permissions allow non-root user access. Subsequent analysis can focus on vulnerability exploitation details, such as calculating offsets and constructing ROP chains.", "file_path": "bin/cfmd"}
{"name": "stack-buffer-overflow-sntp_start", "location": "sntp:0x00400de0 sym.sntp_start", "description": "A stack buffer overflow vulnerability was discovered in the sntp_start function of the sntp program. This function handles SNTP network communication, using recvfrom to receive packets of up to 128 bytes, but then uses memcpy to copy the data into a stack buffer (auStack_204) of only 40 bytes. An attacker can trigger the overflow by sending a malicious SNTP response packet longer than 40 bytes. The overflow may overwrite other variables on the stack (such as saved registers or local pointers), leading to denial of service or potential code execution. The conditions for triggering the vulnerability include: the device running the sntp client, and the attacker being able to send malicious network packets. If the program runs with root privileges, it may lead to privilege escalation, but since the return address is far from the overflow point (512 bytes), direct exploitation is difficult.", "link_identifiers": ["sys.timesyn", "sys.timezone", "sys.timefixper"], "code_snippet": "// Receives data from recvfrom, length can be up to 0x80 bytes\niVar3 = recvfrom(uVar4, puVar11, 0x80, 0, auStack_c0, puStack_34);\n...\n// memcpy copies data to fixed-size buffer, length iVar3 is attacker-controlled\nmemcpy(puStack_3c, &uStack_140, iVar3); // puStack_3c points to auStack_204 (40 bytes)", "risk_score": 5.5, "confidence": 7.0, "notes": "The overflow exists but the possibility of directly overwriting the return address is low due to the 512-byte distance. Further testing of the stack layout and exploit feasibility is recommended. The program may run with root privileges, but the attacker must already be logged in and able to send network packets. Related functions: sntp_start is called in main, depends on NVRAM configuration.", "file_path": "bin/sntp"}
{"name": "CSRF-SystemToolFunctions", "location": "system_tool.js: functions submitSystemReboot (approx. line 70), submitSystemPassword (approx. line 100), submitSystemRestore (approx. line 50), etc.", "description": "The JavaScript code handles critical system operations (e.g., reboot, password change, configuration backup/restore) without CSRF protection. An attacker can craft a malicious web page that, when visited by a logged-in user, triggers unauthorized requests to server endpoints. For example, the submitSystemReboot function sends a POST request to \"/goform/SysToolReboot\" with data \"reboot\" via AJAX, lacking CSRF tokens. This could lead to denial of service (via reboot) or privilege escalation (via password change) if the user has permissions. Trigger condition: User visits a malicious page while authenticated. Constraints: Requires user interaction and authentication; no client-side or evident server-side CSRF checks. Potential attack: Attacker creates a page with JavaScript that sends forged requests to critical endpoints.", "link_identifiers": ["/goform/SysToolReboot", "system_reboot.asp", "system_password.asp", "system_backup.asp", "system_restore.asp"], "code_snippet": "From submitSystemReboot: $.ajax({ type : \"POST\", url : \"/goform/SysToolReboot\", data : \"reboot\", success : function (msg) {} });", "risk_score": 7.0, "confidence": 8.0, "notes": "This finding is based on client-side code analysis; server-side verification is recommended to confirm the absence of CSRF protection on endpoints. Additional analysis of server-side components (e.g., \"/goform\" handlers) is suggested to validate exploitability. No other exploitable vulnerabilities with full attack chains were identified in this file.", "file_path": "webroot/js/system_tool.js"}
{"name": "command-injection-do_script_run", "location": "dhcps:0x0040b06c sym.create_helper (Function call chain of do_script_run)", "description": "In the do_script_run function (via create_helper), there is a command injection vulnerability. User-controlled DHCP packet data (such as hostname, client identifier) is passed to the execl function to execute scripts, lacking input validation and filtering. An attacker can construct a malicious DHCP packet, embedding shell metacharacters or commands in the fields. When dnsmasq processes a DHCP event (such as lease assignment), it triggers script execution, leading to arbitrary commands running with the dnsmasq process privileges (typically root). Trigger condition: The attacker sends a specially crafted DHCP request packet; Exploitation method: Gain shell access or execute privileged operations by injecting commands. The vulnerability provides a complete attack chain from network input to command execution.", "link_identifiers": ["DHCP Packet Network Interface", "Environment Variables: DNSMASQ_CLIENT_ID, DNSMASQ_SUPPLIED_HOSTNAME, etc.", "IPC Socket Path: Not directly identified, but communicated via DHCP", "Custom Shared Function Symbol: execl"], "code_snippet": "Key snippet extracted from decompiled code:\n0x0040b06c      lw t9, -sym.imp.execl(gp)   ; Load execl function\n0x0040b070      move a0, s1                 ; Parameter1: Script path\n0x0040b074      move a1, s2                 ; Parameter2: User-controlled data (e.g., hostname)\n0x0040b078      move a3, s0                 ; Other parameters\n0x0040b07c      sw v0, (var_10h)           ; Store variable\n0x0040b084      jalr t9                     ; Call execl, execute script\nUser data is passed via parameters and used for command execution without validation.", "risk_score": 8.5, "confidence": 9.0, "notes": "Evidence is based on decompilation and function call tracing, showing complete data flow: DHCP packet → Global data structure → execl call. The vulnerability is highly exploitable because dnsmasq often runs as root, allowing privilege escalation. It is recommended to verify dnsmasq process privileges and script execution context. Buffer overflow vulnerabilities in other functions (such as dhcp_packet) may assist the attack but do not constitute an independent complete chain.", "file_path": "bin/dhcps"}
{"name": "Heap-Overflow-Process_upnphttp", "location": "miniupnpd:0x004054fc sym.Process_upnphttp", "description": "A heap buffer overflow vulnerability exists in the Process_upnphttp function due to an integer overflow in the realloc size calculation. When processing HTTP requests, the function uses param_1[8] (total read data size) to dynamically adjust the buffer size. If an attacker sends an HTTP request with the Content-Length header set to 4294967295 (the uint32_t maximum value) and sends data in chunks until param_1[8] approaches this value, a subsequent recv call causes iVar1 + param_1[8] to wrap around to a smaller value in realloc, resulting in an allocation of an insufficiently small buffer. A subsequent memcpy operation using the large param_1[8] offset copies data outside the buffer, causing heap memory corruption. Trigger conditions include: 1) The attacker possesses valid login credentials and is connected to the device; 2) Sending a malicious UPnP HTTP request with Content-Length set to 4294967295; 3) Sending data in chunks so that the total read size reaches 4294967295; 4) Triggering the integer overflow and heap overflow on the next recv. Potential exploitation methods include remote code execution (by overwriting heap metadata or function pointers) or denial of service. Constraints of the vulnerability include the need to send approximately 4GB of data, which is feasible in persistent attacks or controlled environments.", "link_identifiers": ["Content-Length HTTP header", "UPnP HTTP request processing", "HTTP_socket"], "code_snippet": "// Key snippet from the decompiled code of Process_upnphttp (state 1 processing)\niVar1 = (**(iVar13 + -0x7c78))(*param_1, auStack_830, 0x800, 0); // recv call, reading data\nif (-1 < iVar1) {\n    if (iVar1 != 0) {\n        iVar2 = (**(iVar13 + -0x7e30))(param_1[7], iVar1 + param_1[8]); // realloc call, size calculation is iVar1 + param_1[8]\n        pcVar12 = *(iVar13 + -0x7ce8); // memcpy function pointer\n        param_1[7] = iVar2;\n        (*pcVar12)(iVar2 + param_1[8], auStack_830, iVar1); // memcpy operation, target address is iVar2 + param_1[8]\n        iVar2 = param_1[8];\n        param_1[8] = iVar1 + iVar2; // Update total read size param_1[8]\n        if ((iVar1 + iVar2) - param_1[10] < param_1[9]) { // Check if the request body is complete\n            return;\n        }\n        // Other processing logic\n    }\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "This vulnerability requires the attacker to send a large amount of data (approximately 4GB) to trigger the integer overflow, which may cause denial of service on resource-constrained devices, but can also be used for code execution. Further analysis of downstream functions (such as ExecuteSoapAction) may reveal additional attack vectors. It is recommended to verify the feasibility of actual exploitation, including heap layout and exploit payload development. The function uses indirect calls (via iVar13 offsets), which may correspond to library functions such as recv, realloc, and memcpy.", "file_path": "bin/miniupnpd"}
{"name": "XSS-initList", "location": "log_setting.js initList function", "description": "In the `initList` function, the log server IP and port values parsed from `reqStr` are directly inserted into HTML without escaping, leading to an XSS vulnerability. When the page loads, if `reqStr` contains malicious JavaScript code, it will be executed in the user's browser. Trigger conditions include: the attacker can control the content of `reqStr` (for example, by adding or modifying log entries), and the user visits the log settings page. Potential attacks include stealing session cookies, performing arbitrary actions, or privilege escalation. The constraint is that `reqStr` must contain malicious scripts, and the attacker must be able to set it through other interfaces (such as `log_addsetting.asp`).", "link_identifiers": ["reqStr", "log_setting.asp", "log_addsetting.asp"], "code_snippet": "for (var i = 0; i < itms.length; i++) { var cl = itms[i].split(';'); strtmp += '<td>' + cl[0] + '</td>'; strtmp += '<td>' + cl[1] + '</td>'; }", "risk_score": 7.0, "confidence": 6.0, "notes": "Further analysis of `log_addsetting.asp` or other related files is needed to confirm how the attacker can control `reqStr`. It is recommended to trace the data flow from the input point to the output point to verify exploitability.", "file_path": "webroot/js/log_setting.js"}
{"name": "stack-buffer-overflow-wlconf-start", "location": "bin/wlconf:0x00401b24 (strncpy), bin/wlconf:0x00401cb0 (strcpy), bin/wlconf:0x00401fbc (strncpy), bin/wlconf:0x00402094 (strncpy) in sym.wlconf_start", "description": "In the sym.wlconf_start function of the 'wlconf' file, multiple stack buffer overflow vulnerabilities were discovered, involving the command line argument argv[1] (interface name). Tainted data propagates from the command line argument to unsafe string operations:\n- Using strncpy to copy to a 255-byte buffer while specifying a size of 256 bytes, causing an off-by-one overflow.\n- Using strcpy to copy to a 100-byte buffer without size restrictions, easily causing an overflow.\n- Using strncpy to copy to a 79-byte buffer while specifying a size of 80 bytes, causing an off-by-one overflow.\nTrigger condition: An attacker executes 'wlconf <ifname> up|down' via the command line and provides a maliciously long interface name (length exceeding the target buffer size). Constraint: The parameter must be passed via the command line, and its length needs to be precisely calculated to overwrite the return address or critical variables. Potential attack methods: The overflow can overwrite the return address or local variables on the stack, potentially leading to arbitrary code execution (e.g., shellcode injection) or denial of service (crash). The relevant code logic lacks boundary checks before string copying and involves indirect function calls (e.g., wl_iovar_get), which may increase exploitation complexity but does not completely prevent exploitation.", "link_identifiers": ["argv[1]", "acStack_258", "auStack_3bc", "acStack_40c", "strncpy", "strcpy", "wl_iovar_get"], "code_snippet": "// Example snippet based on decompiled code (showing unsafe operations)\n// At 0x00401b24: strncpy(acStack_258, argv[1], 0x100); // acStack_258 size is 255 bytes, off-by-one overflow\n// At 0x00401cb0: strcpy(auStack_3bc, argv[1]); // auStack_3bc size is 100 bytes, no size restriction\n// At 0x00401fbc: strncpy(acStack_40c, argv[1], 0x50); // acStack_40c size is 79 bytes, off-by-one overflow\n// At 0x00402094: strncpy(acStack_40c, argv[1], 0x50); // Repeated operation", "risk_score": 6.5, "confidence": 7.0, "notes": "The vulnerability exists and the attack chain is complete: entry point (command line argument) → data flow (unverified copy) → dangerous operation (buffer overflow). Exploitability requires dynamic validation (e.g., testing for crashes or control flow overwrites), but the evidence supports a theoretical attack path. Non-root users can execute wlconf, but it lacks setuid permissions, so exploitation might be limited to the current user's privileges unless combined with other vulnerabilities for privilege escalation. It is recommended to subsequently analyze other binaries (e.g., httpd) to find more direct attack chains or privilege escalation opportunities.", "file_path": "bin/wlconf"}
{"name": "Command-Injection-sym.sendJoinLeaveUpstream", "location": "igmpproxy:0x40468c (sym.sendJoinLeaveUpstream) and 0x404758 (sym.sendJoinLeaveUpstream) for system calls; data flow originates from IGMP input handlers like sym.acceptIgmp at 0x406164", "description": "A command injection vulnerability exists in igmpproxy's sym.sendJoinLeaveUpstream function, where IGMP group addresses from untrusted network inputs are used unsanitized in system() calls. Attackers with valid login credentials (non-root) can send crafted IGMP messages (e.g., Join/Leave reports) that inject malicious commands into iptables rules executed via system(). The vulnerability is triggered when IGMP messages are processed, leading to routes being added or removed, and the group address is incorporated into commands like 'iptables -t filter -I FORWARD -i %s -d %s -j ACCEPT 2>/dev/null\n' without validation. This allows arbitrary command execution with the privileges of the igmpproxy process (typically root), potentially leading to full device compromise. Constraints include the need for IGMP message handling to be active, but no additional boundary checks are present. Potential attacks involve crafting IGMP packets with malicious group addresses that include shell metacharacters to execute arbitrary commands.", "link_identifiers": ["IGMP group address", "sym.imp.system", "sym.sendJoinLeaveUpstream", "sym.insertRoute", "sym.removeRoute", "sym.setRouteLastMemberMode", "sym.clearAllRoutes", "sym.acceptGroupReport", "sym.acceptIgmp", "sym.inetFmt", "sym.imp.sprintf"], "code_snippet": "From sym.sendJoinLeaveUpstream decompilation and disassembly:\n  0x00404644: lw a0, 8(s4)              # Load tainted group address from route structure\n  0x00404654: lw t9, -sym.inetFmt(gp); jalr t9  # Format the address\n  0x00404668: lw t9, -sym.imp.sprintf(gp); jalr t9   # Build iptables command string with formatted address\n  0x0040468c: lw t9, -sym.imp.system(gp); jalr t9    # Execute the command via system call\n  The command string is constructed using sprintf with a fixed format, but the group address is inserted without sanitization.", "risk_score": 9.0, "confidence": 9.0, "notes": "The vulnerability is exploitable via multiple paths (e.g., through sym.insertRoute, sym.removeRoute), all converging on sym.sendJoinLeaveUpstream. Attack requires IGMP messaging capability, which is accessible to authenticated users on the network. Further analysis could verify exploitability in a lab environment, and patches should sanitize all inputs used in command construction. No other exploitable vulnerabilities were found in sprintf, strncpy, or other functions analyzed.", "file_path": "sbin/igmpproxy"}
{"name": "StackBufferOverflow-fcn.00400fb4", "location": "igs:0x00400ff8 fcn.00400fb4", "description": "In the fcn.00400fb4 function of the 'igs' file, there exists a stack buffer overflow vulnerability. This function uses strcpy to copy user-provided command line arguments (such as <bridge>) into a fixed-size stack buffer (size 0x420 bytes), without performing any boundary checks. An attacker can trigger the overflow by executing the 'igs' command and providing an overly long argument (exceeding 0x420 bytes), overwriting the return address on the stack (located at offset 0x428), which may lead to arbitrary code execution. Trigger condition: The attacker possesses valid login credentials (non-root user) and executes a command such as 'igs add bridge <long_string>'. Potential attack methods include control flow hijacking to escalate privileges or execute malicious code. The relevant code logic involves command line argument parsing, data being passed to fcn.00400fb4, and the dangerous strcpy operation.", "link_identifiers": ["Command line argument <bridge>", "Function fcn.00400fb4", "Function sym.igs_cfg_request_send", "NVRAM/Environment variable: None", "File path: /sbin/igs", "IPC socket: netlink socket (in sym.igs_cfg_request_send)"], "code_snippet": "From Radare2 decompilation and assembly code:\n- In fcn.00400fb4:\n  0x00400fe0: addiu a2, zero, 0x420       ; Buffer size\n  0x00400ff4: lw a1, 0xc(s1)             ; Load input from argument\n  0x00400ff8: lw t9, -sym.imp.strcpy(gp) ; Load strcpy address\n  0x00401000: jalr t9                    ; Call strcpy, copy input to stack buffer\nStack buffer auStack_430 starts at sp+0x18, return address stored at sp+0x440.", "risk_score": 8.0, "confidence": 8.5, "notes": "Vulnerability verified based on code evidence, but exploitation not tested in a real environment; Offset calculation (0x428) comes from assembly analysis, further verification is recommended to confirm the precise overflow point; Related files include the main function (handles command line) and sym.igs_cfg_request_send (network operations); Future analysis directions: Test specific argument length to trigger crash, check the impact of ASLR and other mitigation measures.", "file_path": "usr/sbin/igs"}
{"name": "BufferOverflow-wl-command-functions", "location": "File:wl Address:0x426540 Function:sym.wlu_var_setbuf; File:wl Address:0x40d1d0 Function:sym.wlu_var_getbuf_med", "description": "Multiple buffer overflow vulnerabilities were discovered in the 'wl' binary, originating from the use of the strcpy function without bounds checking. Attackers can provide overly long strings through command-line parameters (such as 'wl set' or 'wl nvset' commands) to trigger stack or heap buffer overflows. Specifically, the sym.wlu_var_setbuf function uses a fixed-size 0x2000-byte buffer but does not validate the length of input parameters param_2 and param_3; similarly, sym.wlu_var_getbuf_med uses a 0x600-byte buffer. Since the attacker already possesses login credentials and can execute these commands, the overflow could overwrite the return address or critical data structures, leading to arbitrary code execution. Vulnerability trigger conditions include: the user providing input parameters that exceed the buffer size, and the command processing flow lacking proper filtering.", "link_identifiers": ["param_2", "param_3", "command-line parameters", "wl set", "wl nvset", "NVRAM variables"], "code_snippet": "// sym.wlu_var_setbuf partial code\nint32_t iVar2 = *(*(iVar3 + -0x7fe4) + 0x6014);\n(**(iVar3 + -0x7edc))(iVar2, 0, 0x2000); // memset buffer 0x2000 bytes\n(**(iVar3 + -0x7d84))(iVar2, param_2); // strcpy(param_2 to buffer)\nif (param_4 != 0) {\n    (**(iVar3 + -0x7df4))(iVar2 + iVar1 + 1, param_3, param_4); // strcpy(param_3 to buffer offset)\n}\n// sym.wlu_var_getbuf_med partial code\nint32_t iVar2 = *(*(iVar4 + -0x7fe4) + 0x6014);\n(**(iVar4 + -0x7edc))(iVar2, 0, 0x600); // memset buffer 0x600 bytes\n(**(iVar4 + -0x7d84))(iVar2, param_2); // strcpy(param_2 to buffer)", "risk_score": 8.5, "confidence": 7.5, "notes": "Evidence is based on strcpy calls and fixed buffer sizes in the decompiled code. Attack chain is complete: user input via command line -> process_args dispatch -> command functions (e.g., wl set) -> vulnerable functions (e.g., wlu_var_setbuf) -> strcpy overflow. It is recommended to further validate the input paths and exploit feasibility of specific commands, such as testing the 'wl set' command with long parameters. Related functions include main, process_args, and command processing functions. Since the binary is stripped, dynamic analysis or testing may require an actual device environment.", "file_path": "usr/sbin/wl"}
{"name": "BufferOverflow-fcn.004013b4", "location": "emf:0x00401400 fcn.004013b4", "description": "The function fcn.004013b4 contains a buffer overflow vulnerability due to the unsafe use of strcpy to copy user-input from argv[2] (e.g., the <bridge> parameter) into a fixed-size stack buffer of 0x420 bytes without bounds checking. The overflow occurs when the emf command is executed with subcommands like 'start', 'stop', 'status', etc., and the <bridge> parameter (argv[2]) is provided with a length exceeding 0x420 bytes. This can be triggered by a non-root user with command-line access. An attacker can craft a long string to overwrite the return address on the stack, potentially leading to arbitrary code execution in the context of the user running the binary. The attack chain is complete and verifiable: from input (argv[2]) to overflow via strcpy, with no size checks.", "link_identifiers": ["argv[2]", "bridge parameter", "emf command", "strcpy"], "code_snippet": "From disassembly:\n- 0x004013f4: lw a1, 8(s1)    # Load argv[2] into a1\n- 0x004013f8: lw t9, -sym.imp.strcpy # Load strcpy function\n- 0x00401400: jalr t9          # Call strcpy(s0, a1), where s0 is the buffer", "risk_score": 6.0, "confidence": 7.0, "notes": "The binary has world-writable permissions (-rwxrwxrwx), which could allow unauthorized modification but is separate from this code vulnerability. Further analysis could involve testing exploitability on a target system or examining other functions for additional issues. No other exploitable vulnerabilities were identified in the main or emf_cfg_request_send functions.", "file_path": "usr/sbin/emf"}
{"name": "buffer-overflow-parse_url", "location": "ufilter:0x00404350 sym.parse_url (instruction address: 0x004043e4 for strcpy, 0x00404448 for memcpy)", "description": "In the parse_url function, when processing user-provided URL data (from set_url's param_2[2]), there is a lack of bounds checking, leading to a stack buffer overflow. Specific behavior: The function uses strchr to find a comma delimiter, then based on the result calls memcpy or strcpy to copy data to a fixed-size stack buffer (64 bytes). An attacker can overflow the buffer by providing an overly long string without a comma (triggering the strcpy path) or a string containing a comma (controlling the memcpy length). Trigger condition: The attacker is already logged in and invokes set_url related functionality (e.g., via the command line tool), providing malicious URL data. Potential exploitation methods: Overwrite the return address or critical variables to achieve code execution or privilege escalation.", "link_identifiers": ["set_url", "parse_url", "param_2[2]", "memcpy", "strcpy", "main"], "code_snippet": "Key snippets extracted from decompiled code:\n- strcpy path (0x004043e4): lw a1, (var_20h); lw t9, -sym.imp.strcpy(gp); jalr t9; // Tainted data in a1, copied directly to buffer\n- memcpy path (0x00404448): lw a1, (var_20h); move a2, v0; lw t9, -sym.imp.memcpy(gp); jalr t9; // Tainted data in a1 and a2 (length controlled by input)\n- Buffer size: Fixed 64 bytes, but input length is not checked", "risk_score": 8.5, "confidence": 8.5, "notes": "The vulnerability is passed in via the set_url function with user input, forming a complete attack chain. The attacker is most likely to trigger this vulnerability by invoking ufilter related functionality (such as URL filter settings) via the command line tool. It is recommended to further validate the feasibility of overflow exploitation, for example, by testing the buffer layout and jump addresses. Associated file: ufilter (main binary).", "file_path": "usr/sbin/ufilter"}
