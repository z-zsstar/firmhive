{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（cgi-bin）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 'cgi-bin' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 助手可以与文件交互以执行特定的文件分析任务。使用场景：当你需要单步任务的分析结果后再决定下一个分析任务时。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n- Name: ParallelTaskDelegator\n  Description: 每个助手可以与文件交互，并行执行多个文件分析子任务。使用场景：1. 当复杂任务需要分解为多个独立的子任务时。2. 子任务之间没有严格的执行顺序依赖。3. 建议对大规模和复杂任务并行执行多个子任务，提高分析效率。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"description\": \"要执行的子任务的详细描述。每个任务描述都是独立的，应指定分析对象。\"\n      },\n      \"description\": \"要分配给子代理并行执行的独立任务描述列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前任务：\n专注于分析文件 'jScrollPane.js' 的内容，寻找可利用的信息和线索。"}
{"role": "assistant", "content": "{\n  \"thought\": \"当前任务是分析文件 'jScrollPane.js' 的内容，以寻找可利用的信息和线索。这是一个 JavaScript 文件，可能涉及前端交互，我需要首先读取其内容来识别潜在的输入点、数据流和危险操作。我将使用 execute_shell 工具运行 'cat jScrollPane.js' 命令来获取文件内容，然后基于证据进行分析。\",\n  \"action\": \"execute_shell\",\n  \"action_input\": {\n    \"command\": \"cat jScrollPane.js\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：execute_shell\n参数：{\"command\": \"cat jScrollPane.js\"}\n结果：\n 退出代码：0\n标准输出：\n/*!\n * jScrollPane - v2.0.0beta12 - 2012-09-27\n * http://jscrollpane.kelvinluck.com/\n *\n * Copyright (c) 2010 Kelvin Luck\n * Dual licensed under the MIT or GPL licenses.\n */\n\n// Script: jScrollPane - cross browser customisable scrollbars\n//\n// *Version: 2.0.0beta12, Last updated: 2012-09-27*\n//\n// Project Home - http://jscrollpane.kelvinluck.com/\n// GitHub       - http://github.com/vitch/jScrollPane\n// Source       - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.js\n// (Minified)   - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.min.js\n//\n// About: License\n//\n// Copyright (c) 2012 Kelvin Luck\n// Dual licensed under the MIT or GPL Version 2 licenses.\n// http://jscrollpane.kelvinluck.com/MIT-LICENSE.txt\n// http://jscrollpane.kelvinluck.com/GPL-LICENSE.txt\n//\n// About: Examples\n//\n// All examples and demos are available through the jScrollPane example site at:\n// http://jscrollpane.kelvinluck.com/\n//\n// About: Support and Testing\n//\n// This plugin is tested on the browsers below and has been found to work reliably on them. If you run\n// into a problem on one of the supported browsers then please visit the support section on the jScrollPane\n// website (http://jscrollpane.kelvinluck.com/) for more information on getting support. You are also\n// welcome to fork the project on GitHub if you can contribute a fix for a given issue. \n//\n// jQuery Versions - tested in 1.4.2+ - reported to work in 1.3.x\n// Browsers Tested - Firefox 3.6.8, Safari 5, Opera 10.6, Chrome 5.0, IE 6, 7, 8\n//\n// About: Release History\n//\n// 2.0.0beta12 - (2012-09-27) fix for jQuery 1.8+\n// 2.0.0beta11 - (2012-05-14)\n// 2.0.0beta10 - (2011-04-17) cleaner required size calculation, improved keyboard support, stickToBottom/Left, other small fixes\n// 2.0.0beta9 - (2011-01-31) new API methods, bug fixes and correct keyboard support for FF/OSX\n// 2.0.0beta8 - (2011-01-29) touchscreen support, improved keyboard support\n// 2.0.0beta7 - (2011-01-23) scroll speed consistent (thanks Aivo Paas)\n// 2.0.0beta6 - (2010-12-07) scrollToElement horizontal support\n// 2.0.0beta5 - (2010-10-18) jQuery 1.4.3 support, various bug fixes\n// 2.0.0beta4 - (2010-09-17) clickOnTrack support, bug fixes\n// 2.0.0beta3 - (2010-08-27) Horizontal mousewheel, mwheelIntent, keyboard support, bug fixes\n// 2.0.0beta2 - (2010-08-21) Bug fixes\n// 2.0.0beta1 - (2010-08-17) Rewrite to follow modern best practices and enable horizontal scrolling, initially hidden\n//\t\t\t\t\t\t\t elements and dynamically sized elements.\n// 1.x - (2006-12-31 - 2010-07-31) Initial version, hosted at googlecode, deprecated\n\n(function($,window,undefined){\n\n\t$.fn.jScrollPane = function(settings)\n\t{\n\t\t// JScrollPane \"class\" - public methods are available through $('selector').data('jsp')\n\t\tfunction JScrollPane(elem, s)\n\t\t{\n\t\t\tvar settings, jsp = this, pane, paneWidth, paneHeight, container, contentWidth, contentHeight,\n\t\t\t\tpercentInViewH, percentInViewV, isScrollableV, isScrollableH, verticalDrag, dragMaxY,\n\t\t\t\tverticalDragPosition, horizontalDrag, dragMaxX, horizontalDragPosition,\n\t\t\t\tverticalBar, verticalTrack, scrollbarWidth, verticalTrackHeight, verticalDragHeight, arrowUp, arrowDown,\n\t\t\t\thorizontalBar, horizontalTrack, horizontalTrackWidth, horizontalDragWidth, arrowLeft, arrowRight,\n\t\t\t\treinitialiseInterval, originalPadding, originalPaddingTotalWidth, previousContentWidth,\n\t\t\t\twasAtTop = true, wasAtLeft = true, wasAtBottom = false, wasAtRight = false,\n\t\t\t\toriginalElement = elem.clone(false, false).empty(),\n\t\t\t\tmwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';\n\n\t\t\toriginalPadding = elem.css('paddingTop') + ' ' +\n\t\t\t\t\t\t\t\telem.css('paddingRight') + ' ' +\n\t\t\t\t\t\t\t\telem.css('paddingBottom') + ' ' +\n\t\t\t\t\t\t\t\telem.css('paddingLeft');\n\t\t\toriginalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) +\n\t\t\t\t\t\t\t\t\t\t(parseInt(elem.css('paddingRight'), 10) || 0);\n\n\t\t\tfunction initialise(s)\n\t\t\t{\n\n\t\t\t\tvar /*firstChild, lastChild, */isMaintainingPositon, lastContentX, lastContentY,\n\t\t\t\t\t\thasContainingSpaceChanged, originalScrollTop, originalScrollLeft,\n\t\t\t\t\t\tmaintainAtBottom = false, maintainAtRight = false;\n\n\t\t\t\tsettings = s;\n\n\t\t\t\tif (pane === undefined) {\n\t\t\t\t\toriginalScrollTop = elem.scrollTop();\n\t\t\t\t\toriginalScrollLeft = elem.scrollLeft();\n\n\t\t\t\t\telem.css(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\t\t\tpadding: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\t// TODO: Deal with where width/ height is 0 as it probably means the element is hidden and we should\n\t\t\t\t\t// come back to it later and check once it is unhidden...\n\t\t\t\t\tpaneWidth = elem.innerWidth() + originalPaddingTotalWidth;\n\t\t\t\t\tpaneHeight = elem.innerHeight();\n\n\t\t\t\t\telem.width(paneWidth);\n\t\t\t\t\t\n\t\t\t\t\tpane = $('<div class=\"jspPane\" />').css('padding', originalPadding).append(elem.children());\n\t\t\t\t\tcontainer = $('<div class=\"jspContainer\" />')\n\t\t\t\t\t\t.css({\n\t\t\t\t\t\t\t'width': paneWidth + 'px',\n\t\t\t\t\t\t\t'height': paneHeight + 'px'\n\t\t\t\t\t\t}\n\t\t\t\t\t).append(pane).appendTo(elem);\n\n\t\t\t\t\t/*\n\t\t\t\t\t// Move any margins from the first and last children up to the container so they can still\n\t\t\t\t\t// collapse with neighbouring elements as they would before jScrollPane \n\t\t\t\t\tfirstChild = pane.find(':first-child');\n\t\t\t\t\tlastChild = pane.find(':last-child');\n\t\t\t\t\telem.css(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t'margin-top': firstChild.css('margin-top'),\n\t\t\t\t\t\t\t'margin-bottom': lastChild.css('margin-bottom')\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tfirstChild.css('margin-top', 0);\n\t\t\t\t\tlastChild.css('margin-bottom', 0);\n\t\t\t\t\t*/\n\t\t\t\t} else {\n\t\t\t\t\telem.css('width', '');\n\n\t\t\t\t\tmaintainAtBottom = settings.stickToBottom && isCloseToBottom();\n\t\t\t\t\tmaintainAtRight  = settings.stickToRight  && isCloseToRight();\n\n\t\t\t\t\thasContainingSpaceChanged = elem.innerWidth() + originalPaddingTotalWidth != paneWidth || elem.outerHeight() != paneHeight;\n\n\t\t\t\t\tif (hasContainingSpaceChanged) {\n\t\t\t\t\t\tpaneWidth = elem.innerWidth() + originalPaddingTotalWidth;\n\t\t\t\t\t\tpaneHeight = elem.innerHeight();\n\t\t\t\t\t\tcontainer.css({\n\t\t\t\t\t\t\twidth: paneWidth + 'px',\n\t\t\t\t\t\t\theight: paneHeight + 'px'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// If nothing changed since last check...\n\t\t\t\t\tif (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {\n\t\t\t\t\t\telem.width(paneWidth);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpreviousContentWidth = contentWidth;\n\t\t\t\t\t\n\t\t\t\t\tpane.css('width', '');\n\t\t\t\t\telem.width(paneWidth);\n\n\t\t\t\t\tcontainer.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();\n\t\t\t\t}\n\n\t\t\t\tpane.css('overflow', 'auto');\n\t\t\t\tif (s.contentWidth) {\n\t\t\t\t\tcontentWidth = s.contentWidth;\n\t\t\t\t} else {\n\t\t\t\t\tcontentWidth = pane[0].scrollWidth;\n\t\t\t\t}\n\t\t\t\tcontentHeight = pane[0].scrollHeight;\n\t\t\t\tpane.css('overflow', '');\n\n\t\t\t\tpercentInViewH = contentWidth / paneWidth;\n\t\t\t\tpercentInViewV = contentHeight / paneHeight;\n\t\t\t\tisScrollableV = percentInViewV > 1;\n\n\t\t\t\tisScrollableH = percentInViewH > 1;\n\n\t\t\t\t//console.log(paneWidth, paneHeight, contentWidth, contentHeight, percentInViewH, percentInViewV, isScrollableH, isScrollableV);\n\n\t\t\t\tif (!(isScrollableH || isScrollableV)) {\n\t\t\t\t\telem.removeClass('jspScrollable');\n\t\t\t\t\tpane.css({\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: container.width() - originalPaddingTotalWidth\n\t\t\t\t\t});\n\t\t\t\t\tremoveMousewheel();\n\t\t\t\t\tremoveFocusHandler();\n\t\t\t\t\tremoveKeyboardNav();\n\t\t\t\t\tremoveClickOnTrack();\n\t\t\t\t} else {\n\t\t\t\t\telem.addClass('jspScrollable');\n\n\t\t\t\t\tisMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);\n\t\t\t\t\tif (isMaintainingPositon) {\n\t\t\t\t\t\tlastContentX = contentPositionX();\n\t\t\t\t\t\tlastContentY = contentPositionY();\n\t\t\t\t\t}\n\n\t\t\t\t\tinitialiseVerticalScroll();\n\t\t\t\t\tinitialiseHorizontalScroll();\n\t\t\t\t\tresizeScrollbars();\n\n\t\t\t\t\tif (isMaintainingPositon) {\n\t\t\t\t\t\tscrollToX(maintainAtRight  ? (contentWidth  - paneWidth ) : lastContentX, false);\n\t\t\t\t\t\tscrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);\n\t\t\t\t\t}\n\n\t\t\t\t\tinitFocusHandler();\n\t\t\t\t\tinitMousewheel();\n\t\t\t\t\tinitTouch();\n\t\t\t\t\t\n\t\t\t\t\tif (settings.enableKeyboardNavigation) {\n\t\t\t\t\t\tinitKeyboardNav();\n\t\t\t\t\t}\n\t\t\t\t\tif (settings.clickOnTrack) {\n\t\t\t\t\t\tinitClickOnTrack();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tobserveHash();\n\t\t\t\t\tif (settings.hijackInternalLinks) {\n\t\t\t\t\t\thijackInternalLinks();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (settings.autoReinitialise && !reinitialiseInterval) {\n\t\t\t\t\treinitialiseInterval = setInterval(\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinitialise(settings);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsettings.autoReinitialiseDelay\n\t\t\t\t\t);\n\t\t\t\t} else if (!settings.autoReinitialise && reinitialiseInterval) {\n\t\t\t\t\tclearInterval(reinitialiseInterval);\n\t\t\t\t}\n\n\t\t\t\toriginalScrollTop && elem.scrollTop(0) && scrollToY(originalScrollTop, false);\n\t\t\t\toriginalScrollLeft && elem.scrollLeft(0) && scrollToX(originalScrollLeft, false);\n\n\t\t\t\telem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);\n\t\t\t}\n\n\t\t\tfunction initialiseVerticalScroll()\n\t\t\t{\n\t\t\t\tif (isScrollableV) {\n\n\t\t\t\t\tcontainer.append(\n\t\t\t\t\t\t$('<div class=\"jspVerticalBar\" />').append(\n\t\t\t\t\t\t\t$('<div class=\"jspCap jspCapTop\" />'),\n\t\t\t\t\t\t\t$('<div class=\"jspTrack\" />').append(\n\t\t\t\t\t\t\t\t$('<div class=\"jspDrag\" />').append(\n\t\t\t\t\t\t\t\t\t$('<div class=\"jspDragTop\" />'),\n\t\t\t\t\t\t\t\t\t$('<div class=\"jspDragBottom\" />')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t$('<div class=\"jspCap jspCapBottom\" />')\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tverticalBar = container.find('>.jspVerticalBar');\n\t\t\t\t\tverticalTrack = verticalBar.find('>.jspTrack');\n\t\t\t\t\tverticalDrag = verticalTrack.find('>.jspDrag');\n\n\t\t\t\t\tif (settings.showArrows) {\n\t\t\t\t\t\tarrowUp = $('<a class=\"jspArrow jspArrowUp\" />').bind(\n\t\t\t\t\t\t\t'mousedown.jsp', getArrowScroll(0, -1)\n\t\t\t\t\t\t).bind('click.jsp', nil);\n\t\t\t\t\t\tarrowDown = $('<a class=\"jspArrow jspArrowDown\" />').bind(\n\t\t\t\t\t\t\t'mousedown.jsp', getArrowScroll(0, 1)\n\t\t\t\t\t\t).bind('click.jsp', nil);\n\t\t\t\t\t\tif (settings.arrowScrollOnHover) {\n\t\t\t\t\t\t\tarrowUp.bind('mouseover.jsp', getArrowScroll(0, -1, arrowUp));\n\t\t\t\t\t\t\tarrowDown.bind('mouseover.jsp', getArrowScroll(0, 1, arrowDown));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tappendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);\n\t\t\t\t\t}\n\n\t\t\t\t\tverticalTrackHeight = paneHeight;\n\t\t\t\t\tcontainer.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tverticalTrackHeight -= $(this).outerHeight();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\n\t\t\t\t\tverticalDrag.hover(\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tverticalDrag.addClass('jspHover');\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tverticalDrag.removeClass('jspHover');\n\t\t\t\t\t\t}\n\t\t\t\t\t).bind(\n\t\t\t\t\t\t'mousedown.jsp',\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Stop IE from allowing text selection\n\t\t\t\t\t\t\t$('html').bind('dragstart.jsp selectstart.jsp', nil);\n\n\t\t\t\t\t\t\tverticalDrag.addClass('jspActive');\n\n\t\t\t\t\t\t\tvar startY = e.pageY - verticalDrag.position().top;\n\n\t\t\t\t\t\t\t$('html').bind(\n\t\t\t\t\t\t\t\t'mousemove.jsp',\n\t\t\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpositionDragY(e.pageY - startY, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t).bind('mouseup.jsp mouseleave.jsp', cancelDrag);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tsizeVerticalScrollbar();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction sizeVerticalScrollbar()\n\t\t\t{\n\t\t\t\tverticalTrack.height(verticalTrackHeight + 'px');\n\t\t\t\tverticalDragPosition = 0;\n\t\t\t\tscrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();\n\n\t\t\t\t// Make the pane thinner to allow for the vertical scrollbar\n\t\t\t\tpane.width(paneWidth - scrollbarWidth - originalPaddingTotalWidth);\n\n\t\t\t\t// Add margin to the left of the pane if scrollbars are on that side (to position\n\t\t\t\t// the scrollbar on the left or right set it's left or right property in CSS)\n\t\t\t\ttry {\n\t\t\t\t\tif (verticalBar.position().left === 0) {\n\t\t\t\t\t\tpane.css('margin-left', scrollbarWidth + 'px');\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction initialiseHorizontalScroll()\n\t\t\t{\n\t\t\t\tif (isScrollableH) {\n\n\t\t\t\t\tcontainer.append(\n\t\t\t\t\t\t$('<div class=\"jspHorizontalBar\" />').append(\n\t\t\t\t\t\t\t$('<div class=\"jspCap jspCapLeft\" />'),\n\t\t\t\t\t\t\t$('<div class=\"jspTrack\" />').append(\n\t\t\t\t\t\t\t\t$('<div class=\"jspDrag\" />').append(\n\t\t\t\t\t\t\t\t\t$('<div class=\"jspDragLeft\" />'),\n\t\t\t\t\t\t\t\t\t$('<div class=\"jspDragRight\" />')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t$('<div class=\"jspCap jspCapRight\" />')\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\thorizontalBar = container.find('>.jspHorizontalBar');\n\t\t\t\t\thorizontalTrack = horizontalBar.find('>.jspTrack');\n\t\t\t\t\thorizontalDrag = horizontalTrack.find('>.jspDrag');\n\n\t\t\t\t\tif (settings.showArrows) {\n\t\t\t\t\t\tarrowLeft = $('<a class=\"jspArrow jspArrowLeft\" />').bind(\n\t\t\t\t\t\t\t'mousedown.jsp', getArrowScroll(-1, 0)\n\t\t\t\t\t\t).bind('click.jsp', nil);\n\t\t\t\t\t\tarrowRight = $('<a class=\"jspArrow jspArrowRight\" />').bind(\n\t\t\t\t\t\t\t'mousedown.jsp', getArrowScroll(1, 0)\n\t\t\t\t\t\t).bind('click.jsp', nil);\n\t\t\t\t\t\tif (settings.arrowScrollOnHover) {\n\t\t\t\t\t\t\tarrowLeft.bind('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));\n\t\t\t\t\t\t\tarrowRight.bind('mouseover.jsp', getArrowScroll(1, 0, arrowRight));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tappendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);\n\t\t\t\t\t}\n\n\t\t\t\t\thorizontalDrag.hover(\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thorizontalDrag.addClass('jspHover');\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thorizontalDrag.removeClass('jspHover');\n\t\t\t\t\t\t}\n\t\t\t\t\t).bind(\n\t\t\t\t\t\t'mousedown.jsp',\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Stop IE from allowing text selection\n\t\t\t\t\t\t\t$('html').bind('dragstart.jsp selectstart.jsp', nil);\n\n\t\t\t\t\t\t\thorizontalDrag.addClass('jspActive');\n\n\t\t\t\t\t\t\tvar startX = e.pageX - horizontalDrag.position().left;\n\n\t\t\t\t\t\t\t$('html').bind(\n\t\t\t\t\t\t\t\t'mousemove.jsp',\n\t\t\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpositionDragX(e.pageX - startX, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t).bind('mouseup.jsp mouseleave.jsp', cancelDrag);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\thorizontalTrackWidth = container.innerWidth();\n\t\t\t\t\tsizeHorizontalScrollbar();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction sizeHorizontalScrollbar()\n\t\t\t{\n\t\t\t\tcontainer.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\thorizontalTrackWidth -= $(this).outerWidth();\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\thorizontalTrack.width(horizontalTrackWidth + 'px');\n\t\t\t\thorizontalDragPosition = 0;\n\t\t\t}\n\n\t\t\tfunction resizeScrollbars()\n\t\t\t{\n\t\t\t\tif (isScrollableH && isScrollableV) {\n\t\t\t\t\tvar horizontalTrackHeight = horizontalTrack.outerHeight(),\n\t\t\t\t\t\tverticalTrackWidth = verticalTrack.outerWidth();\n\t\t\t\t\tverticalTrackHeight -= horizontalTrackHeight;\n\t\t\t\t\t$(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(\n\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thorizontalTrackWidth += $(this).outerWidth();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\thorizontalTrackWidth -= verticalTrackWidth;\n\t\t\t\t\tpaneHeight -= verticalTrackWidth;\n\t\t\t\t\tpaneWidth -= horizontalTrackHeight;\n\t\t\t\t\thorizontalTrack.parent().append(\n\t\t\t\t\t\t$('<div class=\"jspCorner\" />').css('width', horizontalTrackHeight + 'px')\n\t\t\t\t\t);\n\t\t\t\t\tsizeVerticalScrollbar();\n\t\t\t\t\tsizeHorizontalScrollbar();\n\t\t\t\t}\n\t\t\t\t// reflow content\n\t\t\t\tif (isScrollableH) {\n\t\t\t\t\tpane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');\n\t\t\t\t}\n\t\t\t\tcontentHeight = pane.outerHeight();\n\t\t\t\tpercentInViewV = contentHeight / paneHeight;\n\n\t\t\t\tif (isScrollableH) {\n\t\t\t\t\thorizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);\n\t\t\t\t\tif (horizontalDragWidth > settings.horizontalDragMaxWidth) {\n\t\t\t\t\t\thorizontalDragWidth = settings.horizontalDragMaxWidth;\n\t\t\t\t\t} else if (horizontalDragWidth < settings.horizontalDragMinWidth) {\n\t\t\t\t\t\thorizontalDragWidth = settings.horizontalDragMinWidth;\n\t\t\t\t\t}\n\t\t\t\t\thorizontalDrag.width(horizontalDragWidth + 'px');\n\t\t\t\t\tdragMaxX = horizontalTrackWidth - horizontalDragWidth;\n\t\t\t\t\t_positionDragX(horizontalDragPosition); // To update the state for the arrow buttons\n\t\t\t\t}\n\t\t\t\tif (isScrollableV) {\n\t\t\t\t\tverticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);\n\t\t\t\t\tif (verticalDragHeight > settings.verticalDragMaxHeight) {\n\t\t\t\t\t\tverticalDragHeight = settings.verticalDragMaxHeight;\n\t\t\t\t\t} else if (verticalDragHeight < settings.verticalDragMinHeight) {\n\t\t\t\t\t\tverticalDragHeight = settings.verticalDragMinHeight;\n\t\t\t\t\t}\n\t\t\t\t\tverticalDrag.height(verticalDragHeight + 'px');\n\t\t\t\t\tdragMaxY = verticalTrackHeight - verticalDragHeight;\n\t\t\t\t\t_positionDragY(verticalDragPosition); // To update the state for the arrow buttons\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction appendArrows(ele, p, a1, a2)\n\t\t\t{\n\t\t\t\tvar p1 = \"before\", p2 = \"after\", aTemp;\n\t\t\t\t\n\t\t\t\t// Sniff for mac... Is there a better way to determine whether the arrows would naturally appear\n\t\t\t\t// at the top or the bottom of the bar?\n\t\t\t\tif (p == \"os\") {\n\t\t\t\t\tp = /Mac/.test(navigator.platform) ? \"after\" : \"split\";\n\t\t\t\t}\n\t\t\t\tif (p == p1) {\n\t\t\t\t\tp2 = p;\n\t\t\t\t} else if (p == p2) {\n\t\t\t\t\tp1 = p;\n\t\t\t\t\taTemp = a1;\n\t\t\t\t\ta1 = a2;\n\t\t\t\t\ta2 = aTemp;\n\t\t\t\t}\n\n\t\t\t\tele[p1](a1)[p2](a2);\n\t\t\t}\n\n\t\t\tfunction getArrowScroll(dirX, dirY, ele)\n\t\t\t{\n\t\t\t\treturn function()\n\t\t\t\t{\n\t\t\t\t\tarrowScroll(dirX, dirY, this, ele);\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction arrowScroll(dirX, dirY, arrow, ele)\n\t\t\t{\n\t\t\t\tarrow = $(arrow).addClass('jspActive');\n\n\t\t\t\tvar eve,\n\t\t\t\t\tscrollTimeout,\n\t\t\t\t\tisFirst = true,\n\t\t\t\t\tdoScroll = function()\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dirX !== 0) {\n\t\t\t\t\t\t\tjsp.scrollByX(dirX * settings.arrowButtonSpeed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dirY !== 0) {\n\t\t\t\t\t\t\tjsp.scrollByY(dirY * settings.arrowButtonSpeed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t};\n\n\t\t\t\tdoScroll();\n\n\t\t\t\teve = ele ? 'mouseout.jsp' : 'mouseup.jsp';\n\t\t\t\tele = ele || $('html');\n\t\t\t\tele.bind(\n\t\t\t\t\teve,\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\tarrow.removeClass('jspActive');\n\t\t\t\t\t\tscrollTimeout && clearTimeout(scrollTimeout);\n\t\t\t\t\t\tscrollTimeout = null;\n\t\t\t\t\t\tele.unbind(eve);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction initClickOnTrack()\n\t\t\t{\n\t\t\t\tremoveClickOnTrack();\n\t\t\t\tif (isScrollableV) {\n\t\t\t\t\tverticalTrack.bind(\n\t\t\t\t\t\t'mousedown.jsp',\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {\n\t\t\t\t\t\t\t\tvar clickedTrack = $(this),\n\t\t\t\t\t\t\t\t\toffset = clickedTrack.offset(),\n\t\t\t\t\t\t\t\t\tdirection = e.pageY - offset.top - verticalDragPosition,\n\t\t\t\t\t\t\t\t\tscrollTimeout,\n\t\t\t\t\t\t\t\t\tisFirst = true,\n\t\t\t\t\t\t\t\t\tdoScroll = function()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar offset = clickedTrack.offset(),\n\t\t\t\t\t\t\t\t\t\t\tpos = e.pageY - offset.top - verticalDragHeight / 2,\n\t\t\t\t\t\t\t\t\t\t\tcontentDragY = paneHeight * settings.scrollPagePercent,\n\t\t\t\t\t\t\t\t\t\t\tdragY = dragMaxY * contentDragY / (contentHeight - paneHeight);\n\t\t\t\t\t\t\t\t\t\tif (direction < 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (verticalDragPosition - dragY > pos) {\n\t\t\t\t\t\t\t\t\t\t\t\tjsp.scrollByY(-contentDragY);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpositionDragY(pos);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (direction > 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (verticalDragPosition + dragY < pos) {\n\t\t\t\t\t\t\t\t\t\t\t\tjsp.scrollByY(contentDragY);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpositionDragY(pos);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcancelClick();\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tscrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);\n\t\t\t\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcancelClick = function()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tscrollTimeout && clearTimeout(scrollTimeout);\n\t\t\t\t\t\t\t\t\t\tscrollTimeout = null;\n\t\t\t\t\t\t\t\t\t\t$(document).unbind('mouseup.jsp', cancelClick);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdoScroll();\n\t\t\t\t\t\t\t\t$(document).bind('mouseup.jsp', cancelClick);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isScrollableH) {\n\t\t\t\t\thorizontalTrack.bind(\n\t\t\t\t\t\t'mousedown.jsp',\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {\n\t\t\t\t\t\t\t\tvar clickedTrack = $(this),\n\t\t\t\t\t\t\t\t\toffset = clickedTrack.offset(),\n\t\t\t\t\t\t\t\t\tdirection = e.pageX - offset.left - horizontalDragPosition,\n\t\t\t\t\t\t\t\t\tscrollTimeout,\n\t\t\t\t\t\t\t\t\tisFirst = true,\n\t\t\t\t\t\t\t\t\tdoScroll = function()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar offset = clickedTrack.offset(),\n\t\t\t\t\t\t\t\t\t\t\tpos = e.pageX - offset.left - horizontalDragWidth / 2,\n\t\t\t\t\t\t\t\t\t\t\tcontentDragX = paneWidth * settings.scrollPagePercent,\n\t\t\t\t\t\t\t\t\t\t\tdragX = dragMaxX * contentDragX / (contentWidth - paneWidth);\n\t\t\t\t\t\t\t\t\t\tif (direction < 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (horizontalDragPosition - dragX > pos) {\n\t\t\t\t\t\t\t\t\t\t\t\tjsp.scrollByX(-contentDragX);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpositionDragX(pos);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (direction > 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (horizontalDragPosition + dragX < pos) {\n\t\t\t\t\t\t\t\t\t\t\t\tjsp.scrollByX(contentDragX);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpositionDragX(pos);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcancelClick();\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tscrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);\n\t\t\t\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcancelClick = function()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tscrollTimeout && clearTimeout(scrollTimeout);\n\t\t\t\t\t\t\t\t\t\tscrollTimeout = null;\n\t\t\t\t\t\t\t\t\t\t$(document).unbind('mouseup.jsp', cancelClick);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdoScroll();\n\t\t\t\t\t\t\t\t$(document).bind('mouseup.jsp', cancelClick);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction removeClickOnTrack()\n\t\t\t{\n\t\t\t\tif (horizontalTrack) {\n\t\t\t\t\thorizontalTrack.unbind('mousedown.jsp');\n\t\t\t\t}\n\t\t\t\tif (verticalTrack) {\n\t\t\t\t\tverticalTrack.unbind('mousedown.jsp');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cancelDrag()\n\t\t\t{\n\t\t\t\t$('html').unbind('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');\n\n\t\t\t\tif (verticalDrag) {\n\t\t\t\t\tverticalDrag.removeClass('jspActive');\n\t\t\t\t}\n\t\t\t\tif (horizontalDrag) {\n\t\t\t\t\thorizontalDrag.removeClass('jspActive');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction positionDragY(destY, animate)\n\t\t\t{\n\t\t\t\tif (!isScrollableV) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (destY < 0) {\n\t\t\t\t\tdestY = 0;\n\t\t\t\t} else if (destY > dragMaxY) {\n\t\t\t\t\tdestY = dragMaxY;\n\t\t\t\t}\n\n\t\t\t\t// can't just check if(animate) because false is a valid value that could be passed in...\n\t\t\t\tif (animate === undefined) {\n\t\t\t\t\tanimate = settings.animateScroll;\n\t\t\t\t}\n\t\t\t\tif (animate) {\n\t\t\t\t\tjsp.animate(verticalDrag, 'top', destY,\t_positionDragY);\n\t\t\t\t} else {\n\t\t\t\t\tverticalDrag.css('top', destY);\n\t\t\t\t\t_positionDragY(destY);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction _positionDragY(destY)\n\t\t\t{\n\t\t\t\tif (destY === undefined) {\n\t\t\t\t\tdestY = verticalDrag.position().top;\n\t\t\t\t}\n\n\t\t\t\tcontainer.scrollTop(0);\n\t\t\t\tverticalDragPosition = destY;\n\n\t\t\t\tvar isAtTop = verticalDragPosition === 0,\n\t\t\t\t\tisAtBottom = verticalDragPosition == dragMaxY,\n\t\t\t\t\tpercentScrolled = destY/ dragMaxY,\n\t\t\t\t\tdestTop = -percentScrolled * (contentHeight - paneHeight);\n\n\t\t\t\tif (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {\n\t\t\t\t\twasAtTop = isAtTop;\n\t\t\t\t\twasAtBottom = isAtBottom;\n\t\t\t\t\telem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tupdateVerticalArrows(isAtTop, isAtBottom);\n\t\t\t\tpane.css('top', destTop);\n\t\t\t\telem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');\n\t\t\t}\n\n\t\t\tfunction positionDragX(destX, animate)\n\t\t\t{\n\t\t\t\tif (!isScrollableH) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (destX < 0) {\n\t\t\t\t\tdestX = 0;\n\t\t\t\t} else if (destX > dragMaxX) {\n\t\t\t\t\tdestX = dragMaxX;\n\t\t\t\t}\n\n\t\t\t\tif (animate === undefined) {\n\t\t\t\t\tanimate = settings.animateScroll;\n\t\t\t\t}\n\t\t\t\tif (animate) {\n\t\t\t\t\tjsp.animate(horizontalDrag, 'left', destX,\t_positionDragX);\n\t\t\t\t} else {\n\t\t\t\t\thorizontalDrag.css('left', destX);\n\t\t\t\t\t_positionDragX(destX);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction _positionDragX(destX)\n\t\t\t{\n\t\t\t\tif (destX === undefined) {\n\t\t\t\t\tdestX = horizontalDrag.position().left;\n\t\t\t\t}\n\n\t\t\t\tcontainer.scrollTop(0);\n\t\t\t\thorizontalDragPosition = destX;\n\n\t\t\t\tvar isAtLeft = horizontalDragPosition === 0,\n\t\t\t\t\tisAtRight = horizontalDragPosition == dragMaxX,\n\t\t\t\t\tpercentScrolled = destX / dragMaxX,\n\t\t\t\t\tdestLeft = -percentScrolled * (contentWidth - paneWidth);\n\n\t\t\t\tif (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {\n\t\t\t\t\twasAtLeft = isAtLeft;\n\t\t\t\t\twasAtRight = isAtRight;\n\t\t\t\t\telem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tupdateHorizontalArrows(isAtLeft, isAtRight);\n\t\t\t\tpane.css('left', destLeft);\n\t\t\t\telem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');\n\t\t\t}\n\n\t\t\tfunction updateVerticalArrows(isAtTop, isAtBottom)\n\t\t\t{\n\t\t\t\tif (settings.showArrows) {\n\t\t\t\t\tarrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');\n\t\t\t\t\tarrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction updateHorizontalArrows(isAtLeft, isAtRight)\n\t\t\t{\n\t\t\t\tif (settings.showArrows) {\n\t\t\t\t\tarrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');\n\t\t\t\t\tarrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction scrollToY(destY, animate)\n\t\t\t{\n\t\t\t\tvar percentScrolled = destY / (contentHeight - paneHeight);\n\t\t\t\tpositionDragY(percentScrolled * dragMaxY, animate);\n\t\t\t}\n\n\t\t\tfunction scrollToX(destX, animate)\n\t\t\t{\n\t\t\t\tvar percentScrolled = destX / (contentWidth - paneWidth);\n\t\t\t\tpositionDragX(percentScrolled * dragMaxX, animate);\n\t\t\t}\n\n\t\t\tfunction scrollToElement(ele, stickToTop, animate)\n\t\t\t{\n\t\t\t\tvar e, eleHeight, eleWidth, eleTop = 0, eleLeft = 0, viewportTop, viewportLeft, maxVisibleEleTop, maxVisibleEleLeft, destY, destX;\n\n\t\t\t\t// Legal hash values aren't necessarily legal jQuery selectors so we need to catch any\n\t\t\t\t// errors from the lookup...\n\t\t\t\ttry {\n\t\t\t\t\te = $(ele);\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\teleHeight = e.outerHeight();\n\t\t\t\teleWidth= e.outerWidth();\n\n\t\t\t\tcontainer.scrollTop(0);\n\t\t\t\tcontainer.scrollLeft(0);\n\t\t\t\t\n\t\t\t\t// loop through parents adding the offset top of any elements that are relatively positioned between\n\t\t\t\t// the focused element and the jspPane so we can get the true distance from the top\n\t\t\t\t// of the focused element to the top of the scrollpane...\n\t\t\t\twhile (!e.is('.jspPane')) {\n\t\t\t\t\teleTop += e.position().top;\n\t\t\t\t\teleLeft += e.position().left;\n\t\t\t\t\te = e.offsetParent();\n\t\t\t\t\tif (/^body|html$/i.test(e[0].nodeName)) {\n\t\t\t\t\t\t// we ended up too high in the document structure. Quit!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tviewportTop = contentPositionY();\n\t\t\t\tmaxVisibleEleTop = viewportTop + paneHeight;\n\t\t\t\tif (eleTop < viewportTop || stickToTop) { // element is above viewport\n\t\t\t\t\tdestY = eleTop - settings.verticalGutter;\n\t\t\t\t} else if (eleTop + eleHeight > maxVisibleEleTop) { // element is below viewport\n\t\t\t\t\tdestY = eleTop - paneHeight + eleHeight + settings.verticalGutter;\n\t\t\t\t}\n\t\t\t\tif (destY) {\n\t\t\t\t\tscrollToY(destY, animate);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tviewportLeft = contentPositionX();\n\t            maxVisibleEleLeft = viewportLeft + paneWidth;\n\t            if (eleLeft < viewportLeft || stickToTop) { // element is to the left of viewport\n\t                destX = eleLeft - settings.horizontalGutter;\n\t            } else if (eleLeft + eleWidth > maxVisibleEleLeft) { // element is to the right viewport\n\t                destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;\n\t            }\n\t            if (destX) {\n\t                scrollToX(destX, animate);\n\t            }\n\n\t\t\t}\n\n\t\t\tfunction contentPositionX()\n\t\t\t{\n\t\t\t\treturn -pane.position().left;\n\t\t\t}\n\n\t\t\tfunction contentPositionY()\n\t\t\t{\n\t\t\t\treturn -pane.position().top;\n\t\t\t}\n\n\t\t\tfunction isCloseToBottom()\n\t\t\t{\n\t\t\t\tvar scrollableHeight = contentHeight - paneHeight;\n\t\t\t\treturn (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);\n\t\t\t}\n\n\t\t\tfunction isCloseToRight()\n\t\t\t{\n\t\t\t\tvar scrollableWidth = contentWidth - paneWidth;\n\t\t\t\treturn (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);\n\t\t\t}\n\n\t\t\tfunction initMousewheel()\n\t\t\t{\n\t\t\t\tcontainer.unbind(mwEvent).bind(\n\t\t\t\t\tmwEvent,\n\t\t\t\t\tfunction (event, delta, deltaX, deltaY) {\n\t\t\t\t\t\tvar dX = horizontalDragPosition, dY = verticalDragPosition;\n\t\t\t\t\t\tjsp.scrollBy(deltaX * settings.mouseWheelSpeed, -deltaY * settings.mouseWheelSpeed, false);\n\t\t\t\t\t\t// return true if there was no movement so rest of screen can scroll\n\t\t\t\t\t\treturn dX == horizontalDragPosition && dY == verticalDragPosition;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction removeMousewheel()\n\t\t\t{\n\t\t\t\tcontainer.unbind(mwEvent);\n\t\t\t}\n\n\t\t\tfunction nil()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfunction initFocusHandler()\n\t\t\t{\n\t\t\t\tpane.find(':input,a').unbind('focus.jsp').bind(\n\t\t\t\t\t'focus.jsp',\n\t\t\t\t\tfunction(e)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToElement(e.target, false);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction removeFocusHandler()\n\t\t\t{\n\t\t\t\tpane.find(':input,a').unbind('focus.jsp');\n\t\t\t}\n\t\t\t\n\t\t\tfunction initKeyboardNav()\n\t\t\t{\n\t\t\t\tvar keyDown, elementHasScrolled, validParents = [];\n\t\t\t\tisScrollableH && validParents.push(horizontalBar[0]);\n\t\t\t\tisScrollableV && validParents.push(verticalBar[0]);\n\t\t\t\t\n\t\t\t\t// IE also focuses elements that don't have tabindex set.\n\t\t\t\tpane.focus(\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\telem.focus();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\telem.attr('tabindex', 0)\n\t\t\t\t\t.unbind('keydown.jsp keypress.jsp')\n\t\t\t\t\t.bind(\n\t\t\t\t\t\t'keydown.jsp',\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)){\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar dX = horizontalDragPosition, dY = verticalDragPosition;\n\t\t\t\t\t\t\tswitch(e.keyCode) {\n\t\t\t\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\t\t\tcase 32: // space\n\t\t\t\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\t\t\t\tkeyDown = e.keyCode;\n\t\t\t\t\t\t\t\t\tkeyDownHandler();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 35: // end\n\t\t\t\t\t\t\t\t\tscrollToY(contentHeight - paneHeight);\n\t\t\t\t\t\t\t\t\tkeyDown = null;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 36: // home\n\t\t\t\t\t\t\t\t\tscrollToY(0);\n\t\t\t\t\t\t\t\t\tkeyDown = null;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\telementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;\n\t\t\t\t\t\t\treturn !elementHasScrolled;\n\t\t\t\t\t\t}\n\t\t\t\t\t).bind(\n\t\t\t\t\t\t'keypress.jsp', // For FF/ OSX so that we can cancel the repeat key presses if the JSP scrolls...\n\t\t\t\t\t\tfunction(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.keyCode == keyDown) {\n\t\t\t\t\t\t\t\tkeyDownHandler();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn !elementHasScrolled;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tif (settings.hideFocus) {\n\t\t\t\t\telem.css('outline', 'none');\n\t\t\t\t\tif ('hideFocus' in container[0]){\n\t\t\t\t\t\telem.attr('hideFocus', true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telem.css('outline', '');\n\t\t\t\t\tif ('hideFocus' in container[0]){\n\t\t\t\t\t\telem.attr('hideFocus', false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction keyDownHandler()\n\t\t\t\t{\n\t\t\t\t\tvar dX = horizontalDragPosition, dY = verticalDragPosition;\n\t\t\t\t\tswitch(keyDown) {\n\t\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\t\tjsp.scrollByY(settings.keyboardSpeed, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\t\tjsp.scrollByY(-settings.keyboardSpeed, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\tcase 32: // space\n\t\t\t\t\t\t\tjsp.scrollByY(paneHeight * settings.scrollPagePercent, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\t\tjsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\t\tjsp.scrollByX(settings.keyboardSpeed, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\t\tjsp.scrollByX(-settings.keyboardSpeed, false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\telementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;\n\t\t\t\t\treturn elementHasScrolled;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction removeKeyboardNav()\n\t\t\t{\n\t\t\t\telem.attr('tabindex', '-1')\n\t\t\t\t\t.removeAttr('tabindex')\n\t\t\t\t\t.unbind('keydown.jsp keypress.jsp');\n\t\t\t}\n\n\t\t\tfunction observeHash()\n\t\t\t{\n\t\t\t\tif (location.hash && location.hash.length > 1) {\n\t\t\t\t\tvar e,\n\t\t\t\t\t\tretryInt,\n\t\t\t\t\t\thash = escape(location.hash.substr(1)) // hash must be escaped to prevent XSS\n\t\t\t\t\t\t;\n\t\t\t\t\ttry {\n\t\t\t\t\t\te = $('#' + hash + ', a[name=\"' + hash + '\"]');\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.length && pane.find(hash)) {\n\t\t\t\t\t\t// nasty workaround but it appears to take a little while before the hash has done its thing\n\t\t\t\t\t\t// to the rendered page so we just wait until the container's scrollTop has been messed up.\n\t\t\t\t\t\tif (container.scrollTop() === 0) {\n\t\t\t\t\t\t\tretryInt = setInterval(\n\t\t\t\t\t\t\t\tfunction()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (container.scrollTop() > 0) {\n\t\t\t\t\t\t\t\t\t\tscrollToElement(e, true);\n\t\t\t\t\t\t\t\t\t\t$(document).scrollTop(container.position().top);\n\t\t\t\t\t\t\t\t\t\tclearInterval(retryInt);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t50\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscrollToElement(e, true);\n\t\t\t\t\t\t\t$(document).scrollTop(container.position().top);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction hijackInternalLinks()\n\t\t\t{\n\t\t\t\t// only register the link handler once\n\t\t\t\tif ($(document.body).data('jspHijack')) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// remember that the handler was bound\n\t\t\t\t$(document.body).data('jspHijack', true);\n\n\t\t\t\t// use live handler to also capture newly created links\n\t\t\t\t$(document.body).delegate('a[href*=#]', 'click', function(event) {\n\t\t\t\t\t// does the link point to the same page?\n\t\t\t\t\t// this also takes care of cases with a <base>-Tag or Links not starting with the hash #\n\t\t\t\t\t// e.g. <a href=\"index.html#test\"> when the current url already is index.html\n\t\t\t\t\tvar href = this.href.substr(0, this.href.indexOf('#')),\n\t\t\t\t\t\tlocationHref = location.href,\n\t\t\t\t\t\thash,\n\t\t\t\t\t\telement,\n\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\tjsp,\n\t\t\t\t\t\tscrollTop,\n\t\t\t\t\t\telementTop;\n\t\t\t\t\tif (location.href.indexOf('#') !== -1) {\n\t\t\t\t\t\tlocationHref = location.href.substr(0, location.href.indexOf('#'));\n\t\t\t\t\t}\n\t\t\t\t\tif (href !== locationHref) {\n\t\t\t\t\t\t// the link points to another page\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if jScrollPane should handle this click event\n\t\t\t\t\thash = escape(this.href.substr(this.href.indexOf('#') + 1));\n\n\t\t\t\t\t// find the element on the page\n\t\t\t\t\telement;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telement = $('#' + hash + ', a[name=\"' + hash + '\"]');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// hash is not a valid jQuery identifier\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!element.length) {\n\t\t\t\t\t\t// this link does not point to an element on this page\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = element.closest('.jspScrollable');\n\t\t\t\t\tjsp = container.data('jsp');\n\n\t\t\t\t\t// jsp might be another jsp instance than the one, that bound this event\n\t\t\t\t\t// remember: this event is only bound once for all instances.\n\t\t\t\t\tjsp.scrollToElement(element, true);\n\n\t\t\t\t\tif (container[0].scrollIntoView) {\n\t\t\t\t\t\t// also scroll to the top of the container (if it is not visible)\n\t\t\t\t\t\tscrollTop = $(window).scrollTop();\n\t\t\t\t\t\telementTop = element.offset().top;\n\t\t\t\t\t\tif (elementTop < scrollTop || elementTop > scrollTop + $(window).height()) {\n\t\t\t\t\t\t\tcontainer[0].scrollIntoView();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// jsp handled this event, prevent the browser default (scrolling :P)\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// Init touch on iPad, iPhone, iPod, Android\n\t\t\tfunction initTouch()\n\t\t\t{\n\t\t\t\tvar startX,\n\t\t\t\t\tstartY,\n\t\t\t\t\ttouchStartX,\n\t\t\t\t\ttouchStartY,\n\t\t\t\t\tmoved,\n\t\t\t\t\tmoving = false;\n  \n\t\t\t\tcontainer.unbind('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').bind(\n\t\t\t\t\t'touchstart.jsp',\n\t\t\t\t\tfunction(e)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar touch = e.originalEvent.touches[0];\n\t\t\t\t\t\tstartX = contentPositionX();\n\t\t\t\t\t\tstartY = contentPositionY();\n\t\t\t\t\t\ttouchStartX = touch.pageX;\n\t\t\t\t\t\ttouchStartY = touch.pageY;\n\t\t\t\t\t\tmoved = false;\n\t\t\t\t\t\tmoving = true;\n\t\t\t\t\t}\n\t\t\t\t).bind(\n\t\t\t\t\t'touchmove.jsp',\n\t\t\t\t\tfunction(ev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!moving) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar touchPos = ev.originalEvent.touches[0],\n\t\t\t\t\t\t\tdX = horizontalDragPosition, dY = verticalDragPosition;\n\t\t\t\t\t\t\n\t\t\t\t\t\tjsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmoved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// return true if there was no movement so rest of screen can scroll\n\t\t\t\t\t\treturn dX == horizontalDragPosition && dY == verticalDragPosition;\n\t\t\t\t\t}\n\t\t\t\t).bind(\n\t\t\t\t\t'touchend.jsp',\n\t\t\t\t\tfunction(e)\n\t\t\t\t\t{\n\t\t\t\t\t\tmoving = false;\n\t\t\t\t\t\t/*if(moved) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t).bind(\n\t\t\t\t\t'click.jsp-touchclick',\n\t\t\t\t\tfunction(e)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(moved) {\n\t\t\t\t\t\t\tmoved = false;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\tfunction destroy(){\n\t\t\t\tvar currentY = contentPositionY(),\n\t\t\t\t\tcurrentX = contentPositionX();\n\t\t\t\telem.removeClass('jspScrollable').unbind('.jsp');\n\t\t\t\telem.replaceWith(originalElement.append(pane.children()));\n\t\t\t\toriginalElement.scrollTop(currentY);\n\t\t\t\toriginalElement.scrollLeft(currentX);\n\n\t\t\t\t// clear reinitialize timer if active\n\t\t\t\tif (reinitialiseInterval) {\n\t\t\t\t\tclearInterval(reinitialiseInterval);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Public API\n\t\t\t$.extend(\n\t\t\t\tjsp,\n\t\t\t\t{\n\t\t\t\t\t// Reinitialises the scroll pane (if it's internal dimensions have changed since the last time it\n\t\t\t\t\t// was initialised). The settings object which is passed in will override any settings from the\n\t\t\t\t\t// previous time it was initialised - if you don't pass any settings then the ones from the previous\n\t\t\t\t\t// initialisation will be used.\n\t\t\t\t\treinitialise: function(s)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = $.extend({}, settings, s);\n\t\t\t\t\t\tinitialise(s);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the specified element (a jQuery object, DOM node or jQuery selector string) into view so\n\t\t\t\t\t// that it can be seen within the viewport. If stickToTop is true then the element will appear at\n\t\t\t\t\t// the top of the viewport, if it is false then the viewport will scroll as little as possible to\n\t\t\t\t\t// show the element. You can also specify if you want animation to occur. If you don't provide this\n\t\t\t\t\t// argument then the animateScroll value from the settings object is used instead.\n\t\t\t\t\tscrollToElement: function(ele, stickToTop, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToElement(ele, stickToTop, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane so that the specified co-ordinates within the content are at the top left\n\t\t\t\t\t// of the viewport. animate is optional and if not passed then the value of animateScroll from\n\t\t\t\t\t// the settings object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollTo: function(destX, destY, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToX(destX, animate);\n\t\t\t\t\t\tscrollToY(destY, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane so that the specified co-ordinate within the content is at the left of the\n\t\t\t\t\t// viewport. animate is optional and if not passed then the value of animateScroll from the settings\n\t\t\t\t\t// object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollToX: function(destX, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToX(destX, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane so that the specified co-ordinate within the content is at the top of the\n\t\t\t\t\t// viewport. animate is optional and if not passed then the value of animateScroll from the settings\n\t\t\t\t\t// object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollToY: function(destY, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToY(destY, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane to the specified percentage of its maximum horizontal scroll position. animate\n\t\t\t\t\t// is optional and if not passed then the value of animateScroll from the settings object this\n\t\t\t\t\t// jScrollPane was initialised with is used.\n\t\t\t\t\tscrollToPercentX: function(destPercentX, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToX(destPercentX * (contentWidth - paneWidth), animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane to the specified percentage of its maximum vertical scroll position. animate\n\t\t\t\t\t// is optional and if not passed then the value of animateScroll from the settings object this\n\t\t\t\t\t// jScrollPane was initialised with is used.\n\t\t\t\t\tscrollToPercentY: function(destPercentY, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tscrollToY(destPercentY * (contentHeight - paneHeight), animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then\n\t\t\t\t\t// the value of animateScroll from the settings object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollBy: function(deltaX, deltaY, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tjsp.scrollByX(deltaX, animate);\n\t\t\t\t\t\tjsp.scrollByY(deltaY, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then\n\t\t\t\t\t// the value of animateScroll from the settings object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollByX: function(deltaX, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar destX = contentPositionX() + Math[deltaX<0 ? 'floor' : 'ceil'](deltaX),\n\t\t\t\t\t\t\tpercentScrolled = destX / (contentWidth - paneWidth);\n\t\t\t\t\t\tpositionDragX(percentScrolled * dragMaxX, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then\n\t\t\t\t\t// the value of animateScroll from the settings object this jScrollPane was initialised with is used.\n\t\t\t\t\tscrollByY: function(deltaY, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar destY = contentPositionY() + Math[deltaY<0 ? 'floor' : 'ceil'](deltaY),\n\t\t\t\t\t\t\tpercentScrolled = destY / (contentHeight - paneHeight);\n\t\t\t\t\t\tpositionDragY(percentScrolled * dragMaxY, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Positions the horizontal drag at the specified x position (and updates the viewport to reflect\n\t\t\t\t\t// this). animate is optional and if not passed then the value of animateScroll from the settings\n\t\t\t\t\t// object this jScrollPane was initialised with is used.\n\t\t\t\t\tpositionDragX: function(x, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositionDragX(x, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Positions the vertical drag at the specified y position (and updates the viewport to reflect\n\t\t\t\t\t// this). animate is optional and if not passed then the value of animateScroll from the settings\n\t\t\t\t\t// object this jScrollPane was initialised with is used.\n\t\t\t\t\tpositionDragY: function(y, animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositionDragY(y, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// This method is called when jScrollPane is trying to animate to a new position. You can override\n\t\t\t\t\t// it if you want to provide advanced animation functionality. It is passed the following arguments:\n\t\t\t\t\t//  * ele          - the element whose position is being animated\n\t\t\t\t\t//  * prop         - the property that is being animated\n\t\t\t\t\t//  * value        - the value it's being animated to\n\t\t\t\t\t//  * stepCallback - a function that you must execute each time you update the value of the property\n\t\t\t\t\t// You can use the default implementation (below) as a starting point for your own implementation.\n\t\t\t\t\tanimate: function(ele, prop, value, stepCallback)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar params = {};\n\t\t\t\t\t\tparams[prop] = value;\n\t\t\t\t\t\tele.animate(\n\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t'duration'\t: settings.animateDuration,\n\t\t\t\t\t\t\t\t'easing'\t: settings.animateEase,\n\t\t\t\t\t\t\t\t'queue'\t\t: false,\n\t\t\t\t\t\t\t\t'step'\t\t: stepCallback\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the current x position of the viewport with regards to the content pane.\n\t\t\t\t\tgetContentPositionX: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentPositionX();\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the current y position of the viewport with regards to the content pane.\n\t\t\t\t\tgetContentPositionY: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentPositionY();\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the width of the content within the scroll pane.\n\t\t\t\t\tgetContentWidth: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentWidth;\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the height of the content within the scroll pane.\n\t\t\t\t\tgetContentHeight: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentHeight;\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the horizontal position of the viewport within the pane content.\n\t\t\t\t\tgetPercentScrolledX: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentPositionX() / (contentWidth - paneWidth);\n\t\t\t\t\t},\n\t\t\t\t\t// Returns the vertical position of the viewport within the pane content.\n\t\t\t\t\tgetPercentScrolledY: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn contentPositionY() / (contentHeight - paneHeight);\n\t\t\t\t\t},\n\t\t\t\t\t// Returns whether or not this scrollpane has a horizontal scrollbar.\n\t\t\t\t\tgetIsScrollableH: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn isScrollableH;\n\t\t\t\t\t},\n\t\t\t\t\t// Returns whether or not this scrollpane has a vertical scrollbar.\n\t\t\t\t\tgetIsScrollableV: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn isScrollableV;\n\t\t\t\t\t},\n\t\t\t\t\t// Gets a reference to the content pane. It is important that you use this method if you want to\n\t\t\t\t\t// edit the content of your jScrollPane as if you access the element directly then you may have some\n\t\t\t\t\t// problems (as your original element has had additional elements for the scrollbars etc added into\n\t\t\t\t\t// it).\n\t\t\t\t\tgetContentPane: function()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn pane;\n\t\t\t\t\t},\n\t\t\t\t\t// Scrolls this jScrollPane down as far as it can currently scroll. If animate isn't passed then the\n\t\t\t\t\t// animateScroll value from settings is used instead.\n\t\t\t\t\tscrollToBottom: function(animate)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositionDragY(dragMaxY, animate);\n\t\t\t\t\t},\n\t\t\t\t\t// Hijacks the links on the page which link to content inside the scrollpane. If you have changed\n\t\t\t\t\t// the content of your page (e.g. via AJAX) and want to make sure any new anchor links to the\n\t\t\t\t\t// contents of your scroll pane will work then call this function.\n\t\t\t\t\thijackInternalLinks: $.noop,\n\t\t\t\t\t// Removes the jScrollPane and returns the page to the state it was in before jScrollPane was\n\t\t\t\t\t// initialised.\n\t\t\t\t\tdestroy: function()\n\t\t\t\t\t{\n\t\t\t\t\t\t\tdestroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\tinitialise(s);\n\t\t}\n\n\t\t// Pluginifying code...\n\t\tsettings = $.extend({}, $.fn.jScrollPane.defaults, settings);\n\t\t\n\t\t// Apply default speed\n\t\t$.each(['mouseWheelSpeed', 'arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function() {\n\t\t\tsettings[this] = settings[this] || settings.speed;\n\t\t});\n\n\t\treturn this.each(\n\t\t\tfunction()\n\t\t\t{\n\t\t\t\tvar elem = $(this), jspApi = elem.data('jsp');\n\t\t\t\tif (jspApi) {\n\t\t\t\t\tjspApi.reinitialise(settings);\n\t\t\t\t} else {\n\t\t\t\t\t$(\"script\",elem).filter('[type=\"text/javascript\"],:not([type])').remove();\n\t\t\t\t\tjspApi = new JScrollPane(elem, settings);\n\t\t\t\t\telem.data('jsp', jspApi);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t};\n\n\t$.fn.jScrollPane.defaults = {\n\t\tshowArrows\t\t\t\t\t: false,\n\t\tmaintainPosition\t\t\t: true,\n\t\tstickToBottom\t\t\t\t: false,\n\t\tstickToRight\t\t\t\t: false,\n\t\tclickOnTrack\t\t\t\t: true,\n\t\tautoReinitialise\t\t\t: false,\n\t\tautoReinitialiseDelay\t\t: 500,\n\t\tverticalDragMinHeight\t\t: 0,\n\t\tverticalDragMaxHeight\t\t: 99999,\n\t\thorizontalDragMinWidth\t\t: 0,\n\t\thorizontalDragMaxWidth\t\t: 99999,\n\t\tcontentWidth\t\t\t\t: undefined,\n\t\tanimateScroll\t\t\t\t: false,\n\t\tanimateDuration\t\t\t\t: 300,\n\t\tanimateEase\t\t\t\t\t: 'linear',\n\t\thijackInternalLinks\t\t\t: false,\n\t\tverticalGutter\t\t\t\t: 4,\n\t\thorizontalGutter\t\t\t: 4,\n\t\tmouseWheelSpeed\t\t\t\t: 0,\n\t\tarrowButtonSpeed\t\t\t: 0,\n\t\tarrowRepeatFreq\t\t\t\t: 50,\n\t\tarrowScrollOnHover\t\t\t: false,\n\t\ttrackClickSpeed\t\t\t\t: 0,\n\t\ttrackClickRepeatFreq\t\t: 70,\n\t\tverticalArrowPositions\t\t: 'split',\n\t\thorizontalArrowPositions\t: 'split',\n\t\tenableKeyboardNavigation\t: true,\n\t\thideFocus\t\t\t\t\t: false,\n\t\tkeyboardSpeed\t\t\t\t: 0,\n\t\tinitialDelay                : 300,        // Delay before starting repeating\n\t\tspeed\t\t\t\t\t\t: 30,\t\t// Default speed when others falsey\n\t\tscrollPagePercent\t\t\t: .8\t\t// Percent of visible area scrolled when pageUp/Down or track area pressed\n\t};\n\n})(jQuery,this);\n\n", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已经分析了 'jScrollPane.js' 文件的内容。这是一个 jQuery 插件，用于创建自定义滚动条。我检查了所有潜在的输入点，包括 URL 哈希处理、内部链接劫持、用户交互事件（鼠标、键盘、触摸）和设置参数。代码中使用了转义函数（escape）和 try-catch 块来处理输入，没有发现动态代码执行（如 eval）、未验证的 DOM 操作或明显的安全漏洞。输入数据被安全地用于 jQuery 选择器和滚动逻辑，没有完整的攻击链证据。因此，我无法识别任何实际可利用的漏洞。\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": \"对文件 'jScrollPane.js' 的安全分析完成。未发现任何实际可利用的安全漏洞或完整的攻击链。\\n\\n**分析摘要：**\\n- **输入点识别**：主要输入点包括 URL 哈希（通过 `location.hash`）、内部链接点击（通过 `hijackInternalLinks`）、用户交互事件（鼠标、键盘、触摸）和设置参数。\\n- **数据流追踪**：输入数据（如哈希值）通过 `escape` 函数转义，并在 jQuery 选择器中使用，伴有 try-catch 错误处理。未发现缺少验证或边界检查的过程。\\n- **组件交互分析**：库处理滚动行为，与 DOM 元素交互，但未发现外部可控数据导致危险操作（如代码注入或权限提升）。\\n- **利用链评估**：无完整攻击链。输入被限制在滚动功能内，无证据表明可导致 XSS、代码执行或其他漏洞。\\n\\n**结论**：该文件是一个前端 UI 库，代码采取了基本的安全措施（如输入转义和错误处理），在典型使用场景下不存在明确的可利用漏洞。建议在固件上下文中，确保其他组件不滥用此库的输入点。\"\n  },\n  \"status\": \"complete\"\n}"}
