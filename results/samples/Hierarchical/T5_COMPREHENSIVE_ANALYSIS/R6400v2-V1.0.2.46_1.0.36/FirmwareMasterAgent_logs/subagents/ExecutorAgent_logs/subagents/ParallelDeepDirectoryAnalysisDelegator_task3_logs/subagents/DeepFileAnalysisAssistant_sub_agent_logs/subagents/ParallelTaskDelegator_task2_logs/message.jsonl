{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（sbin）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 'sbin' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: FunctionDelegator\n  Description: \n    函数分析委托器 - 专门分析二进制文件中函数调用链的代理。它的职责是正向追踪函数调用之间的污点数据流。你可以将潜在的外部入口点委托给此代理进行深入追踪。\n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"task\": {\n            \"type\": \"string\",\n            \"description\": \"为子函数创建分析任务时，你的描述必须清楚地包括以下四点：\\n1. **目标函数**：要分析的子函数的名称和地址。\\n2. **污点入口**：污点在子函数中所在的特定寄存器或栈地址（例如，'污点在第一个参数寄存器 r0 中'）。\\n3. **污点来源**：这个污点数据在父函数中是如何产生的（例如，'这个值是父函数 main 通过调用 nvram_get(\\\"lan_ipaddr\\\") 获取的'）。\\n4. **分析目标**：清楚地指出新任务应该追踪这个新的污点入口（例如，'在子函数内追踪 r0'）。\"\n          },\n          \"task_context\": {\n            \"type\": \"string\",\n            \"description\": \"（可选）提供可能影响分析的补充上下文。这些信息不是污点流本身的一部分，但可能影响子函数的执行路径。例如：\\n- '此时寄存器 r2 的值为 0x500，表示最大缓冲区长度。'\\n- '在此调用之前，全局变量 `is_admin` 被设置为 1。'\\n- '在分析期间假设文件已成功打开。'\"\n          }\n        },\n        \"required\": [\n          \"task\"\n        ]\n      },\n      \"description\": \"要执行的函数分析任务列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 用于查询此固件文件系统的所有已知信息。可以查询文件的已知发现以及其他文件的已知发现。你可以优先查询文件的已知发现，然后通过结果链接到其他文件的已知发现。注意：没有发现意味着当前还没有发现。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前具体任务：\n使用 r2 的 izz 命令列出所有字符串，以识别网络接口、文件路径、环境变量等输入点。"}
{"role": "assistant", "content": "{\n  \"thought\": \"用户请求对固件进行全面的安全分析，核心目标是识别从不可信输入点到危险操作的完整攻击链。当前具体任务是使用 r2 的 izz 命令列出所有字符串，以识别网络接口、文件路径、环境变量等输入点。我将先执行这个命令来获取字符串列表，然后基于结果进行进一步分析，以识别潜在的输入源和数据流。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"izz\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"izz\"}\n结果：\n nth  paddr      vaddr      len size section         type    string\n――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0    0x000000f4 0x000080f4 19  20   .interp         ascii   /lib/ld-uClibc.so.0\n1    0x00000114 0x00008114 7   32   .hash           utf32le r\\f®±ªf½\n2    0x000001b8 0x000081b8 4   20   .hash           utf32le `5¹º\n3    0x000001e0 0x000081e0 4   20   .hash           utf32le b-¤H\n4    0x00000248 0x00008248 4   20   .hash           utf32le Zv²£\n5    0x00000284 0x00008284 7   32   .hash           utf32le Upjq¼°¡\n6    0x0000042c 0x0000842c 4   20   .hash           utf32le  (8\"\n7    0x000004e0 0x000084e0 5   24   .hash           utf32le _Yo<S\n8    0x00000514 0x00008514 5   24   .hash           utf32le 0dta\\n\n9    0x00000608 0x00008608 6   28   .hash           utf32le \\e|BOy©\n10   0x00001231 0x00009231 11  12   .dynstr         ascii   libnvram.so\n11   0x0000123d 0x0000923d 6   7    .dynstr         ascii   strcpy\n12   0x00001244 0x00009244 5   6    .dynstr         ascii   ioctl\n13   0x0000124a 0x0000924a 6   7    .dynstr         ascii   memcpy\n14   0x00001251 0x00009251 6   7    .dynstr         ascii   perror\n15   0x00001258 0x00009258 6   7    .dynstr         ascii   system\n16   0x0000125f 0x0000925f 6   7    .dynstr         ascii   malloc\n17   0x00001266 0x00009266 20  21   .dynstr         ascii   acosNvramConfig_read\n18   0x0000127b 0x0000927b 4   5    .dynstr         ascii   mmap\n19   0x00001280 0x00009280 7   8    .dynstr         ascii   fprintf\n20   0x00001288 0x00009288 4   5    .dynstr         ascii   kill\n21   0x0000128d 0x0000928d 21  22   .dynstr         ascii   acosNvramConfig_unset\n22   0x000012a3 0x000092a3 19  20   .dynstr         ascii   acosNvramConfig_get\n23   0x000012b7 0x000092b7 24  25   .dynstr         ascii   acosNvramConfig_invmatch\n24   0x000012d0 0x000092d0 7   8    .dynstr         ascii   strncmp\n25   0x000012d8 0x000092d8 7   8    .dynstr         ascii   strncpy\n26   0x000012e0 0x000092e0 21  22   .dynstr         ascii   acosNvramConfig_match\n27   0x000012f6 0x000092f6 5   6    .dynstr         ascii   fopen\n28   0x000012fc 0x000092fc 6   7    .dynstr         ascii   memset\n29   0x00001303 0x00009303 6   7    .dynstr         ascii   fclose\n30   0x0000130a 0x0000930a 6   7    .dynstr         ascii   strcmp\n31   0x00001311 0x00009311 7   8    .dynstr         ascii   sprintf\n32   0x00001319 0x00009319 30  31   .dynstr         ascii   acosNvramConfig_setPAParam_RU2\n33   0x00001338 0x00009338 6   7    .dynstr         ascii   stderr\n34   0x0000133f 0x0000933f 20  21   .dynstr         ascii   acosNvramConfig_save\n35   0x00001354 0x00009354 6   7    .dynstr         ascii   fwrite\n36   0x0000135b 0x0000935b 19  20   .dynstr         ascii   acosNvramConfig_set\n37   0x0000136f 0x0000936f 16  17   .dynstr         ascii   __errno_location\n38   0x00001380 0x00009380 6   7    .dynstr         ascii   strlen\n39   0x00001387 0x00009387 4   5    .dynstr         ascii   free\n40   0x0000138c 0x0000938c 17  18   .dynstr         ascii   libacos_shared.so\n41   0x0000139e 0x0000939e 11  12   .dynstr         ascii   bd_read_pin\n42   0x000013aa 0x000093aa 19  20   .dynstr         ascii   get_eth_link_status\n43   0x000013be 0x000093be 12  13   .dynstr         ascii   bd_read_ssid\n44   0x000013cb 0x000093cb 17  18   .dynstr         ascii   restore_guest_led\n45   0x000013dd 0x000093dd 7   8    .dynstr         ascii   waitpid\n46   0x000013e5 0x000093e5 9   10   .dynstr         ascii   getTokens\n47   0x000013ef 0x000093ef 8   9    .dynstr         ascii   strtok_r\n48   0x000013f8 0x000093f8 16  17   .dynstr         ascii   create_ipv6_addr\n49   0x00001409 0x00009409 18  19   .dynstr         ascii   bd_read_passphrase\n50   0x0000141c 0x0000941c 15  16   .dynstr         ascii   bd_read_eth_mac\n51   0x0000142c 0x0000942c 24  25   .dynstr         ascii   openvpn_make_config_file\n52   0x00001445 0x00009445 9   10   .dynstr         ascii   inet_pton\n53   0x0000144f 0x0000944f 8   9    .dynstr         ascii   snprintf\n54   0x00001458 0x00009458 6   7    .dynstr         ascii   munmap\n55   0x0000145f 0x0000945f 25  26   .dynstr         ascii   get_inet6_link_local_info\n56   0x00001479 0x00009479 10  11   .dynstr         ascii   bd_read_sn\n57   0x00001484 0x00009484 25  26   .dynstr         ascii   wait_for_ppp_to_terminate\n58   0x0000149e 0x0000949e 9   10   .dynstr         ascii   route_add\n59   0x000014a8 0x000094a8 6   7    .dynstr         ascii   usleep\n60   0x000014af 0x000094af 5   6    .dynstr         ascii   fgets\n61   0x000014b5 0x000094b5 23  24   .dynstr         ascii   abEnableLanEthernetPort\n62   0x000014cd 0x000094cd 13  14   .dynstr         ascii   load_rf_param\n63   0x000014db 0x000094db 17  18   .dynstr         ascii   preset_wan_routes\n64   0x000014ed 0x000094ed 24  25   .dynstr         ascii   abfifo_is_running_or_not\n65   0x00001506 0x00009506 18  19   .dynstr         ascii   compress_ipv6_addr\n66   0x00001519 0x00009519 4   5    .dynstr         ascii   dup2\n67   0x0000151e 0x0000951e 4   5    .dynstr         ascii   feof\n68   0x00001523 0x00009523 7   8    .dynstr         ascii   strtoul\n69   0x0000152b 0x0000952b 4   5    .dynstr         ascii   itoa\n70   0x00001530 0x00009530 16  17   .dynstr         ascii   bd_read_board_id\n71   0x00001541 0x00009541 24  25   .dynstr         ascii   mac_addr_to_interface_id\n72   0x0000155a 0x0000955a 12  13   .dynstr         ascii   is_ru_region\n73   0x00001567 0x00009567 20  21   .dynstr         ascii   check_upgrade_status\n74   0x0000157c 0x0000957c 11  12   .dynstr         ascii   strncasecmp\n75   0x00001588 0x00009588 14  15   .dynstr         ascii   initial_abfifo\n76   0x00001597 0x00009597 8   9    .dynstr         ascii   MD5Final\n77   0x000015a0 0x000095a0 26  27   .dynstr         ascii   single_session_pppoe_check\n78   0x000015bb 0x000095bb 19  20   .dynstr         ascii   __ctype_tolower_loc\n79   0x000015cf 0x000095cf 10  11   .dynstr         ascii   del_routes\n80   0x000015da 0x000095da 8   9    .dynstr         ascii   ifconfig\n81   0x000015e3 0x000095e3 6   7    .dynstr         ascii   strcat\n82   0x000015ea 0x000095ea 9   10   .dynstr         ascii   inet_addr\n83   0x000015f4 0x000095f4 19  20   .dynstr         ascii   set_CTF_Router_Mode\n84   0x00001608 0x00009608 16  17   .dynstr         ascii   send_data_to_nat\n85   0x00001619 0x00009619 10  11   .dynstr         ascii   add_routes\n86   0x00001624 0x00009624 23  24   .dynstr         ascii   is_single_session_pppoe\n87   0x0000163c 0x0000963c 5   6    .dynstr         ascii   _eval\n88   0x00001642 0x00009642 6   7    .dynstr         ascii   strstr\n89   0x00001649 0x00009649 4   5    .dynstr         ascii   rand\n90   0x0000164e 0x0000964e 17  18   .dynstr         ascii   arp_reply_control\n91   0x00001660 0x00009660 6   7    .dynstr         ascii   signal\n92   0x00001667 0x00009667 16  17   .dynstr         ascii   set_led_settings\n93   0x00001678 0x00009678 6   7    .dynstr         ascii   unlink\n94   0x0000167f 0x0000967f 6   7    .dynstr         ascii   strtok\n95   0x00001686 0x00009686 6   7    .dynstr         ascii   memcmp\n96   0x0000168d 0x0000968d 4   5    .dynstr         ascii   fork\n97   0x00001692 0x00009692 6   7    .dynstr         ascii   sscanf\n98   0x00001699 0x00009699 15  16   .dynstr         ascii   getReservedAddr\n99   0x000016a9 0x000096a9 5   6    .dynstr         ascii   fread\n100  0x000016af 0x000096af 17  18   .dynstr         ascii   ambitSetLogFilter\n101  0x000016c1 0x000096c1 9   10   .dynstr         ascii   inet_aton\n102  0x000016cb 0x000096cb 16  17   .dynstr         ascii   send_wps_led_cmd\n103  0x000016dc 0x000096dc 11  12   .dynstr         ascii   set_eth_mac\n104  0x000016e8 0x000096e8 27  28   .dynstr         ascii   getinst_ipv6rd_rules_shared\n105  0x00001704 0x00009704 9   10   .dynstr         ascii   inet_ntoa\n106  0x0000170e 0x0000970e 24  25   .dynstr         ascii   abDisableLanEthernetPort\n107  0x00001727 0x00009727 9   10   .dynstr         ascii   mtd_erase\n108  0x00001731 0x00009731 10  11   .dynstr         ascii   sys_uptime\n109  0x0000173c 0x0000973c 19  20   .dynstr         ascii   get_6rd_auto_params\n110  0x00001750 0x00009750 7   8    .dynstr         ascii   MD5Init\n111  0x00001758 0x00009758 9   10   .dynstr         ascii   mtd_write\n112  0x00001762 0x00009762 7   8    .dynstr         ascii   strcspn\n113  0x0000176a 0x0000976a 18  19   .dynstr         ascii   openvpn_set_lan_ip\n114  0x0000177d 0x0000977d 25  26   .dynstr         ascii   need_to_run_telnetenabled\n115  0x00001797 0x00009797 9   10   .dynstr         ascii   MD5Update\n116  0x000017a1 0x000097a1 13  14   .dynstr         ascii   __ctype_b_loc\n117  0x000017af 0x000097af 4   5    .dynstr         ascii   stat\n118  0x000017b4 0x000097b4 16  17   .dynstr         ascii   sys_set_timezone\n119  0x000017c5 0x000097c5 25  26   .dynstr         ascii   is_china_specific_support\n120  0x000017df 0x000097df 4   5    .dynstr         ascii   exit\n121  0x000017e4 0x000097e4 9   10   .dynstr         ascii   inet_ntop\n122  0x000017ee 0x000097ee 4   5    .dynstr         ascii   atoi\n123  0x000017f3 0x000097f3 7   8    .dynstr         ascii   stristr\n124  0x000017fb 0x000097fb 6   7    .dynstr         ascii   strspn\n125  0x00001802 0x00009802 13  14   .dynstr         ascii   ambitWriteLog\n126  0x00001810 0x00009810 16  17   .dynstr         ascii   bd_read_sku_info\n127  0x00001821 0x00009821 13  14   .dynstr         ascii   isValidIpAddr\n128  0x0000182f 0x0000982f 6   7    .dynstr         ascii   strchr\n129  0x00001836 0x00009836 6   7    .dynstr         ascii   setsid\n130  0x0000183d 0x0000983d 9   10   .dynstr         ascii   route_del\n131  0x00001847 0x00009847 10  11   .dynstr         ascii   ether_atoe\n132  0x00001852 0x00009852 19  20   .dynstr         ascii   convert_wlan_params\n133  0x00001866 0x00009866 13  14   .dynstr         ascii   libgcc_s.so.1\n134  0x00001874 0x00009874 5   6    .dynstr         ascii   abort\n135  0x0000187a 0x0000987a 23  24   .dynstr         ascii   __deregister_frame_info\n136  0x00001892 0x00009892 19  20   .dynstr         ascii   _Jv_RegisterClasses\n137  0x000018a6 0x000098a6 21  22   .dynstr         ascii   __register_frame_info\n138  0x000018bc 0x000098bc 9   10   .dynstr         ascii   libnat.so\n139  0x000018c6 0x000098c6 7   8    .dynstr         ascii   putchar\n140  0x000018ce 0x000098ce 17  18   .dynstr         ascii   agApi_natWanIfCnt\n141  0x000018e0 0x000098e0 18  19   .dynstr         ascii   agApi_natLanUnhook\n142  0x000018f3 0x000098f3 16  17   .dynstr         ascii   agApi_natLanHook\n143  0x00001904 0x00009904 19  20   .dynstr         ascii   agApi_fwEchoRespSet\n144  0x00001918 0x00009918 16  17   .dynstr         ascii   agApi_natDisable\n145  0x00001929 0x00009929 30  31   .dynstr         ascii   agApi_natSetWanLanConflictFlag\n146  0x00001948 0x00009948 15  16   .dynstr         ascii   agApi_natEnable\n147  0x00001958 0x00009958 17  18   .dynstr         ascii   agApi_fwPolicyAdd\n148  0x0000196a 0x0000996a 23  24   .dynstr         ascii   agApi_SetDayLightSaving\n149  0x00001982 0x00009982 26  27   .dynstr         ascii   agApi_qos_del_all_database\n150  0x0000199d 0x0000999d 15  16   .dynstr         ascii   agApi_natUnhook\n151  0x000019ad 0x000099ad 25  26   .dynstr         ascii   agApi_natSetInboundFilter\n152  0x000019c7 0x000099c7 25  26   .dynstr         ascii   agApi_setDeviceListenPort\n153  0x000019e1 0x000099e1 22  23   .dynstr         ascii   agApi_setDropAlgPacket\n154  0x000019f8 0x000099f8 20  21   .dynstr         ascii   agApi_natPptpWanHook\n155  0x00001a0d 0x00009a0d 18  19   .dynstr         ascii   agApi_fwDMZRuleSet\n156  0x00001a20 0x00009a20 22  23   .dynstr         ascii   acosNat_DoConnRecovery\n157  0x00001a37 0x00009a37 13  14   .dynstr         ascii   agApi_natHook\n158  0x00001a45 0x00009a45 19  20   .dynstr         ascii   agApi_fwPolicyClear\n159  0x00001a59 0x00009a59 18  19   .dynstr         ascii   agApi_natSetRegion\n160  0x00001a6c 0x00009a6c 17  18   .dynstr         ascii   agApi_feature_set\n161  0x00001a7e 0x00009a7e 12  13   .dynstr         ascii   agApi_setAlg\n162  0x00001a8b 0x00009a8b 13  14   .dynstr         ascii   libcrypt.so.0\n163  0x00001a99 0x00009a99 5   6    .dynstr         ascii   crypt\n164  0x00001a9f 0x00009a9f 9   10   .dynstr         ascii   libc.so.0\n165  0x00001aa9 0x00009aa9 8   9    .dynstr         ascii   unsetenv\n166  0x00001ab2 0x00009ab2 5   6    .dynstr         ascii   mknod\n167  0x00001ab8 0x00009ab8 6   7    .dynstr         ascii   getenv\n168  0x00001abf 0x00009abf 7   8    .dynstr         ascii   tolower\n169  0x00001ac7 0x00009ac7 6   7    .dynstr         ascii   remove\n170  0x00001ace 0x00009ace 12  13   .dynstr         ascii   settimeofday\n171  0x00001adb 0x00009adb 5   6    .dynstr         ascii   chmod\n172  0x00001ae1 0x00009ae1 6   7    .dynstr         ascii   strtol\n173  0x00001ae8 0x00009ae8 7   8    .dynstr         ascii   getpgrp\n174  0x00001af0 0x00009af0 6   7    .dynstr         ascii   rename\n175  0x00001af7 0x00009af7 7   8    .dynstr         ascii   strrchr\n176  0x00001aff 0x00009aff 6   7    .dynstr         ascii   reboot\n177  0x00001b06 0x00009b06 5   6    .dynstr         ascii   fseek\n178  0x00001b0c 0x00009b0c 7   8    .dynstr         ascii   isupper\n179  0x00001b14 0x00009b14 11  12   .dynstr         ascii   sethostname\n180  0x00001b20 0x00009b20 4   5    .dynstr         ascii   sync\n181  0x00001b25 0x00009b25 5   6    .dynstr         ascii   execv\n182  0x00001b2b 0x00009b2b 13  14   .dynstr         ascii   __uClibc_main\n183  0x00001b39 0x00009b39 7   8    .dynstr         ascii   symlink\n184  0x00001b41 0x00009b41 9   10   .dynstr         ascii   tcgetattr\n185  0x00001b4b 0x00009b4b 5   6    .dynstr         ascii   mount\n186  0x00001b51 0x00009b51 5   6    .dynstr         ascii   fgetc\n187  0x00001b57 0x00009b57 5   6    .dynstr         ascii   fputc\n188  0x00001b5d 0x00009b5d 6   7    .dynstr         ascii   access\n189  0x00001b64 0x00009b64 5   6    .dynstr         ascii   fputs\n190  0x00001b6a 0x00009b6a 9   10   .dynstr         ascii   tcsetattr\n191  0x00001b74 0x00009b74 5   6    .dynstr         ascii   mkdir\n192  0x00001b7a 0x00009b7a 9   10   .dynstr         ascii   tcsetpgrp\n193  0x00001b84 0x00009b84 6   7    .dynstr         ascii   _edata\n194  0x00001b8b 0x00009b8b 11  12   .dynstr         ascii   __bss_start\n195  0x00001b97 0x00009b97 13  14   .dynstr         ascii   __bss_start__\n196  0x00001ba5 0x00009ba5 11  12   .dynstr         ascii   __bss_end__\n197  0x00001bb1 0x00009bb1 7   8    .dynstr         ascii   __end__\n198  0x00001bb9 0x00009bb9 4   5    .dynstr         ascii   _end\n199  0x00018734 0x00020734 8   9    .rodata         ascii   board_id\n200  0x00018740 0x00020740 18  19   .rodata         ascii   U12H332T20_NETGEAR\n201  0x00018754 0x00020754 18  19   .rodata         ascii   U12H332T30_NETGEAR\n202  0x00018768 0x00020768 21  22   .rodata         ascii   Release version : %s\\n\n203  0x00018780 0x00020780 50  51   .rodata         ascii   802.11ac Dual Band Gigabit Wireless Router R6400v2\n204  0x000187b4 0x000207b4 27  28   .rodata         ascii                     %s/%s/%s\\n\n205  0x000187d0 0x000207d0 10  11   .rodata         ascii   U12H332T30\n206  0x000187dc 0x000207dc 9   10   .rodata         ascii   V1.0.2.46\n207  0x000187e8 0x000207e8 6   7    .rodata         ascii   1.0.36\n208  0x000187f0 0x000207f0 18  19   .rodata         ascii   U12H332T77_NETGEAR\n209  0x00018804 0x00020804 50  51   .rodata         ascii   802.11ac Dual Band Gigabit Wireless Router R6700v3\n210  0x00018838 0x00020838 10  11   .rodata         ascii   U12H332T77\n211  0x00018844 0x00020844 48  49   .rodata         ascii   802.11ac Dual Band Gigabit Wireless Router R6400\n212  0x00018878 0x00020878 10  11   .rodata         ascii   U12H332T00\n213  0x00018884 0x00020884 24  25   .rodata         ascii              Time : %s %s\\n\n214  0x000188a0 0x000208a0 11  12   .rodata         ascii   Nov 27 2017\n215  0x000188ac 0x000208ac 8   9    .rodata         ascii   20:54:42\n216  0x000188b8 0x000208b8 11  12   .rodata         ascii   cfe_version\n217  0x000188c4 0x000208c4 21  22   .rodata         ascii       CFE version : %s\\n\n218  0x000188dc 0x000208dc 21  22   .rodata         ascii       CFE version : N/A\n219  0x000188f4 0x000208f4 15  16   .rodata         ascii   /tmp/uboot.info\n220  0x00018904 0x00020904 16  17   .rodata         ascii   cannot open file\n221  0x00018918 0x00020918 17  18   .rodata         ascii   Boot code version\n222  0x0001892c 0x0002092c 25  26   .rodata         ascii   Boot code version : %c%s\\n\n223  0x00018968 0x00020968 4   5    .rodata         ascii   main\n224  0x00018994 0x00020994 21  22   .rodata         ascii   Reading board data...\n225  0x000189ac 0x000209ac 29  30   .rodata         ascii   %02X:%02X:%02X:%02X:%02X:%02X\n226  0x000189cc 0x000209cc 10  11   .rodata         ascii   lan_hwaddr\n227  0x000189d8 0x000209d8 10  11   .rodata         ascii   et0macaddr\n228  0x000189e4 0x000209e4 15  16   .rodata         ascii   pci/1/1/macaddr\n229  0x000189f4 0x000209f4 15  16   .rodata         ascii   enable_sta_mode\n230  0x00018a04 0x00020a04 16  17   .rodata         ascii   bridge_interface\n231  0x00018a18 0x00020a18 16  17   .rodata         ascii   default LAN MAC!\n232  0x00018a2c 0x00020a2c 15  16   .rodata         ascii   pci/2/1/macaddr\n233  0x00018a3c 0x00020a3c 10  11   .rodata         ascii   et1macaddr\n234  0x00018a48 0x00020a48 9   10   .rodata         ascii   ipv6ready\n235  0x00018a54 0x00020a54 11  12   .rodata         ascii   wan_hwaddr2\n236  0x00018a60 0x00020a60 14  15   .rodata         ascii   wan_hwaddr_sel\n237  0x00018a70 0x00020a70 10  11   .rodata         ascii   wan_hwaddr\n238  0x00018a7c 0x00020a7c 14  15   .rodata         ascii   wps_device_pin\n239  0x00018a8c 0x00020a8c 8   9    .rodata         ascii   12345670\n240  0x00018a98 0x00020a98 8   9    .rodata         ascii   WSC/UUID\n241  0x00018aa4 0x00020aa4 8   9    .rodata         ascii   WSC_UUID\n242  0x00018ab0 0x00020ab0 4   5    .rodata         ascii   0x%s\n243  0x00018ab8 0x00020ab8 13  14   .rodata         ascii   WSC UUID: %s\\n\n244  0x00018ac8 0x00020ac8 8   9    .rodata         ascii   wps_uuid\n245  0x00018ad4 0x00020ad4 10  11   .rodata         ascii   region_num\n246  0x00018ae0 0x00020ae0 8   9    .rodata         ascii   sku_name\n247  0x00018aec 0x00020aec 8   9    .rodata         ascii   sku_lang\n248  0x00018af8 0x00020af8 6   7    .rodata         ascii   0x%04X\n249  0x00018b00 0x00020b00 13  14   .rodata         ascii   load_defaults\n250  0x00018b10 0x00020b10 10  11   .rodata         ascii   wla_region\n251  0x00018b1c 0x00020b1c 9   10   .rodata         ascii   time_zone\n252  0x00018b2c 0x00020b2c 11  12   .rodata         ascii   wlg_channel\n253  0x00018b3c 0x00020b3c 16  17   .rodata         ascii   wlg_temp_channel\n254  0x00018b50 0x00020b50 8   9    .rodata         ascii   wlg_mode\n255  0x00018b5c 0x00020b5c 4   5    .rodata         ascii   HT80\n256  0x00018b70 0x00020b70 15  16   .rodata         ascii   wla_preset_ssid\n257  0x00018b80 0x00020b80 21  22   .rodata         ascii   wla_preset_passphrase\n258  0x00018b98 0x00020b98 8   9    .rodata         ascii   wla_ssid\n259  0x00018ba4 0x00020ba4 14  15   .rodata         ascii   wla_passphrase\n260  0x00018bb4 0x00020bb4 13  14   .rodata         ascii   wla_secu_type\n261  0x00018bc4 0x00020bc4 8   9    .rodata         ascii   WPA2-PSK\n262  0x00018bd0 0x00020bd0 19  20   .rodata         ascii   wl_wps_config_state\n263  0x00018be4 0x00020be4 20  21   .rodata         ascii   wl0_wps_config_state\n264  0x00018bfc 0x00020bfc 11  12   .rodata         ascii   lan_wps_oob\n265  0x00018c08 0x00020c08 8   9    .rodata         ascii   disabled\n266  0x00018c14 0x00020c14 22  23   .rodata         ascii   allow_registrar_config\n267  0x00018c2c 0x00020c2c 15  16   .rodata         ascii   wlg_preset_ssid\n268  0x00018c3c 0x00020c3c 21  22   .rodata         ascii   wlg_preset_passphrase\n269  0x00018c54 0x00020c54 8   9    .rodata         ascii   wlg_ssid\n270  0x00018c60 0x00020c60 14  15   .rodata         ascii   wlg_passphrase\n271  0x00018c70 0x00020c70 13  14   .rodata         ascii   wlg_secu_type\n272  0x00018c80 0x00020c80 20  21   .rodata         ascii   wl1_wps_config_state\n273  0x00018c98 0x00020c98 17  18   .rodata         ascii   /tmp/register.txt\n274  0x00018cac 0x00020cac 27  28   .rodata         ascii   Input Register Info Error!\\n\n275  0x00018cc8 0x00020cc8 61  62   .rodata         ascii   {\"id\":\"readycloud\",\"state\":\"%s\",\"owner\":\"%s\",\"password\":\"%s\"}\n276  0x00018d08 0x00020d08 14  15   .rodata         ascii   mkdir /dev/net\n277  0x00018d18 0x00020d18 20  21   .rodata         ascii   cp /dev/tun /dev/net\n278  0x00018d30 0x00020d30 33  34   .rodata         ascii   cp /opt/broken/register.txt /tmp/\n279  0x00018d54 0x00020d54 11  12   .rodata         ascii   leafp2p_run\n280  0x00018d60 0x00020d60 16  17   .rodata         ascii   leafp2p_username\n281  0x00018d74 0x00020d74 43  44   .rodata         ascii   ############ leafp2p_run = %d username=%d\\n\\n\n282  0x00018da0 0x00020da0 17  18   .rodata         ascii   tmp_register_name\n283  0x00018db4 0x00020db4 18  19   .rodata         ascii   reg_cloud_tmp_user\n284  0x00018dc8 0x00020dc8 17  18   .rodata         ascii   reg_cloud_tmp_pwd\n285  0x00018ddc 0x00020ddc 112 113  .rodata         ascii   cat /tmp/register.txt | PATH_INFO=/api/services/readycloud REQUEST_METHOD=PUT /opt/broken/readycloud_control.cgi\n286  0x00018e50 0x00020e50 20  21   .rodata         ascii   igmp_proxying_enable\n287  0x00018e68 0x00020e68 10  11   .rodata         ascii   qos_enable\n288  0x00018e74 0x00020e74 12  13   .rodata         ascii   wla_repeater\n289  0x00018e84 0x00020e84 12  13   .rodata         ascii   wlg_repeater\n290  0x00018e94 0x00020e94 8   9    .rodata         ascii   qos_port\n291  0x00018ea0 0x00020ea0 12  13   .rodata         ascii   iptv_enabled\n292  0x00018eb0 0x00020eb0 22  23   .rodata         ascii   et robowr 0x0 0x8 0x1c\n293  0x00018ec8 0x00020ec8 21  22   .rodata         ascii   et robowr 0x0 0xb 0x7\n294  0x00018ee0 0x00020ee0 22  23   .rodata         ascii   et robowr 0x2 0x0 0x80\n295  0x00018ef8 0x00020ef8 24  25   .rodata         ascii   et robowr 0x02 0x03 0x02\n296  0x00018f14 0x00020f14 23  24   .rodata         ascii   et robowr 0x34 0x6 0x11\n297  0x00018f2c 0x00020f2c 25  26   .rodata         ascii   et robowr 0xffff 0xfe 0x3\n298  0x00018f48 0x00020f48 21  22   .rodata         ascii   et robowr 0x0 0x8 0x0\n299  0x00018f60 0x00020f60 21  22   .rodata         ascii   et robowr 0x0 0xb 0x6\n300  0x00018f78 0x00020f78 21  22   .rodata         ascii   et robowr 0x2 0x0 0x0\n301  0x00018f90 0x00020f90 24  25   .rodata         ascii   et robowr 0x02 0x03 0x01\n302  0x00018fac 0x00020fac 23  24   .rodata         ascii   et robowr 0x34 0x6 0x10\n303  0x00018fc4 0x00020fc4 25  26   .rodata         ascii   et robowr 0xffff 0xfe 0x1\n304  0x00018fe0 0x00020fe0 25  26   .rodata         ascii   et robowr 0xffff 0xfe 0x2\n305  0x00018ffc 0x00020ffc 25  26   .rodata         ascii   et robowr 0xffff 0xfe 0x0\n306  0x00019018 0x00021018 19  20   .rodata         ascii   ap_mode_lan_disable\n307  0x0001902c 0x0002102c 7   8    .rodata         ascii   read_bd\n308  0x00019034 0x00021034 16  17   .rodata         ascii   wireless_restart\n309  0x00019048 0x00021048 18  19   .rodata         ascii   reset_product_name\n310  0x0001905c 0x0002105c 13  14   .rodata         ascii   friendly_name\n311  0x0001906c 0x0002106c 7   8    .rodata         ascii   R6400v2\n312  0x00019074 0x00021074 12  13   .rodata         ascii   l2tp_conn_id\n313  0x00019084 0x00021084 10  11   .rodata         ascii   media_name\n314  0x00019090 0x00021090 18  19   .rodata         ascii   ReadyDLNA: R6400v2\n315  0x000190a4 0x000210a4 11  12   .rodata         ascii   system_name\n316  0x000190b0 0x000210b0 13  14   .rodata         ascii   wps_modelname\n317  0x000190c0 0x000210c0 15  16   .rodata         ascii   wps_device_name\n318  0x000190d0 0x000210d0 12  13   .rodata         ascii   wps_modelnum\n319  0x000190e0 0x000210e0 7   8    .rodata         ascii   R6700v3\n320  0x000190e8 0x000210e8 18  19   .rodata         ascii   ReadyDLNA: R6700v3\n321  0x000190fc 0x000210fc 13  14   .rodata         ascii   >/dev/console\n322  0x0001910c 0x0002110c 9   10   .rodata         ascii   wl0_radio\n323  0x00019118 0x00021118 12  13   .rodata         ascii   led_settings\n324  0x00019128 0x00021128 8   9    .rodata         ascii   turn_off\n325  0x00019134 0x00021134 9   10   .rodata         ascii   gpio %d 0\n326  0x00019140 0x00021140 9   10   .rodata         ascii   gpio %d 1\n327  0x0001914c 0x0002114c 9   10   .rodata         ascii   wl1_radio\n328  0x0001915c 0x0002115c 10  11   .rodata         ascii   gui_region\n329  0x00019168 0x00021168 7   8    .rodata         ascii   Russian\n330  0x00019174 0x00021174 29  30   .rodata         ascii   ### %s:%d Set Russian Power!\\n\n331  0x00019194 0x00021194 28  29   .rodata         ascii   ### %s:%d Set Normal Power!\\n\n332  0x000191b4 0x000211b4 15  16   .rodata         ascii   dome_led_status\n333  0x000191cc 0x000211cc 9   10   .rodata         ascii   acos_init\n334  0x000191d8 0x000211d8 15  16   .rodata         ascii   upgrage_to_4_30\n335  0x000191e8 0x000211e8 9   10   .rodata         ascii   wan_proto\n336  0x000191f4 0x000211f4 5   6    .rodata         ascii   pppoe\n337  0x000191fc 0x000211fc 9   10   .rodata         ascii   pppoe_dod\n338  0x00019208 0x00021208 4   5    .rodata         ascii   l2tp\n339  0x00019210 0x00021210 8   9    .rodata         ascii   l2tp_dod\n340  0x0001921c 0x0002121c 4   5    .rodata         ascii   pptp\n341  0x00019224 0x00021224 8   9    .rodata         ascii   pptp_dod\n342  0x00019230 0x00021230 11  12   .rodata         ascii   enable_vlan\n343  0x0001923c 0x0002123c 33  34   .rodata         ascii   nvram set vlan1ports=\"4 3 2 1 5*\"\n344  0x00019260 0x00021260 27  28   .rodata         ascii   nvram set vlan2ports=\"0 5u\"\n345  0x0001927c 0x0002127c 27  28   .rodata         ascii   nvram set vlan1hwname=\"et0\"\n346  0x00019298 0x00021298 27  28   .rodata         ascii   nvram set vlan2hwname=\"et0\"\n347  0x000192b4 0x000212b4 6   7    .rodata         ascii   static\n348  0x000192bc 0x000212bc 10  11   .rodata         ascii   wan_ipaddr\n349  0x000192c8 0x000212c8 7   8    .rodata         ascii   0.0.0.0\n350  0x000192d0 0x000212d0 16  17   .rodata         ascii   static_if_status\n351  0x000192e4 0x000212e4 16  17   .rodata         ascii   ce_dfs_ch_enable\n352  0x000192f8 0x000212f8 17  18   .rodata         ascii   fcc_dfs_ch_enable\n353  0x0001930c 0x0002130c 19  20   .rodata         ascii   telec_dfs_ch_enable\n354  0x00019320 0x00021320 17  18   .rodata         ascii   second_wan_status\n355  0x00019334 0x00021334 16  17   .rodata         ascii   first_wan_status\n356  0x00019348 0x00021348 11  12   .rodata         ascii   blank_state\n357  0x00019354 0x00021354 60  61   .rodata         ascii   echo 2400 > /proc/sys/net/ipv4/neigh/br0/base_reachable_time\n358  0x00019394 0x00021394 64  65   .rodata         ascii   echo 2400 > /proc/sys/net/ipv4/neigh/default/base_reachable_time\n359  0x000193d8 0x000213d8 47  48   .rodata         ascii   echo 1 > /proc/sys/net/ipv4/conf/all/arp_filter\n360  0x00019408 0x00021408 56  57   .rodata         ascii   echo 1 > /proc/sys/net/ipv4/conf/all/accept_source_route\n361  0x00019444 0x00021444 21  22   .rodata         ascii   restart_all_processes\n362  0x0001945c 0x0002145c 25  26   .rodata         ascii   nvram unset arp_check_run\n363  0x00019478 0x00021478 25  26   .rodata         ascii   nvram set arp_check_run=1\n364  0x00019494 0x00021494 12  13   .rodata         ascii   settimeofday\n365  0x000194a4 0x000214a4 37  38   .rodata         ascii   echo 1 >/proc/sys/net/ipv4/ip_forward\n366  0x000194cc 0x000214cc 43  44   .rodata         ascii   /bin/mknod -m 755 /dev/acos_nat_cli c 100 0\n367  0x000194f8 0x000214f8 65  66   .rodata         ascii   /sbin/insmod /lib/modules/2.6.36.4brcmarm+/kernel/lib/acos_nat.ko\n368  0x0001953c 0x0002153c 36  37   .rodata         ascii   /bin/mknod -m 755 /dev/spiv6 c 101 0\n369  0x00019564 0x00021564 10  11   .rodata         ascii   log_filter\n370  0x00019570 0x00021570 5   6    .rodata         ascii   65535\n371  0x00019578 0x00021578 17  18   .rodata         ascii   /tmp/opendns.flag\n372  0x0001958c 0x0002158c 19  20   .rodata         ascii   fopen(opendns.flag)\n373  0x000195a0 0x000215a0 15  16   .rodata         ascii   ParentalControl\n374  0x000195b0 0x000215b0 23  24   .rodata         ascii   ParentalCtrl_MAC_ID_tbl\n375  0x000195c8 0x000215c8 16  17   .rodata         ascii   /tmp/opendns.tbl\n376  0x000195dc 0x000215dc 18  19   .rodata         ascii   fopen(opendns.tbl)\n377  0x000195f0 0x000215f0 21  22   .rodata         ascii   /tmp/opendns_auth.tbl\n378  0x00019608 0x00021608 23  24   .rodata         ascii   fopen(opendns_auth.tbl)\n379  0x00019620 0x00021620 64  65   .rodata         ascii   /sbin/insmod /lib/modules/2.6.36.4brcmarm+/kernel/lib/opendns.ko\n380  0x00019664 0x00021664 69  70   .rodata         ascii   /sbin/insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/ufsd/jnl.ko\n381  0x000196ac 0x000216ac 70  71   .rodata         ascii   /sbin/insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/ufsd/ufsd.ko\n382  0x000196f4 0x000216f4 13  14   .rodata         ascii   lanip_changed\n383  0x00019704 0x00021704 8   9    .rodata         ascii   en_blink\n384  0x00019710 0x00021710 9   10   .rodata         ascii   dis_blink\n385  0x0001971c 0x0002171c 6   7    .rodata         ascii   uptime\n386  0x00019724 0x00021724 10  11   .rodata         ascii    %lu day%s\n387  0x00019730 0x00021730 11  12   .rodata         ascii    %lu hour%s\n388  0x0001973c 0x0002173c 13  14   .rodata         ascii    %lu minute%s\n389  0x0001974c 0x0002174c 13  14   .rodata         ascii    %lu second%s\n390  0x0001975c 0x0002175c 10  11   .rodata         ascii   routerinfo\n391  0x00019768 0x00021768 7   8    .rodata         ascii   burnpin\n392  0x00019770 0x00021770 12  13   .rodata         ascii   burnethermac\n393  0x00019780 0x00021780 11  12   .rodata         ascii   burnboardid\n394  0x0001978c 0x0002178c 6   7    .rodata         ascii   burnsn\n395  0x00019794 0x00021794 8   9    .rodata         ascii   burnssid\n396  0x000197a0 0x000217a0 10  11   .rodata         ascii   burn5gssid\n397  0x000197ac 0x000217ac 8   9    .rodata         ascii   burnpass\n398  0x000197b8 0x000217b8 10  11   .rodata         ascii   burn5gpass\n399  0x000197c4 0x000217c4 7   8    .rodata         ascii   burnsku\n400  0x000197cc 0x000217cc 5   6    .rodata         ascii   ledup\n401  0x000197d4 0x000217d4 8   9    .rodata         ascii   gpio 1 0\n402  0x000197e0 0x000217e0 8   9    .rodata         ascii   gpio 2 0\n403  0x000197ec 0x000217ec 8   9    .rodata         ascii   gpio 6 0\n404  0x000197f8 0x000217f8 8   9    .rodata         ascii   gpio 7 0\n405  0x00019804 0x00021804 8   9    .rodata         ascii   gpio 8 0\n406  0x00019810 0x00021810 8   9    .rodata         ascii   gpio 9 0\n407  0x0001981c 0x0002181c 9   10   .rodata         ascii   gpio 10 1\n408  0x00019828 0x00021828 9   10   .rodata         ascii   gpio 11 1\n409  0x00019834 0x00021834 9   10   .rodata         ascii   gpio 12 0\n410  0x00019840 0x00021840 9   10   .rodata         ascii   gpio 13 0\n411  0x0001984c 0x0002184c 24  25   .rodata         ascii   et robowr 0x0 0x18 0x1ff\n412  0x00019868 0x00021868 22  23   .rodata         ascii   et robowr 0x0 0x1a 0x0\n413  0x00019880 0x00021880 7   8    .rodata         ascii   leddown\n414  0x00019888 0x00021888 8   9    .rodata         ascii   gpio 1 1\n415  0x00019894 0x00021894 8   9    .rodata         ascii   gpio 2 1\n416  0x000198a0 0x000218a0 8   9    .rodata         ascii   gpio 6 1\n417  0x000198ac 0x000218ac 8   9    .rodata         ascii   gpio 7 1\n418  0x000198b8 0x000218b8 8   9    .rodata         ascii   gpio 8 1\n419  0x000198c4 0x000218c4 8   9    .rodata         ascii   gpio 9 1\n420  0x000198d0 0x000218d0 9   10   .rodata         ascii   gpio 10 0\n421  0x000198dc 0x000218dc 9   10   .rodata         ascii   gpio 11 0\n422  0x000198e8 0x000218e8 9   10   .rodata         ascii   gpio 12 1\n423  0x000198f4 0x000218f4 9   10   .rodata         ascii   gpio 13 1\n424  0x00019900 0x00021900 22  23   .rodata         ascii   et robowr 0x0 0x18 0x0\n425  0x00019918 0x00021918 12  13   .rodata         ascii   acos_service\n426  0x00019928 0x00021928 47  48   .rodata         ascii   echo /tmp/core >> /proc/sys/kernel/core_pattern\n427  0x00019958 0x00021958 31  32   .rodata         ascii   debug_hidden_page_dump_wifi_pkt\n428  0x00019978 0x00021978 28  29   .rodata         ascii   debug_hidden_page_in_process\n429  0x00019998 0x00021998 33  34   .rodata         ascii   action_Start_Capture_When_Boot_Up\n430  0x000199bc 0x000219bc 38  39   .rodata         ascii   Start Debug Log Capture when boot up !\n431  0x000199e4 0x000219e4 22  23   .rodata         ascii   debug_capture_wifi_log\n432  0x000199fc 0x000219fc 31  32   .rodata         ascii   debug_capture_detailed_wifi_log\n433  0x00019a1c 0x00021a1c 18  19   .rodata         ascii   wl ptrack_enable 1\n434  0x00019a30 0x00021a30 35  36   .rodata         ascii   debug_hidden_page_wifi_rate_monitor\n435  0x00019a54 0x00021a54 11  12   .rodata         ascii   killall cat\n436  0x00019a60 0x00021a60 18  19   .rodata         ascii   killall debug_logd\n437  0x00019a74 0x00021a74 15  16   .rodata         ascii   killall tcpdump\n438  0x00019a84 0x00021a84 33  34   .rodata         ascii   cat /proc/kmsg  > /tmp/info.txt &\n439  0x00019aa8 0x00021aa8 12  13   .rodata         ascii   debug_logd &\n440  0x00019ab8 0x00021ab8 29  30   .rodata         ascii   debug_capture_lan_wan_packets\n441  0x00019ad8 0x00021ad8 14  15   .rodata         ascii   store_location\n442  0x00019ae8 0x00021ae8 6   7    .rodata         ascii   memory\n443  0x00019af0 0x00021af0 37  38   .rodata         ascii   tcpdump -i br0 -w /tmp/BR.cap -C 10 &\n444  0x00019b18 0x00021b18 91  92   .rodata         ascii   tcpdump -i eth0 'ether[12:2] != 0x8100' and 'ether[14:2] != 0x0001' -w /tmp/ETH.cap -C 10 &\n445  0x00019b74 0x00021b74 39  40   .rodata         ascii   tcpdump -i ppp0 -w /tmp/PPP.cap -C 10 &\n446  0x00019ba0 0x00021ba0 43  44   .rodata         ascii   tcpdump -i br0 -w /tmp/BR.cap -C 100 -W 3 &\n447  0x00019bcc 0x00021bcc 97  98   .rodata         ascii   tcpdump -i eth0 'ether[12:2] != 0x8100' and 'ether[14:2] != 0x0001' -w /tmp/ETH.cap -C 100 -W 3 &\n448  0x00019c30 0x00021c30 45  46   .rodata         ascii   tcpdump -i ppp0 -w /tmp/PPP.cap -C 100 -W 3 &\n449  0x00019c60 0x00021c60 45  46   .rodata         ascii   wl msglevel +assoc +error +chanim +rate +time\n450  0x00019c90 0x00021c90 34  35   .rodata         ascii   nvram set gbsd_msglevel=0x800003ff\n451  0x00019cb4 0x00021cb4 23  24   .rodata         ascii   schedule_daylightadjust\n452  0x00019ccc 0x00021ccc 14  15   .rodata         ascii   nmrp_test_mode\n453  0x00019cdc 0x00021cdc 14  15   .rodata         ascii   telnetd_enable\n454  0x00019cec 0x00021cec 5   6    .rodata         ascii   start\n455  0x00019cf4 0x00021cf4 10  11   .rodata         ascii   ipv6_proto\n456  0x00019d00 0x00021d00 11  12   .rodata         ascii   passthrough\n457  0x00019d10 0x00021d10 8   9    .rodata         ascii   Japanese\n458  0x00019d1c 0x00021d1c 14  15   .rodata         ascii   enable_ap_mode\n459  0x00019d2c 0x00021d2c 17  18   .rodata         ascii   rmmod ipv6_spi.ko\n460  0x00019d40 0x00021d40 36  37   .rodata         ascii   insmod ipv6_spi.ko working_mode=\"ap\"\n461  0x00019d68 0x00021d68 18  19   .rodata         ascii   insmod ipv6_spi.ko\n462  0x00019d7c 0x00021d7c 11  12   .rodata         ascii   afpd_enable\n463  0x00019d88 0x00021d88 10  11   .rodata         ascii   %s \"%s\" %s\n464  0x00019d94 0x00021d94 4   5    .rodata         ascii   echo\n465  0x00019d9c 0x00021d9c 27  28   .rodata         ascii   > /proc/sys/kernel/hostname\n466  0x00019db8 0x00021db8 10  11   .rodata         ascii   /tmp/avahi\n467  0x00019dc4 0x00021dc4 19  20   .rodata         ascii   /tmp/avahi/services\n468  0x00019dd8 0x00021dd8 21  22   .rodata         ascii   /var/run/avahi-daemon\n469  0x00019df0 0x00021df0 11  12   .rodata         ascii   /tmp/config\n470  0x00019dfc 0x00021dfc 61  62   .rodata         ascii   cp -f /usr/config/netatalk/AppleVolumes.default /tmp/netatalk\n471  0x00019e3c 0x00021e3c 65  66   .rodata         ascii   cp -f /usr/config/avahi/services/http.service /tmp/avahi/services\n472  0x00019e80 0x00021e80 65  66   .rodata         ascii   cp -f /usr/config/avahi/services/smbd.service /tmp/avahi/services\n473  0x00019ec4 0x00021ec4 100 101  .rodata         ascii   /bin/nice -n 19 /usr/sbin/afpd -F /etc/netatalk/afpd.conf -P /var/run/afpd.pid -c 7 > /dev/null 2>&1\n474  0x00019f2c 0x00021f2c 47  48   .rodata         ascii   avahi-daemon -f /etc/avahi/avahi-daemon.conf -D\n475  0x00019f5c 0x00021f5c 12  13   .rodata         ascii   /tmp/openvpn\n476  0x00019f6c 0x00021f6c 15  16   .rodata         ascii   /dev/mtdblock19\n477  0x00019f7c 0x00021f7c 5   6    .rodata         ascii   jffs2\n478  0x00019f84 0x00021f84 62  63   .rodata         ascii   \\r\\n###################################mount openvpn mtdblock19\\r\n479  0x00019fc4 0x00021fc4 71  72   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usb/core/usbcore.ko\n480  0x0001a00c 0x0002200c 72  73   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usb/host/ehci-hcd.ko\n481  0x0001a058 0x00022058 72  73   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usb/host/ohci-hcd.ko\n482  0x0001a0a4 0x000220a4 78  79   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usb/storage/usb-storage.ko\n483  0x0001a0f4 0x000220f4 32  33   .rodata         ascii   mknod /dev/usblp0 -m 666 c 180 0\n484  0x0001a118 0x00022118 32  33   .rodata         ascii   mknod /dev/usblp1 -m 666 c 180 1\n485  0x0001a13c 0x0002213c 32  33   .rodata         ascii   mknod /dev/usblp2 -m 666 c 180 2\n486  0x0001a160 0x00022160 32  33   .rodata         ascii   mknod /dev/usblp3 -m 666 c 180 3\n487  0x0001a184 0x00022184 32  33   .rodata         ascii   mknod /dev/usblp4 -m 666 c 180 4\n488  0x0001a1a8 0x000221a8 32  33   .rodata         ascii   mknod /dev/usblp5 -m 666 c 180 5\n489  0x0001a1cc 0x000221cc 32  33   .rodata         ascii   mknod /dev/usblp6 -m 666 c 180 6\n490  0x0001a1f0 0x000221f0 32  33   .rodata         ascii   mknod /dev/usblp7 -m 666 c 180 7\n491  0x0001a214 0x00022214 32  33   .rodata         ascii   mknod /dev/usblp8 -m 666 c 180 8\n492  0x0001a238 0x00022238 32  33   .rodata         ascii   mknod /dev/usblp9 -m 666 c 180 9\n493  0x0001a25c 0x0002225c 76  77   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usbprinter/GPL_NetUSB.ko\n494  0x0001a2ac 0x000222ac 72  73   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usbprinter/NetUSB.ko\n495  0x0001a2f8 0x000222f8 85  86   .rodata         ascii   insmod /lib/modules/2.6.36.4brcmarm+/kernel/drivers/usbprinter/NetUSB.ko localID=\"%s\"\n496  0x0001a350 0x00022350 38  39   .rodata         ascii   /bin/mount -t usbfs none /proc/bus/usb\n497  0x0001a378 0x00022378 21  22   .rodata         ascii   mount usbdevfs failed\n498  0x0001a390 0x00022390 8   9    .rodata         ascii   /tmp/mnt\n499  0x0001a39c 0x0002239c 21  22   .rodata         ascii   mkdir /tmp/mnt failed\n500  0x0001a3b4 0x000223b4 17  18   .rodata         ascii   usb_disk_max_part\n501  0x0001a3c8 0x000223c8 23  24   .rodata         ascii   /tmp/mnt/not_approved%d\n502  0x0001a3e0 0x000223e0 10  11   .rodata         ascii   %s failed\\n\n503  0x0001a3ec 0x000223ec 9   10   .rodata         ascii   /dev/sd%c\n504  0x0001a3f8 0x000223f8 11  12   .rodata         ascii   /dev/sd%c%d\n505  0x0001a404 0x00022404 20  21   .rodata         ascii   Unable to create %s\\n\n506  0x0001a41c 0x0002241c 14  15   .rodata         ascii   /tmp/mnt/usb%d\n507  0x0001a42c 0x0002242c 21  22   .rodata         ascii   /tmp/mnt/usb%d/part%d\n508  0x0001a444 0x00022444 17  18   .rodata         ascii   /tmp/usb_vol_name\n509  0x0001a458 0x00022458 10  11   .rodata         ascii   /tmp/samba\n510  0x0001a464 0x00022464 16  17   .rodata         ascii   /tmp/samba/share\n511  0x0001a478 0x00022478 18  19   .rodata         ascii   /tmp/samba/private\n512  0x0001a48c 0x0002248c 11  12   .rodata         ascii   /tmp/shares\n513  0x0001a498 0x00022498 11  12   .rodata         ascii   http_passwd\n514  0x0001a4a4 0x000224a4 18  19   .rodata         ascii   /tmp/config/shadow\n515  0x0001a4bc 0x000224bc 29  30   .rodata         ascii   /tmp/config/shadow: no files!\n516  0x0001a4dc 0x000224dc 28  29   .rodata         ascii   admin:%s:10957:0:99999:7:::\\n\n517  0x0001a4fc 0x000224fc 25  26   .rodata         ascii   guest::10957:0:99999:7:::\n518  0x0001a518 0x00022518 25  26   .rodata         ascii   /tmp/samba/private/passwd\n519  0x0001a534 0x00022534 36  37   .rodata         ascii   /tmp/samba/private/passwd: no files!\n520  0x0001a55c 0x0002255c 28  29   .rodata         ascii   admin:x:0:0:admin:/:/bin/sh\\n\n521  0x0001a57c 0x0002257c 42  43   .rodata         ascii   echo 2097152 > /proc/sys/net/core/wmem_max\n522  0x0001a5a8 0x000225a8 42  43   .rodata         ascii   echo 2097152 > /proc/sys/net/core/rmem_max\n523  0x0001a5d4 0x000225d4 55  56   .rodata         ascii   echo \"4096 65536 2097152\" > /proc/sys/net/ipv4/tcp_wmem\n524  0x0001a60c 0x0002260c 55  56   .rodata         ascii   echo \"4096 65536 2097152\" > /proc/sys/net/ipv4/tcp_rmem\n525  0x0001a644 0x00022644 48  49   .rodata         ascii   echo 400 > /proc/sys/net/core/netdev_max_backlog\n526  0x0001a678 0x00022678 12  13   .rodata         ascii   KC_BONJOUR &\n527  0x0001a688 0x00022688 10  11   .rodata         ascii   KC_PRINT &\n528  0x0001a694 0x00022694 15  16   .rodata         ascii   KC_BONJOUR %s &\n529  0x0001a6a4 0x000226a4 13  14   .rodata         ascii   KC_PRINT %s &\n530  0x0001a6b4 0x000226b4 21  22   .rodata         ascii   mkdir /tmp/media/nand\n531  0x0001a6cc 0x000226cc 9   10   .rodata         ascii   /proc/mtd\n532  0x0001a6d8 0x000226d8 6   7    .rodata         ascii   mtd%d:\n533  0x0001a6e0 0x000226e0 8   9    .rodata         ascii   brcmnand\n534  0x0001a6ec 0x000226ec 15  16   .rodata         ascii   /dev/mtdblock%d\n535  0x0001a6fc 0x000226fc 15  16   .rodata         ascii   /tmp/media/nand\n536  0x0001a70c 0x0002270c 43  44   .rodata         ascii   Erase nflash MTD partition and mount again\\n\n537  0x0001a738 0x00022738 40  41   .rodata         ascii   Erase nflash MTD partition %s failed %d\\n\n538  0x0001a764 0x00022764 49  50   .rodata         ascii   Mount nflash MTD jffs2 partition %s to %s failed\\n\n539  0x0001a798 0x00022798 27  28   .rodata         ascii   mkdir /tmp/media/nand/daapd\n540  0x0001a7b4 0x000227b4 4   5    .rodata         ascii   6to4\n541  0x0001a7bc 0x000227bc 50  51   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/br0/dad_transmits\n542  0x0001a7f0 0x000227f0 51  52   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/eth0/dad_transmits\n543  0x0001a824 0x00022824 17  18   .rodata         ascii   ifconfig br0 down\n544  0x0001a838 0x00022838 18  19   .rodata         ascii   ifconfig eth0 down\n545  0x0001a84c 0x0002284c 15  16   .rodata         ascii   ifconfig br0 up\n546  0x0001a85c 0x0002285c 16  17   .rodata         ascii   ifconfig eth0 up\n547  0x0001a870 0x00022870 67  68   .rodata         ascii   ifconfig eth0 add 3ffe:501:ffff:101:2%02x:%02xff:fe%02x:%02x%02x/64\n548  0x0001a8b4 0x000228b4 66  67   .rodata         ascii   ifconfig br0 add 3ffe:501:ffff:100:2%02x:%02xff:fe%02x:%02x%02x/64\n549  0x0001a8f8 0x000228f8 47  48   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/all/forwarding\n550  0x0001a928 0x00022928 56  57   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/all/accept_source_route\n551  0x0001a964 0x00022964 56  57   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/br0/accept_source_route\n552  0x0001a9a0 0x000229a0 57  58   .rodata         ascii   echo 1 > /proc/sys/net/ipv6/conf/eth0/accept_source_route\n553  0x0001a9dc 0x000229dc 25  26   .rodata         ascii   ifconfig eth0 99.99.99.99\n554  0x0001a9f8 0x000229f8 7   8    .rodata         ascii   run_mld\n555  0x0001aa00 0x00022a00 5   6    .rodata         ascii   mld &\n556  0x0001aa08 0x00022a08 16  17   .rodata         ascii   dhcp6s_readylogo\n557  0x0001aa1c 0x00022a1c 16  17   .rodata         ascii   dhcp6c_readylogo\n558  0x0001aa30 0x00022a30 4   5    .rodata         ascii   wpsd\n559  0x0001aa38 0x00022a38 8   9    .rodata         ascii   gpio 0 1\n560  0x0001aa44 0x00022a44 17  18   .rodata         ascii   rcagent_log_level\n561  0x0001aa58 0x00022a58 13  14   .rodata         ascii   leafp2p_debug\n562  0x0001aa68 0x00022a68 17  18   .rodata         ascii   leafp2p_service_0\n563  0x0001aa7c 0x00022a7c 113 114  .rodata         ascii   RouterRemote,0,1,1,0,1,6:135,6:136,6:137,6:138,6:139,6:445,6:548,17:135,17:136,17:137,17:138,17:139,17:445,17:548\n564  0x0001aaf0 0x00022af0 30  31   .rodata         ascii   leafp2p_connection_method_type\n565  0x0001ab10 0x00022b10 24  25   .rodata         ascii   leafp2p_peer_router_type\n566  0x0001ab2c 0x00022b2c 14  15   .rodata         ascii   killall xagent\n567  0x0001ab3c 0x00022b3c 25  26   .rodata         ascii   /opt/xagent/run-xagent.sh\n568  0x0001ab58 0x00022b58 27  28   .rodata         ascii   ++++++ run-xagnet.sh ++++++\n569  0x0001ab74 0x00022b74 19  20   .rodata         ascii   weather_band_enable\n570  0x0001ab88 0x00022b88 43  44   .rodata         ascii   ifconfig | grep eth0 > /tmp/check_et_module\n571  0x0001abb4 0x00022bb4 20  21   .rodata         ascii   /tmp/check_et_module\n572  0x0001abcc 0x00022bcc 36  37   .rodata         ascii   ++++++ check et driver (%d) ++++++\\n\\n\n573  0x0001abf4 0x00022bf4 15  16   .rodata         ascii   et_reboot_times\n574  0x0001ac04 0x00022c04 49  50   .rodata         ascii   ++++++ No et module, (%d) Reboot DUT now ++++++\\n\\n\n575  0x0001ac38 0x00022c38 6   7    .rodata         ascii   reboot\n576  0x0001ac40 0x00022c40 44  45   .rodata         ascii   ++++++ et module Register Fail (%d) ++++++\\n\\n\n577  0x0001ac70 0x00022c70 4   5    .rodata         ascii   stop\n578  0x0001ac78 0x00022c78 11  12   .rodata         ascii   restart_wan\n579  0x0001ac84 0x00022c84 10  11   .rodata         ascii   start_ripd\n580  0x0001ac90 0x00022c90 9   10   .rodata         ascii   stop_ripd\n581  0x0001ac9c 0x00022c9c 11  12   .rodata         ascii   delStaRoute\n582  0x0001aca8 0x00022ca8 11  12   .rodata         ascii   wan_restart\n583  0x0001acb4 0x00022cb4 12  13   .rodata         ascii   restart_ipv6\n584  0x0001acc8 0x00022cc8 14  15   .rodata         ascii   restart_dhcp6s\n585  0x0001acd8 0x00022cd8 14  15   .rodata         ascii   killall dhcp6s\n586  0x0001ace8 0x00022ce8 13  14   .rodata         ascii   killall radvd\n587  0x0001acf8 0x00022cf8 52  53   .rodata         ascii   usage: rc [start|stop|restart|start_ripd|stop_ripd]\\n\n588  0x0001ad30 0x00022d30 5   6    .rodata         ascii   ip-up\n589  0x0001ad38 0x00022d38 7   8    .rodata         ascii   ip-down\n590  0x0001ad40 0x00022d40 6   7    .rodata         ascii   udhcpc\n591  0x0001ad48 0x00022d48 9   10   .rodata         ascii   dhcp6c_up\n592  0x0001ad54 0x00022d54 11  12   .rodata         ascii   dhcp6c_down\n593  0x0001ad60 0x00022d60 12  13   .rodata         ascii   ipv6-conntab\n594  0x0001ad70 0x00022d70 17  18   .rodata         ascii   autoconfig_wan_up\n595  0x0001ad84 0x00022d84 19  20   .rodata         ascii   autoconfig_wan_down\n596  0x0001ad98 0x00022d98 17  18   .rodata         ascii   ipv6_drop_all_pkt\n597  0x0001adac 0x00022dac 5   6    .rodata         ascii   lanup\n598  0x0001adb4 0x00022db4 7   8    .rodata         ascii   landown\n599  0x0001adbc 0x00022dbc 27  28   .rodata         ascii   ipv6_enable_wan_ping_to_lan\n600  0x0001add8 0x00022dd8 8   9    .rodata         ascii   internet\n601  0x0001ade4 0x00022de4 6   7    .rodata         ascii   system\n602  0x0001adec 0x00022dec 20  21   .rodata         ascii   Unknown action: %s!\\n\n603  0x0001ae04 0x00022e04 4   5    .rodata         ascii   gpio\n604  0x0001ae10 0x00022e10 10  11   .rodata         ascii   mac_record\n605  0x0001ae1c 0x00022e1c 10  11   .rodata         ascii   ntp_record\n606  0x0001aea8 0x00022ea8 4   20   .rodata         utf32le \\b\\r\\a\\v\n607  0x0001aecc 0x00022ecc 17  18   .rodata         ascii   Caught signal %d\\n\n608  0x0001aee0 0x00022ee0 33  34   .rodata         ascii   Sending SIGTERM to all processes\\n\n609  0x0001af04 0x00022f04 33  34   .rodata         ascii   Sending SIGKILL to all processes\\n\n610  0x0001af28 0x00022f28 4   5    .rodata         ascii   Quit\n611  0x0001af30 0x00022f30 19  20   .rodata         ascii   Illegal instruction\n612  0x0001af44 0x00022f44 10  11   .rodata         ascii   Trace trap\n613  0x0001af50 0x00022f50 5   6    .rodata         ascii   Abort\n614  0x0001af58 0x00022f58 9   10   .rodata         ascii   Bus error\n615  0x0001af64 0x00022f64 18  19   .rodata         ascii   Floating exception\n616  0x0001af78 0x00022f78 21  22   .rodata         ascii   User-defined signal 1\n617  0x0001af90 0x00022f90 18  19   .rodata         ascii   Segmentation fault\n618  0x0001afa4 0x00022fa4 11  12   .rodata         ascii   Broken pipe\n619  0x0001afb0 0x00022fb0 10  11   .rodata         ascii   Terminated\n620  0x0001afbc 0x00022fbc 13  14   .rodata         ascii   Power failure\n621  0x0001afcc 0x00022fcc 15  16   .rodata         ascii   Bad system call\n622  0x0001b058 0x00023058 23  24   .rodata         ascii   [Internet disconnected]\n623  0x0001b0a4 0x000230a4 6   7    .rodata         ascii   wan_up\n624  0x0001b0b4 0x000230b4 11  12   .rodata         ascii   restart_wan\n625  0x0001b0c0 0x000230c0 9   10   .rodata         ascii   start_wan\n626  0x0001b0cc 0x000230cc 16  17   .rodata         ascii   /tmp/resolv.conf\n627  0x0001b0e0 0x000230e0 22  23   .rodata         ascii   fopen /tmp/resolv.conf\n628  0x0001b0f8 0x000230f8 15  16   .rodata         ascii   /tmp/resolv.tmp\n629  0x0001b108 0x00023108 21  22   .rodata         ascii   fopen /tmp/resolv.tmp\n630  0x0001b124 0x00023124 10  11   .rodata         ascii   nameserver\n631  0x0001b130 0x00023130 11  12   .rodata         ascii   wan_dns_sel\n632  0x0001b13c 0x0002313c 9   10   .rodata         ascii   wan2_dns1\n633  0x0001b148 0x00023148 8   9    .rodata         ascii   wan2_dns\n634  0x0001b154 0x00023154 8   9    .rodata         ascii   wan_dns1\n635  0x0001b160 0x00023160 7   8    .rodata         ascii   wan_dns\n636  0x0001b16c 0x0002316c 14  15   .rodata         ascii   nameserver %s\\n\n637  0x0001b180 0x00023180 7   8    .rodata         ascii   killall\n638  0x0001b188 0x00023188 7   8    .rodata         ascii   dnsmasq\n639  0x0001b190 0x00023190 25  26   .rodata         ascii   /tmp/resolv_session2.conf\n640  0x0001b1ac 0x000231ac 17  18   .rodata         ascii   /dev/acos_nat_cli\n641  0x0001b1c4 0x000231c4 30  31   .rodata         ascii   error setting ipaddress %08x.\\n\n642  0x0001b1e4 0x000231e4 10  11   .rodata         ascii   wan_ifname\n643  0x0001b1f0 0x000231f0 11  12   .rodata         ascii   /tmp/udhcpc\n644  0x0001b1fc 0x000231fc 14  15   .rodata         ascii   /tmp/ppp/ip-up\n645  0x0001b20c 0x0002320c 16  17   .rodata         ascii   /tmp/ppp/ip-down\n646  0x0001b220 0x00023220 4   5    .rodata         ascii   XXXX\n647  0x0001b228 0x00023228 15  16   .rodata         ascii   /proc/net/route\n648  0x0001b238 0x00023238 29  30   .rodata         ascii   %s %08x %08x %d %d %d %d %08x\n649  0x0001b258 0x00023258 12  13   .rodata         ascii   wan2_dns_sel\n650  0x0001b268 0x00023268 18  19   .rodata         ascii   static_pptp_enable\n651  0x0001b27c 0x0002327c 13  14   .rodata         ascii   pptp_dhcp_dns\n652  0x0001b28c 0x0002328c 18  19   .rodata         ascii   static_l2tp_enable\n653  0x0001b2a0 0x000232a0 13  14   .rodata         ascii   l2tp_dhcp_dns\n654  0x0001b2b0 0x000232b0 19  20   .rodata         ascii   static_pppoe_enable\n655  0x0001b2c4 0x000232c4 12  13   .rodata         ascii   pptp_gateway\n656  0x0001b2d4 0x000232d4 15  16   .rodata         ascii   l2tp_gateway_ip\n657  0x0001b2e4 0x000232e4 14  15   .rodata         ascii   pppoe_dhcp_dns\n658  0x0001b2f4 0x000232f4 5   6    .rodata         ascii   fixed\n659  0x0001b2fc 0x000232fc 12  13   .rodata         ascii   ipv6_pri_dns\n660  0x0001b30c 0x0002330c 12  13   .rodata         ascii   ipv6_sec_dns\n661  0x0001b31c 0x0002331c 9   10   .rodata         ascii   127.0.0.1\n662  0x0001b328 0x00023328 15  16   .rodata         ascii   255.255.255.255\n663  0x0001b338 0x00023338 28  29   .rodata         ascii   Bypass special address '%s'\\n\n664  0x0001b358 0x00023358 15  16   .rodata         ascii   /tmp/resolv.ppp\n665  0x0001b368 0x00023368 11  12   .rodata         ascii   wan_gateway\n666  0x0001b374 0x00023374 10  11   .rodata         ascii   lan_ifname\n667  0x0001b380 0x00023380 12  13   .rodata         ascii   pptp_serv_ip\n668  0x0001b390 0x00023390 18  19   .rodata         ascii   /tmp/ppp/pptpSrvIp\n669  0x0001b3a4 0x000233a4 18  19   .rodata         ascii   route del %s gw %s\n670  0x0001b3b8 0x000233b8 26  27   .rodata         ascii   route add default dev ppp0\n671  0x0001b3d4 0x000233d4 17  18   .rodata         ascii   pptp_user_netmask\n672  0x0001b3e8 0x000233e8 24  25   .rodata         ascii   route add -host %s gw %s\n673  0x0001b404 0x00023404 12  13   .rodata         ascii   l2tp_serv_ip\n674  0x0001b414 0x00023414 18  19   .rodata         ascii   /tmp/ppp/l2tpSrvIp\n675  0x0001b428 0x00023428 17  18   .rodata         ascii   l2tp_user_netmask\n676  0x0001b43c 0x0002343c 4   5    .rodata         ascii   dhcp\n677  0x0001b444 0x00023444 21  22   .rodata         ascii   /tmp/auto_disconn_log\n678  0x0001b45c 0x0002345c 54  55   .rodata         ascii   [Internet disconnected] 24hr automatic disconnection.\n679  0x0001b494 0x00023494 6   7    .rodata         ascii   wan%d_\n680  0x0001b49c 0x0002349c 14  15   .rodata         ascii   wanXXXXXXXXXX_\n681  0x0001b4ac 0x000234ac 16  17   .rodata         ascii   pppoe_policy_num\n682  0x0001b4c0 0x000234c0 14  15   .rodata         ascii   pppoe_policy%d\n683  0x0001b4d8 0x000234d8 7   8    .rodata         ascii   TCP/UDP\n684  0x0001b4e0 0x000234e0 5   6    .rodata         ascii   NULL,\n685  0x0001b4e8 0x000234e8 13  14   .rodata         ascii   qos_bw_enable\n686  0x0001b4f8 0x000234f8 11  12   .rodata         ascii   /tmp/tc_cmd\n687  0x0001b504 0x00023504 13  14   .rodata         ascii   TC is active.\n688  0x0001b514 0x00023514 37  38   .rodata         ascii   %s is NOT exist!! TC is NOT active!!\\n\n689  0x0001b53c 0x0002353c 19  20   .rodata         ascii   acosnat_ctf_disable\n690  0x0001b550 0x00023550 9   10   .rodata         ascii   bs_enable\n691  0x0001b55c 0x0002355c 14  15   .rodata         ascii   traffic_enable\n692  0x0001b56c 0x0002356c 16  17   .rodata         ascii   video_qos_enable\n693  0x0001b580 0x00023580 25  26   .rodata         ascii   qos_down_streaming_enable\n694  0x0001b59c 0x0002359c 19  20   .rodata         ascii   access_control_mode\n695  0x0001b5b0 0x000235b0 27  28   .rodata         ascii   acosnat_nat4lanonly_disable\n696  0x0001b5cc 0x000235cc 20  21   .rodata         ascii   route delete default\n697  0x0001b5e4 0x000235e4 24  25   .rodata         ascii   route add default dev %s\n698  0x0001b600 0x00023600 25  26   .rodata         ascii   route add -host %s dev %s\n699  0x0001b61c 0x0002361c 23  24   .rodata         ascii   route add default gw %s\n700  0x0001b634 0x00023634 18  19   .rodata         ascii   /var/run/ddnsd.pid\n701  0x0001b648 0x00023648 14  15   .rodata         ascii   wla_wds_enable\n702  0x0001b658 0x00023658 12  13   .rodata         ascii   wla_wds_mode\n703  0x0001b668 0x00023668 14  15   .rodata         ascii   wlg_wds_enable\n704  0x0001b678 0x00023678 12  13   .rodata         ascii   wlg_wds_mode\n705  0x0001b688 0x00023688 23  24   .rodata         ascii   killall -SIGWINCH httpd\n706  0x0001b6a0 0x000236a0 36  37   .rodata         ascii   [Internet connected] IP address: %s,\n707  0x0001b6c8 0x000236c8 25  26   .rodata         ascii   killall -SIGUSR2 check_fw\n708  0x0001b6e4 0x000236e4 14  15   .rodata         ascii   wan_ipaddr_old\n709  0x0001b6f4 0x000236f4 44  45   .rodata         ascii   %s: IP addr changed! (%s->%s) do arp_check!\\n\n710  0x0001b724 0x00023724 26  27   .rodata         ascii   killall -SIGUSR1 arp_check\n711  0x0001b740 0x00023740 48  49   .rodata         ascii   %s: IP addr NOT changed! (%s->%s) do arp_check!\\n\n712  0x0001b774 0x00023774 10  11   .rodata         ascii   rip_enable\n713  0x0001b780 0x00023780 16  17   .rodata         ascii   ipv6rd_auto_mode\n714  0x0001b798 0x00023798 4   5    .rodata         ascii   eth0\n715  0x0001b7a0 0x000237a0 8   9    .rodata         ascii   ifconfig\n716  0x0001b7ac 0x000237ac 5   6    .rodata         ascii   brctl\n717  0x0001b7b4 0x000237b4 5   6    .rodata         ascii   addif\n718  0x0001b7bc 0x000237bc 8   9    .rodata         ascii   /tmp/ppp\n719  0x0001b7c8 0x000237c8 18  19   .rodata         ascii   /sbin/acos_service\n720  0x0001b7dc 0x000237dc 14  15   .rodata         ascii   /tmp/ppp/peers\n721  0x0001b7ec 0x000237ec 17  18   .rodata         ascii   /usr/sbin/pppoecd\n722  0x0001b800 0x00023800 13  14   .rodata         ascii   /tmp/pppoecd2\n723  0x0001b810 0x00023810 11  12   .rodata         ascii   wan_netmask\n724  0x0001b81c 0x0002381c 22  23   .rodata         ascii   hidden_page_debug_ipv6\n725  0x0001b834 0x00023834 4   5    .rodata         ascii   auto\n726  0x0001b83c 0x0002383c 107 108  .rodata         ascii   tcpdump -i eth0 'ether[12:2] != 0x8100' and 'ether[14:2] != 0x0001' -w /tmp/IPv6_autodetect.cap -C 5 -W 3 &\n727  0x0001b8b4 0x000238b4 20  21   .rodata         ascii   /var/run/udhcpc0.pid\n728  0x0001b8d0 0x000238d0 7   8    .rodata         ascii   bpa_dod\n729  0x0001b8d8 0x000238d8 11  12   .rodata         ascii   bpa_monitor\n730  0x0001b8e4 0x000238e4 8   9    .rodata         ascii   run_test\n731  0x0001b8f0 0x000238f0 21  22   .rodata         ascii   /var/run/udhcpc%d.pid\n732  0x0001b908 0x00023908 24  25   .rodata         ascii   Start DHCP client daemon\n733  0x0001b924 0x00023924 13  14   .rodata         ascii   pppoe_user_ip\n734  0x0001b934 0x00023934 18  19   .rodata         ascii   pppoe_localnetmask\n735  0x0001b948 0x00023948 27  28   .rodata         ascii   %s: Unknown protocol (%s)!\\n\n736  0x0001b964 0x00023964 7   8    .rodata         ascii   /bin/sh\n737  0x0001b974 0x00023974 8   9    .rodata         ascii   bpalogin\n738  0x0001b980 0x00023980 7   8    .rodata         ascii   pppoecd\n739  0x0001b988 0x00023988 9   10   .rodata         ascii   ntpclient\n740  0x0001b9f4 0x000239f4 4   5    .rodata         ascii   tun0\n741  0x0001b9fc 0x000239fc 13  14   .rodata         ascii   start_openvpn\n742  0x0001baac 0x00023aac 18  19   .rodata         ascii   ipv6rd_wan_dns_sel\n743  0x0001bac0 0x00023ac0 10  11   .rodata         ascii   autoconfig\n744  0x0001bacc 0x00023acc 15  16   .rodata         ascii   ipv6_proto_auto\n745  0x0001badc 0x00023adc 28  29   .rodata         ascii   Invalid prefix length (%d)!\\n\n746  0x0001bafc 0x00023afc 17  18   .rodata         ascii   video_qos_bwh_min\n747  0x0001bb14 0x00023b14 30  31   .rodata         ascii   video_qos_delta_bwl_pickup_min\n748  0x0001bb38 0x00023b38 22  23   .rodata         ascii   video_qos_zero_traffic\n749  0x0001bb54 0x00023b54 11  12   .rodata         ascii   debug_video\n750  0x0001bb60 0x00023b60 22  23   .rodata         ascii   /tmp/video_streaming &\n751  0x0001bb78 0x00023b78 20  21   .rodata         ascii   debug_downstream_qos\n752  0x0001bb90 0x00023b90 28  29   .rodata         ascii   /tmp/downstream_qos_log.fifo\n753  0x0001bbb0 0x00023bb0 27  28   .rodata         ascii   /tmp/downstream_qos_log.txt\n754  0x0001bbcc 0x00023bcc 22  23   .rodata         ascii   /usr/sbin/qos_test 3 1\n755  0x0001bbe4 0x00023be4 58  59   .rodata         ascii   /usr/sbin/video_streaming > /tmp/downstream_qos_log.fifo &\n756  0x0001bc20 0x00023c20 22  23   .rodata         ascii   /usr/sbin/qos_test 3 0\n757  0x0001bc38 0x00023c38 27  28   .rodata         ascii   /usr/sbin/video_streaming &\n758  0x0001bc54 0x00023c54 8   9    .rodata         ascii   check_db\n759  0x0001bc60 0x00023c60 8   9    .rodata         ascii   swresetd\n760  0x0001bc6c 0x00023c6c 35  36   .rodata         ascii   /sbin/tmd -t 5 -p /tmp/tmsync.pid &\n761  0x0001bc90 0x00023c90 10  11   .rodata         ascii   arp_enable\n762  0x0001bc9c 0x00023c9c 12  13   .rodata         ascii   arp -s %s %s\n763  0x0001bcac 0x00023cac 11  12   .rodata         ascii   %d.%d.%d.%d\n764  0x0001bcb8 0x00023cb8 16  17   .rodata         ascii   %02x%02x%02x%02x\n765  0x0001bccc 0x00023ccc 9   10   .rodata         ascii   lan_proto\n766  0x0001bcd8 0x00023cd8 18  19   .rodata         ascii   /tmp/udhcpd.leases\n767  0x0001bcec 0x00023cec 16  17   .rodata         ascii   /tmp/udhcpd.conf\n768  0x0001bd00 0x00023d00 24  25   .rodata         ascii   pidfile /tmp/udhcpd.pid\\n\n769  0x0001bd1c 0x00023d1c 10  11   .rodata         ascii   dhcp_start\n770  0x0001bd28 0x00023d28 9   10   .rodata         ascii   start %s\\n\n771  0x0001bd34 0x00023d34 8   9    .rodata         ascii   dhcp_end\n772  0x0001bd40 0x00023d40 7   8    .rodata         ascii   end %s\\n\n773  0x0001bd48 0x00023d48 13  14   .rodata         ascii   interface %s\\n\n774  0x0001bd58 0x00023d58 14  15   .rodata         ascii   remaining yes\\n\n775  0x0001bd68 0x00023d68 30  31   .rodata         ascii   lease_file /tmp/udhcpd.leases\\n\n776  0x0001bd88 0x00023d88 11  12   .rodata         ascii   lan_netmask\n777  0x0001bd94 0x00023d94 17  18   .rodata         ascii   option subnet %s\\n\n778  0x0001bda8 0x00023da8 10  11   .rodata         ascii   lan_ipaddr\n779  0x0001bdb4 0x00023db4 17  18   .rodata         ascii   option router %s\\n\n780  0x0001bdc8 0x00023dc8 14  15   .rodata         ascii   option dns %s\\n\n781  0x0001bdd8 0x00023dd8 9   10   .rodata         ascii   lan_lease\n782  0x0001bde4 0x00023de4 16  17   .rodata         ascii   option lease %s\\n\n783  0x0001bdf8 0x00023df8 9   10   .rodata         ascii   dhcp_wins\n784  0x0001be04 0x00023e04 7   8    .rodata         ascii   %s_wins\n785  0x0001be0c 0x00023e0c 15  16   .rodata         ascii   option wins %s\\n\n786  0x0001be1c 0x00023e1c 11  12   .rodata         ascii   dhcp_domain\n787  0x0001be28 0x00023e28 9   10   .rodata         ascii   %s_domain\n788  0x0001be34 0x00023e34 17  18   .rodata         ascii   option domain %s\\n\n789  0x0001be48 0x00023e48 22  23   .rodata         ascii   /tmp/udhcpd_resrv.conf\n790  0x0001be60 0x00023e60 13  14   .rodata         ascii   dhcp_resrv_ip\n791  0x0001be70 0x00023e70 14  15   .rodata         ascii   dhcp_resrv_mac\n792  0x0001be80 0x00023e80 19  20   .rodata         ascii   lanip_setup_changed\n793  0x0001be94 0x00023e94 6   7    .rodata         ascii   udhcpd\n794  0x0001beb4 0x00023eb4 4   5    .rodata         ascii   root\n795  0x0001bebc 0x00023ebc 108 109  .rodata         ascii   cat /tmp/openvpn_log_tun | grep 'TUN/TAP device' | tail -1 | cut -b 25- | cut -d ' ' -f 5 > /tmp/_tundevname\n796  0x0001bf2c 0x00023f2c 13  14   .rodata         ascii   openvpnActive\n797  0x0001bf3c 0x00023f3c 13  14   .rodata         ascii   ntp_is_synced\n798  0x0001bf4c 0x00023f4c 71  72   .rodata         ascii   [OPENVPN] NTP sync time failed. Get correct system time then reconnect.\n799  0x0001bf94 0x00023f94 19  20   .rodata         ascii   /tmp/openvpn/ca.crt\n800  0x0001bfa8 0x00023fa8 60  61   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/ca.crt /tmp/openvpn/ca.crt\n801  0x0001bfe8 0x00023fe8 23  24   .rodata         ascii   /tmp/openvpn/client.crt\n802  0x0001c000 0x00024000 68  69   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/client.crt /tmp/openvpn/client.crt\n803  0x0001c048 0x00024048 23  24   .rodata         ascii   /tmp/openvpn/client.key\n804  0x0001c060 0x00024060 68  69   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/client.key /tmp/openvpn/client.key\n805  0x0001c0a8 0x000240a8 23  24   .rodata         ascii   /tmp/openvpn/dh1024.pem\n806  0x0001c0c0 0x000240c0 68  69   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/dh1024.pem /tmp/openvpn/dh1024.pem\n807  0x0001c108 0x00024108 23  24   .rodata         ascii   /tmp/openvpn/server.crt\n808  0x0001c120 0x00024120 68  69   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/server.crt /tmp/openvpn/server.crt\n809  0x0001c168 0x00024168 23  24   .rodata         ascii   /tmp/openvpn/server.key\n810  0x0001c180 0x00024180 68  69   .rodata         ascii   cp -f /usr/local/share/foxconn_ca/server.key /tmp/openvpn/server.key\n811  0x0001c1c8 0x000241c8 24  25   .rodata         ascii   openvpn_service_port_tun\n812  0x0001c1e4 0x000241e4 20  21   .rodata         ascii   openvpn_service_port\n813  0x0001c1fc 0x000241fc 32  33   .rodata         ascii   %s: Error setting echo response\\n\n814  0x0001c220 0x00024220 34  35   .rodata         ascii   mknod -m0600 /dev/net/tun c 10 200\n815  0x0001c244 0x00024244 46  47   .rodata         ascii   /usr/local/sbin/openvpn /tmp/server_tap.conf &\n816  0x0001c274 0x00024274 46  47   .rodata         ascii   /usr/local/sbin/openvpn /tmp/server_tun.conf &\n817  0x0001c2a4 0x000242a4 20  21   .rodata         ascii   brctl addif br0 tap0\n818  0x0001c2bc 0x000242bc 32  33   .rodata         ascii   ifconfig tap0 0.0.0.0 promisc up\n819  0x0001c2e0 0x000242e0 23  24   .rodata         ascii   rm -rf /tmp/openvpn_zip\n820  0x0001c2f8 0x000242f8 22  23   .rodata         ascii   mkdir /tmp/openvpn_zip\n821  0x0001c310 0x00024310 123 124  .rodata         ascii   cp /tmp/client1.ovpn /tmp/openvpn/ca.crt /tmp/openvpn/client.crt /tmp/openvpn/client.key /tmp/client2.conf /tmp/openvpn_zip\n822  0x0001c38c 0x0002438c 66  67   .rodata         ascii   ps | grep openvpn | grep server | cut -d ' ' -f 1 | xargs kill -9\n823  0x0001c3d0 0x000243d0 15  16   .rodata         ascii   /tmp/igmprt.pid\n824  0x0001c3e0 0x000243e0 8   9    .rodata         ascii   gproxy &\n825  0x0001c3ec 0x000243ec 13  14   .rodata         ascii   restart_httpd\n826  0x0001c3fc 0x000243fc 18  19   .rodata         ascii   /var/run/dlnad.pid\n827  0x0001c410 0x00024410 15  16   .rodata         ascii   /tmp/dlnad.conf\n828  0x0001c420 0x00024420 7   8    .rodata         ascii   dlnad &\n829  0x0001c428 0x00024428 51  52   .rodata         ascii   httpd -S -E /usr/sbin/ca.pem /usr/sbin/httpsd.pem &\n830  0x0001c45c 0x0002445c 5   6    .rodata         ascii   upnpd\n831  0x0001c464 0x00024464 12  13   .rodata         ascii   killall upnp\n832  0x0001c474 0x00024474 12  13   .rodata         ascii   upnp_turn_on\n833  0x0001c484 0x00024484 19  20   .rodata         ascii   killall -9 timesync\n834  0x0001c498 0x00024498 28  29   .rodata         ascii   rm -rf /var/run/timesync.pid\n835  0x0001c4b8 0x000244b8 36  37   .rodata         ascii   /usr/sbin/timesync /sbin/ntpclient &\n836  0x0001c4e0 0x000244e0 5   6    .rodata         ascii   lld2d\n837  0x0001c4e8 0x000244e8 17  18   .rodata         ascii   qos_xbox_mac_down\n838  0x0001c4fc 0x000244fc 22  23   .rodata         ascii   qos_xbox_detected_down\n839  0x0001c514 0x00024514 10  11   .rodata         ascii   lld_xbox &\n840  0x0001c520 0x00024520 17  18   .rodata         ascii   dnsRedirectReplyd\n841  0x0001c534 0x00024534 12  13   .rodata         ascii   static_route\n842  0x0001c544 0x00024544 13  14   .rodata         ascii   rip_multicast\n843  0x0001c554 0x00024554 11  12   .rodata         ascii   /tmp/M.conf\n844  0x0001c560 0x00024560 15  16   .rodata         ascii   /tmp/zebra.conf\n845  0x0001c570 0x00024570 14  15   .rodata         ascii   /tmp/ripd.conf\n846  0x0001c580 0x00024580 7   8    .rodata         ascii   rip_dir\n847  0x0001c588 0x00024588 11  12   .rodata         ascii   router rip\\n\n848  0x0001c594 0x00024594 14  15   .rodata         ascii   no router rip\\n\n849  0x0001c5a4 0x000245a4 20  21   .rodata         ascii   redistribute kernel\\n\n850  0x0001c5bc 0x000245bc 23  24   .rodata         ascii   redistribute connected\\n\n851  0x0001c5d4 0x000245d4 20  21   .rodata         ascii   redistribute static\\n\n852  0x0001c5ec 0x000245ec 11  12   .rodata         ascii   network %s\\n\n853  0x0001c5f8 0x000245f8 11  12   .rodata         ascii   rip_version\n854  0x0001c604 0x00024604 22  23   .rodata         ascii   ip rip send version 2\\n\n855  0x0001c61c 0x0002461c 23  24   .rodata         ascii   ip rip send version %s\\n\n856  0x0001c634 0x00024634 26  27   .rodata         ascii   ip rip receive version %s\\n\n857  0x0001c650 0x00024650 33  34   .rodata         ascii   distribute-list private%s out %s\\n\n858  0x0001c674 0x00024674 33  34   .rodata         ascii   access-list private%s deny %s/%d\\n\n859  0x0001c698 0x00024698 32  33   .rodata         ascii   access-list private%s deny %s/8\\n\n860  0x0001c6bc 0x000246bc 33  34   .rodata         ascii   access-list private%s deny %s/16\\n\n861  0x0001c6e0 0x000246e0 33  34   .rodata         ascii   access-list private%s deny %s/24\\n\n862  0x0001c704 0x00024704 33  34   .rodata         ascii   access-list private%s permit any\\n\n863  0x0001c728 0x00024728 23  24   .rodata         ascii   no ip rip send version\\n\n864  0x0001c740 0x00024740 31  32   .rodata         ascii   access-list private%s deny any\\n\n865  0x0001c760 0x00024760 31  32   .rodata         ascii   distribute-list active%s in %s\\n\n866  0x0001c780 0x00024780 30  31   .rodata         ascii   access-list active%s deny any\\n\n867  0x0001c7a0 0x000247a0 13  14   .rodata         ascii   telnetenabled\n868  0x0001c7b0 0x000247b0 9   10   .rodata         ascii   heartbeat\n869  0x0001c7bc 0x000247bc 11  12   .rodata         ascii   wlanconfigd\n870  0x0001c7c8 0x000247c8 18  19   .rodata         ascii   /proc/net/if_inet6\n871  0x0001c7dc 0x000247dc 50  51   .rodata         ascii   %4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\n872  0x0001c814 0x00024814 23  24   .rodata         ascii   %s:%s:%s:%s:%s:%s:%s:%s\n873  0x0001c82c 0x0002482c 24  25   .rodata         ascii   lan_ipv6_link_local_addr\n874  0x0001c848 0x00024848 30  31   .rodata         ascii   lan_ipv6_link_local_addr_short\n875  0x0001c868 0x00024868 15  16   .rodata         ascii   /tmp/radvd.conf\n876  0x0001c878 0x00024878 15  16   .rodata         ascii   interface %s {\\n\n877  0x0001c888 0x00024888 19  20   .rodata         ascii    AdvSendAdvert on;\\n\n878  0x0001c89c 0x0002489c 17  18   .rodata         ascii   RA_AdvCurHopLimit\n879  0x0001c8b0 0x000248b0 20  21   .rodata         ascii    AdvCurHopLimit %s;\\n\n880  0x0001c8c8 0x000248c8 20  21   .rodata         ascii   RA_MinRtrAdvInterval\n881  0x0001c8e0 0x000248e0 23  24   .rodata         ascii    MinRtrAdvInterval %s;\\n\n882  0x0001c8f8 0x000248f8 20  21   .rodata         ascii   RA_MaxRtrAdvInterval\n883  0x0001c910 0x00024910 23  24   .rodata         ascii    MaxRtrAdvInterval %s;\\n\n884  0x0001c928 0x00024928 17  18   .rodata         ascii   RA_AdvManagedFlag\n885  0x0001c93c 0x0002493c 20  21   .rodata         ascii    AdvManagedFlag %s;\\n\n886  0x0001c954 0x00024954 21  22   .rodata         ascii   RA_AdvOtherConfigFlag\n887  0x0001c96c 0x0002496c 24  25   .rodata         ascii    AdvOtherConfigFlag %s;\\n\n888  0x0001c988 0x00024988 21  22   .rodata         ascii   RA_AdvDefaultLifetime\n889  0x0001c9a0 0x000249a0 24  25   .rodata         ascii    AdvDefaultLifetime %s;\\n\n890  0x0001c9bc 0x000249bc 19  20   .rodata         ascii   RA_AdvReachableTime\n891  0x0001c9d0 0x000249d0 22  23   .rodata         ascii    AdvReachableTime %s;\\n\n892  0x0001c9e8 0x000249e8 18  19   .rodata         ascii   RA_AdvRetransTimer\n893  0x0001c9fc 0x000249fc 21  22   .rodata         ascii    AdvRetransTimer %s;\\n\n894  0x0001ca14 0x00024a14 23  24   .rodata         ascii   RA_AdvDefaultPreference\n895  0x0001ca2c 0x00024a2c 26  27   .rodata         ascii    AdvDefaultPreference %s;\\n\n896  0x0001ca48 0x00024a48 23  24   .rodata         ascii    AdvHomeAgentFlag off;\\n\n897  0x0001ca60 0x00024a60 18  19   .rodata         ascii    AdvLinkMTU 1500;\\n\n898  0x0001ca74 0x00024a74 16  17   .rodata         ascii    prefix %s/%s {\\n\n899  0x0001ca88 0x00024a88 19  20   .rodata         ascii   3ffe:501:ffff:100::\n900  0x0001ca9c 0x00024a9c 12  13   .rodata         ascii   RA_AdvOnLink\n901  0x0001caac 0x00024aac 16  17   .rodata         ascii     AdvOnLink %s;\\n\n902  0x0001cac0 0x00024ac0 16  17   .rodata         ascii   RA_AdvAutonomous\n903  0x0001cad4 0x00024ad4 20  21   .rodata         ascii     AdvAutonomous %s;\\n\n904  0x0001caec 0x00024aec 19  20   .rodata         ascii   RA_AdvValidLifetime\n905  0x0001cb00 0x00024b00 23  24   .rodata         ascii     AdvValidLifetime %s;\\n\n906  0x0001cb18 0x00024b18 23  24   .rodata         ascii   RA_AdvPreferredLifetime\n907  0x0001cb30 0x00024b30 27  28   .rodata         ascii     AdvPreferredLifetime %s;\\n\n908  0x0001cb4c 0x00024b4c 4   5    .rodata         ascii    };\\n\n909  0x0001cb58 0x00024b58 19  20   .rodata         ascii   3ffe:501:ffff:101::\n910  0x0001cb6c 0x00024b6c 4   5    .rodata         ascii   };\\n\\n\n911  0x0001cb74 0x00024b74 18  19   .rodata         ascii   radvd -d 1 -C %s &\n912  0x0001cb88 0x00024b88 27  28   .rodata         ascii    AdvDefaultPreference low;\\n\n913  0x0001cba4 0x00024ba4 14  15   .rodata         ascii   ipv6rd_wan_mtu\n914  0x0001cbb4 0x00024bb4 16  17   .rodata         ascii    AdvLinkMTU %s;\\n\n915  0x0001cbc8 0x00024bc8 15  16   .rodata         ascii   ipv6_lan_ipaddr\n916  0x0001cbd8 0x00024bd8 16  17   .rodata         ascii   ipv6_6to4_sla_id\n917  0x0001cbec 0x00024bec 24  25   .rodata         ascii    prefix 0:0:0:%x::/64 {\\n\n918  0x0001cc08 0x00024c08 21  22   .rodata         ascii     AdvRouterAddr off;\\n\n919  0x0001cc20 0x00024c20 24  25   .rodata         ascii     Base6to4Interface %s;\\n\n920  0x0001cc3c 0x00024c3c 15  16   .rodata         ascii   ipv6_lan_length\n921  0x0001cc4c 0x00024c4c 13  14   .rodata         ascii    prefix %s {\\n\n922  0x0001cc5c 0x00024c5c 23  24   .rodata         ascii   RA_use_dynamic_lifetime\n923  0x0001cc74 0x00024c74 29  30   .rodata         ascii   RA_AdvValidLifetime_from_IAPD\n924  0x0001cc94 0x00024c94 33  34   .rodata         ascii   RA_AdvPreferredLifetime_from_IAPD\n925  0x0001ccb8 0x00024cb8 25  26   .rodata         ascii   radvd_lan_obsolete_ipaddr\n926  0x0001ccd4 0x00024cd4 32  33   .rodata         ascii   radvd_lan_obsolete_ipaddr_length\n927  0x0001ccf8 0x00024cf8 16  17   .rodata         ascii     AdvOnLink on;\\n\n928  0x0001cd0c 0x00024d0c 21  22   .rodata         ascii     AdvAutonomous off;\\n\n929  0x0001cd24 0x00024d24 25  26   .rodata         ascii   lan_ipv6_link_local_addr1\n930  0x0001cd40 0x00024d40 12  13   .rodata         ascii    RDNSS %s {\\n\n931  0x0001cd50 0x00024d50 24  25   .rodata         ascii     AdvRDNSSPreference 0;\\n\n932  0x0001cd6c 0x00024d6c 24  25   .rodata         ascii     AdvRDNSSLifetime %lu;\\n\n933  0x0001cd88 0x00024d88 38  39   .rodata         ascii   /proc/sys/net/ipv6/conf/all/forwarding\n934  0x0001cdb0 0x00024db0 21  22   .rodata         ascii   radvd -d 1 -D -C %s &\n935  0x0001cdc8 0x00024dc8 21  22   .rodata         ascii   /tmp/radvd_debug.fifo\n936  0x0001cde0 0x00024de0 20  21   .rodata         ascii   /tmp/radvd_debug.txt\n937  0x0001cdf8 0x00024df8 40  41   .rodata         ascii   echo '========' >> /tmp/radvd_debug.fifo\n938  0x0001ce24 0x00024e24 56  57   .rodata         ascii   radvd -d 9 -D -m stderr -C %s 2>>/tmp/radvd_debug.fifo &\n939  0x0001ce60 0x00024e60 53  54   .rodata         ascii   radvd -d 9 -m stderr -C %s 2>>/tmp/radvd_debug.fifo &\n940  0x0001ce98 0x00024e98 16  17   .rodata         ascii   /tmp/dhcp6s.conf\n941  0x0001ceac 0x00024eac 19  20   .rodata         ascii   /tmp/server6.leases\n942  0x0001cec0 0x00024ec0 24  25   .rodata         ascii   option dns_servers %s ;\\n\n943  0x0001cedc 0x00024edc 16  17   .rodata         ascii   ipv6_sip_servers\n944  0x0001cef0 0x00024ef0 24  25   .rodata         ascii   option sip_servers %s ;\\n\n945  0x0001cf0c 0x00024f0c 16  17   .rodata         ascii   ipv6_ntp_servers\n946  0x0001cf20 0x00024f20 24  25   .rodata         ascii   option ntp_servers %s ;\\n\n947  0x0001cf3c 0x00024f3c 20  21   .rodata         ascii   lan_dhcpsv6_lifetime\n948  0x0001cf54 0x00024f54 17  18   .rodata         ascii   renew-time %lu ;\\n\n949  0x0001cf68 0x00024f68 18  19   .rodata         ascii   rebind-time %lu ;\\n\n950  0x0001cf7c 0x00024f7c 22  23   .rodata         ascii   prefer-life-time %s ;\\n\n951  0x0001cf94 0x00024f94 21  22   .rodata         ascii   valid-life-time %s ;\\n\n952  0x0001cfac 0x00024fac 21  22   .rodata         ascii   allow rapid-commit ;\\n\n953  0x0001cfc4 0x00024fc4 18  19   .rodata         ascii   lan_dhcpsv6_enable\n954  0x0001cfd8 0x00024fd8 23  24   .rodata         ascii   send information-only;\\n\n955  0x0001cff0 0x00024ff0 11  12   .rodata         ascii   link LAN {\\n\n956  0x0001cffc 0x00024ffc 7   8    .rodata         ascii   pool {\\n\n957  0x0001d004 0x00025004 4   5    .rodata         ascii   1000\n958  0x0001d00c 0x0002500c 4   5    .rodata         ascii   2000\n959  0x0001d014 0x00025014 19  20   .rodata         ascii   range %s to %s/%s;\\n\n960  0x0001d028 0x00025028 22  23   .rodata         ascii   /tmp/dhcp6s_debug.fifo\n961  0x0001d040 0x00025040 21  22   .rodata         ascii   /tmp/dhcp6s_debug.txt\n962  0x0001d058 0x00025058 45  46   .rodata         ascii   echo '==========' >> /tmp/dhcp6s_debug.fifo &\n963  0x0001d088 0x00025088 60  61   .rodata         ascii   dhcp6s -f -D -c /tmp/dhcp6s.conf 2>>/tmp/dhcp6s_debug.fifo &\n964  0x0001d0c8 0x000250c8 16  17   .rodata         ascii   killall check_fw\n965  0x0001d0dc 0x000250dc 17  18   .rodata         ascii   killall arp_check\n966  0x0001d0f0 0x000250f0 14  15   .rodata         ascii   killall mevent\n967  0x0001d100 0x00025100 30  31   .rodata         ascii   sh /etc/init.d/remote.sh start\n968  0x0001d120 0x00025120 31  32   .rodata         ascii   sh /etc/init.d/brokerd.sh start\n969  0x0001d140 0x00025140 31  32   .rodata         ascii   sh /etc/init.d/leafp2p.sh start\n970  0x0001d160 0x00025160 29  30   .rodata         ascii   sh /etc/init.d/remote.sh stop\n971  0x0001d180 0x00025180 30  31   .rodata         ascii   sh /etc/init.d/brokerd.sh stop\n972  0x0001d1a0 0x000251a0 30  31   .rodata         ascii   sh /etc/init.d/leafp2p.sh stop\n973  0x0001d1c0 0x000251c0 14  15   .rodata         ascii   hd_idle_period\n974  0x0001d1d0 0x000251d0 13  14   .rodata         ascii   hd_idle_debug\n975  0x0001d1e0 0x000251e0 16  17   .rodata         ascii   hd-idle -i %d %s\n976  0x0001d1f4 0x000251f4 19  20   .rodata         ascii   -l /tmp/hd-idle.log\n977  0x0001d208 0x00025208 15  16   .rodata         ascii   killall hd-idle\n978  0x0001d218 0x00025218 9   10   .rodata         ascii   ap_dyn_ip\n979  0x0001d224 0x00025224 7   8    .rodata         ascii   autoipd\n980  0x0001d22c 0x0002522c 12  13   .rodata         ascii   sche_tmp_set\n981  0x0001d23c 0x0002523c 7   8    .rodata         ascii   scheact\n982  0x0001d244 0x00025244 15  16   .rodata         ascii   /usr/sbin/email\n983  0x0001d254 0x00025254 25  26   .rodata         ascii   et robowr 0xFFFF 0xFC 0x1\n984  0x0001d270 0x00025270 38  39   .rodata         ascii   [Initialized, firmware version: %s_%s]\n985  0x0001d298 0x00025298 20  21   .rodata         ascii   Init log send failed\n986  0x0001d2b0 0x000252b0 25  26   .rodata         ascii   et robowr 0xFFFF 0xFC 0x0\n987  0x0001d2cc 0x000252cc 20  21   .rodata         ascii   /usr/sbin/acl_logd &\n988  0x0001d2e4 0x000252e4 4   5    .rodata         ascii   ripd\n989  0x0001d2ec 0x000252ec 5   6    .rodata         ascii   zebra\n990  0x0001d2fc 0x000252fc 5   6    .rodata         ascii   ddnsd\n991  0x0001d304 0x00025304 8   9    .rodata         ascii   lld_xbox\n992  0x0001d310 0x00025310 7   8    .rodata         ascii    gproxy\n993  0x0001d318 0x00025318 7   8    .rodata         ascii   tfmeter\n994  0x0001d320 0x00025320 9   10   .rodata         ascii   readstats\n995  0x0001d32c 0x0002532c 23  24   .rodata         ascii   [Internet disconnected]\n996  0x0001d36c 0x0002536c 22  23   .rodata         ascii   static routes overlap!\n997  0x0001d384 0x00025384 20  21   .rodata         ascii   /tmp/udhcpc0.expires\n998  0x0001d39c 0x0002539c 23  24   .rodata         ascii   /tmp/delDhcpOptionRoute\n999  0x0001d3b4 0x000253b4 28  29   .rodata         ascii   route del -net %s netmask %s\n1000 0x0001d3d4 0x000253d4 34  35   .rodata         ascii   route add -net %s netmask %s gw %s\n1001 0x0001d3f8 0x000253f8 30  31   .rodata         ascii   route -n > /tmp/formerRouteTbl\n1002 0x0001d418 0x00025418 19  20   .rodata         ascii   /tmp/formerRouteTbl\n1003 0x0001d42c 0x0002542c 9   10   .rodata         ascii   127.0.0.0\n1004 0x0001d438 0x00025438 15  16   .rodata         ascii   %s %s %s %s %*s\n1005 0x0001d448 0x00025448 64  65   .rodata         ascii   echo 'route del -net %s netmask %s' >> /tmp/delDhcpOptionRoute &\n1006 0x0001d48c 0x0002548c 9   10   .rodata         ascii   interface\n1007 0x0001d498 0x00025498 14  15   .rodata         ascii   apmode_gateway\n1008 0x0001d4a8 0x000254a8 18  19   .rodata         ascii   pppoe_localgateway\n1009 0x0001d4bc 0x000254bc 12  13   .rodata         ascii   dhcp_serv_ip\n1010 0x0001d4cc 0x000254cc 12  13   .rodata         ascii   pptp_user_ip\n1011 0x0001d4dc 0x000254dc 12  13   .rodata         ascii   l2tp_user_ip\n1012 0x0001d4ec 0x000254ec 6   7    .rodata         ascii   subnet\n1013 0x0001d4f4 0x000254f4 6   7    .rodata         ascii   router\n1014 0x0001d4fc 0x000254fc 10  11   .rodata         ascii   ap_dyn_dns\n1015 0x0001d508 0x00025508 11  12   .rodata         ascii   apmode_dns1\n1016 0x0001d514 0x00025514 28  29   .rodata         ascii   killall zeroconf 2>/dev/null\n1017 0x0001d534 0x00025534 36  37   .rodata         ascii   killall -SIGUSR2 autoipd 2>/dev/null\n1018 0x0001d55c 0x0002555c 7   8    .rodata         ascii   rfc3442\n1019 0x0001d564 0x00025564 18  19   .rodata         ascii   /tmp/udhcpc.routes\n1020 0x0001d578 0x00025578 6   7    .rodata         ascii   sroute\n1021 0x0001d580 0x00025580 19  20   .rodata         ascii   /tmp/udhcpc.routes2\n1022 0x0001d594 0x00025594 10  11   .rodata         ascii   wan_domain\n1023 0x0001d5a0 0x000255a0 9   10   .rodata         ascii   wan_lease\n1024 0x0001d5ac 0x000255ac 31  32   .rodata         ascii   [PPTP] gateway from dhcp: (%s)\\n\n1025 0x0001d5cc 0x000255cc 32  33   .rodata         ascii   [PPPoE] gateway from dhcp: (%s)\\n\n1026 0x0001d5f0 0x000255f0 31  32   .rodata         ascii   [L2TP] gateway from dhcp: (%s)\\n\n1027 0x0001d610 0x00025610 32  33   .rodata         ascii   [PPTP] nameserver from dhcp: %s\\n\n1028 0x0001d634 0x00025634 33  34   .rodata         ascii   [PPPoE] nameserver from dhcp: %s\\n\n1029 0x0001d658 0x00025658 32  33   .rodata         ascii   [L2TP] nameserver from dhcp: %s\\n\n1030 0x0001d67c 0x0002567c 15  16   .rodata         ascii   /tmp/ppp/dhcpIp\n1031 0x0001d68c 0x0002568c 16  17   .rodata         ascii   user_ip_addr %s\\n\n1032 0x0001d6a0 0x000256a0 16  17   .rodata         ascii   gateway_addr %s\\n\n1033 0x0001d6b4 0x000256b4 16  17   .rodata         ascii   netmask_addr %s\\n\n1034 0x0001d6c8 0x000256c8 17  18   .rodata         ascii   pptp_dhcp_enabled\n1035 0x0001d6dc 0x000256dc 18  19   .rodata         ascii   pppoe_dhcp_enabled\n1036 0x0001d6f0 0x000256f0 17  18   .rodata         ascii   l2tp_dhcp_enabled\n1037 0x0001d704 0x00025704 35  36   .rodata         ascii   Wins: Got IP of WAN by DHCP client.\n1038 0x0001d728 0x00025728 13  14   .rodata         ascii   dhcp_offer_ip\n1039 0x0001d738 0x00025738 8   9    .rodata         ascii   wan_wins\n1040 0x0001d744 0x00025744 8   9    .rodata         ascii   hostname\n1041 0x0001d750 0x00025750 8   9    .rodata         ascii   serverid\n1042 0x0001d75c 0x0002575c 8   9    .rodata         ascii   deconfig\n1043 0x0001d768 0x00025768 5   6    .rodata         ascii   bound\n1044 0x0001d770 0x00025770 5   6    .rodata         ascii   renew\n1045 0x0001d778 0x00025778 6   7    .rodata         ascii   IFNAME\n1046 0x0001d780 0x00025780 14  15   .rodata         ascii   /tmp/ppp/link.\n1047 0x0001d790 0x00025790 7   8    .rodata         ascii   IPLOCAL\n1048 0x0001d798 0x00025798 11  12   .rodata         ascii   10.64.64.64\n1049 0x0001d7a4 0x000257a4 11  12   .rodata         ascii   wan2_ipaddr\n1050 0x0001d7b0 0x000257b0 12  13   .rodata         ascii   wan2_netmask\n1051 0x0001d7c0 0x000257c0 8   9    .rodata         ascii   IPREMOTE\n1052 0x0001d7cc 0x000257cc 12  13   .rodata         ascii   wan2_gateway\n1053 0x0001d7dc 0x000257dc 11  12   .rodata         ascii   169.254.1.1\n1054 0x0001d7e8 0x000257e8 4   5    .rodata         ascii   DNS1\n1055 0x0001d7f0 0x000257f0 4   5    .rodata         ascii   DNS2\n1056 0x0001d7f8 0x000257f8 4   5    .rodata         ascii   %s%s\n1057 0x0001d800 0x00025800 22  23   .rodata         ascii   /tmp/ppp/pppoe_session\n1058 0x0001d818 0x00025818 16  17   .rodata         ascii   pppoe_server_mac\n1059 0x0001d82c 0x0002582c 16  17   .rodata         ascii   pppoe_session_id\n1060 0x0001d840 0x00025840 21  22   .rodata         ascii   /tmp/ppp/linkupstart.\n1061 0x0001d858 0x00025858 4   5    .rodata         ascii   %lu\\n\n1062 0x0001d860 0x00025860 14  15   .rodata         ascii   pppoe_flet_sel\n1063 0x0001d870 0x00025870 10  11   .rodata         ascii   fletenable\n1064 0x0001d87c 0x0002587c 16  17   .rodata         ascii   /tmp/ppp/no_ppp2\n1065 0x0001d890 0x00025890 40  41   .rodata         ascii   /sbin/pppd file /tmp/ppp/peers/options &\n1066 0x0001d8bc 0x000258bc 18  19   .rodata         ascii   2nd pppd started.\\n\n1067 0x0001d8d0 0x000258d0 12  13   .rodata         ascii   IDLE_TIMEOUT\n1068 0x0001d8e0 0x000258e0 23  24   .rodata         ascii   [Internet idle-timeout]\n1069 0x0001d8f8 0x000258f8 15  16   .rodata         ascii   wan2_ipaddr_old\n1070 0x0001d908 0x00025908 23  24   .rodata         ascii   /tmp/ppp/pppoe2_session\n1071 0x0001d920 0x00025920 17  18   .rodata         ascii   pppoe2_server_mac\n1072 0x0001d934 0x00025934 17  18   .rodata         ascii   pppoe2_session_id\n1073 0x0001d958 0x00025958 13  14   .rodata         ascii   pptp_username\n1074 0x0001d968 0x00025968 11  12   .rodata         ascii   pptp_passwd\n1075 0x0001d974 0x00025974 7   8    .rodata         ascii   wan_mtu\n1076 0x0001d97c 0x0002597c 15  16   .rodata         ascii   /tmp/ppp/pptpIp\n1077 0x0001d98c 0x0002598c 16  17   .rodata         ascii   pptp_serv_ip %s\\n\n1078 0x0001d9a0 0x000259a0 21  22   .rodata         ascii   pptp_user_ip 0.0.0.0\\n\n1079 0x0001d9b8 0x000259b8 16  17   .rodata         ascii   pptp_user_ip %s\\n\n1080 0x0001d9cc 0x000259cc 19  20   .rodata         ascii   pptp_gateway_ip %s\\n\n1081 0x0001d9e0 0x000259e0 26  27   .rodata         ascii   pptp_user_netmask 0.0.0.0\\n\n1082 0x0001d9fc 0x000259fc 21  22   .rodata         ascii   pptp_user_netmask %s\\n\n1083 0x0001da14 0x00025a14 16  17   .rodata         ascii   /tmp/ppp/options\n1084 0x0001da28 0x00025a28 13  14   .rodata         ascii   defaultroute\\n\n1085 0x0001da38 0x00025a38 29  30   .rodata         ascii   pty 'pptp %s --nolaunchpppd'\\n\n1086 0x0001da58 0x00025a58 7   8    .rodata         ascii   noauth\\n\n1087 0x0001da60 0x00025a60 10  11   .rodata         ascii   user \"%s\"\\n\n1088 0x0001da6c 0x00025a6c 7   8    .rodata         ascii   mtu %d\\n\n1089 0x0001da74 0x00025a74 7   8    .rodata         ascii   mru %d\\n\n1090 0x0001da7c 0x00025a7c 10  11   .rodata         ascii   holdoff 5\\n\n1091 0x0001da88 0x00025a88 8   9    .rodata         ascii   persist\\n\n1092 0x0001da94 0x00025a94 21  22   .rodata         ascii   lcp-echo-interval 10\\n\n1093 0x0001daac 0x00025aac 19  20   .rodata         ascii   lcp-echo-failure 3\\n\n1094 0x0001dac0 0x00025ac0 26  27   .rodata         ascii   disconnect 'killall pptp'\\n\n1095 0x0001dadc 0x00025adc 10  11   .rodata         ascii   maxfail 0\\n\n1096 0x0001dae8 0x00025ae8 13  14   .rodata         ascii   connect echo\\n\n1097 0x0001daf8 0x00025af8 12  13   .rodata         ascii   pptp_localip\n1098 0x0001db08 0x00025b08 11  12   .rodata         ascii   pptp_ip_sel\n1099 0x0001db14 0x00025b14 18  19   .rodata         ascii   ipcp-accept-local\\n\n1100 0x0001db28 0x00025b28 4   5    .rodata         ascii   %s:\\n\n1101 0x0001db30 0x00025b30 19  20   .rodata         ascii   ipcp-accept-remote\\n\n1102 0x0001db44 0x00025b44 12  13   .rodata         ascii   noipdefault\\n\n1103 0x0001db54 0x00025b54 6   7    .rodata         ascii   ktune\\n\n1104 0x0001db5c 0x00025b5c 17  18   .rodata         ascii   default-asyncmap\\n\n1105 0x0001db70 0x00025b70 9   10   .rodata         ascii   noaccomp\\n\n1106 0x0001db7c 0x00025b7c 8   9    .rodata         ascii   nopcomp\\n\n1107 0x0001db88 0x00025b88 6   7    .rodata         ascii   noccp\\n\n1108 0x0001db90 0x00025b90 5   6    .rodata         ascii   novj\\n\n1109 0x0001db98 0x00025b98 10  11   .rodata         ascii   nobsdcomp\\n\n1110 0x0001dba4 0x00025ba4 10  11   .rodata         ascii   nodeflate\\n\n1111 0x0001dbb0 0x00025bb0 5   6    .rodata         ascii   lock\\n\n1112 0x0001dbb8 0x00025bb8 11  12   .rodata         ascii   usepeerdns\\n\n1113 0x0001dbc4 0x00025bc4 13  14   .rodata         ascii   pptp_idletime\n1114 0x0001dbd4 0x00025bd4 8   9    .rodata         ascii   idle %d\\n\n1115 0x0001dbe0 0x00025be0 7   8    .rodata         ascii   demand\\n\n1116 0x0001dbe8 0x00025be8 20  21   .rodata         ascii   /tmp/ppp/pap-secrets\n1117 0x0001dc00 0x00025c00 19  20   .rodata         ascii   /tmp/ppp/pap-screts\n1118 0x0001dc14 0x00025c14 14  15   .rodata         ascii   \"%s\" * \"%s\" *\\n\n1119 0x0001dc24 0x00025c24 21  22   .rodata         ascii   /tmp/ppp/chap-secrets\n1120 0x0001dc3c 0x00025c3c 20  21   .rodata         ascii   /tmp/ppp/chap-screts\n1121 0x0001dc54 0x00025c54 10  11   .rodata         ascii   /dev/ptys0\n1122 0x0001dc60 0x00025c60 27  28   .rodata         ascii   Unable to create /dev/ptys0\n1123 0x0001dc7c 0x00025c7c 10  11   .rodata         ascii   /dev/ttys0\n1124 0x0001dc88 0x00025c88 27  28   .rodata         ascii   Unable to create /dev/ttys0\n1125 0x0001dca4 0x00025ca4 26  27   .rodata         ascii   Dynamic IP by DHCP client.\n1126 0x0001dcc0 0x00025cc0 43  44   .rodata         ascii   Fork could not create child process (%d)!!\\n\n1127 0x0001dcec 0x00025cec 16  17   .rodata         ascii   /usr/sbin/udhcpc\n1128 0x0001dd00 0x00025d00 26  27   .rodata         ascii   Static IP by user defined.\n1129 0x0001dd1c 0x00025d1c 9   10   .rodata         ascii   255.0.0.0\n1130 0x0001dd28 0x00025d28 33  34   .rodata         ascii   pppd executed successfully. (%d)\\n\n1131 0x0001dd4c 0x00025d4c 29  30   .rodata         ascii   Failed to execute pppd. (%d)\\n\n1132 0x0001dd6c 0x00025d6c 4   5    .rodata         ascii   wan_\n1133 0x0001dd74 0x00025d74 8   9    .rodata         ascii   dmz_init\n1134 0x0001dd80 0x00025d80 11  12   .rodata         ascii   fw_dmz_enab\n1135 0x0001dd8c 0x00025d8c 10  11   .rodata         ascii   dmz_ipaddr\n1136 0x0001dd98 0x00025d98 23  24   .rodata         ascii   %s: Error setting DMZ.\\n\n1137 0x0001ddb0 0x00025db0 10  11   .rodata         ascii   fw_dmz_ip4\n1138 0x0001ddbc 0x00025dbc 13  14   .rodata         ascii   255.255.255.0\n1139 0x0001ddd0 0x00025dd0 16  17   .rodata         ascii   pptp_passthrough\n1140 0x0001dde4 0x00025de4 4   5    .rodata         ascii   PPTP\n1141 0x0001ddec 0x00025dec 16  17   .rodata         ascii   l2tp_passthrough\n1142 0x0001de00 0x00025e00 4   5    .rodata         ascii   L2TP\n1143 0x0001de08 0x00025e08 17  18   .rodata         ascii   ipsec_passthrough\n1144 0x0001de1c 0x00025e1c 5   6    .rodata         ascii   IPSEC\n1145 0x0001de28 0x00025e28 21  22   .rodata         ascii   nat_inbound_filtering\n1146 0x0001de40 0x00025e40 38  39   .rodata         ascii   mp_start_nat: %s not a ppp interface.\\n\n1147 0x0001de78 0x00025e78 14  15   .rodata         ascii   pppoe_username\n1148 0x0001de88 0x00025e88 12  13   .rodata         ascii   pppoe_passwd\n1149 0x0001de98 0x00025e98 17  18   .rodata         ascii   pppoe_servicename\n1150 0x0001deac 0x00025eac 15  16   .rodata         ascii   tmp/ppp/ipv6-up\n1151 0x0001debc 0x00025ebc 17  18   .rodata         ascii   tmp/ppp/ipv6-down\n1152 0x0001ded0 0x00025ed0 6   7    .rodata         ascii   %s %s\\n\n1153 0x0001ded8 0x00025ed8 26  27   .rodata         ascii   pty 'pppoecd -I %s -S %s'\\n\n1154 0x0001def4 0x00025ef4 20  21   .rodata         ascii   pty 'pppoecd -I %s'\\n\n1155 0x0001df0c 0x00025f0c 42  43   .rodata         ascii   disconnect 'killall pppoecd 2> /dev/null'\\n\n1156 0x0001df38 0x00025f38 29  30   .rodata         ascii   disconnect 'killall pppoecd'\\n\n1157 0x0001df58 0x00025f58 13  14   .rodata         ascii   pppoe_localip\n1158 0x0001df68 0x00025f68 12  13   .rodata         ascii   pppoe_ip_sel\n1159 0x0001df78 0x00025f78 6   7    .rodata         ascii   +ipv6\\n\n1160 0x0001df80 0x00025f80 8   9    .rodata         ascii   ipv6 , \\n\n1161 0x0001df8c 0x00025f8c 7   8    .rodata         ascii   unit 0\\n\n1162 0x0001df94 0x00025f94 18  19   .rodata         ascii   pap-max-authreq 3\\n\n1163 0x0001dfa8 0x00025fa8 21  22   .rodata         ascii   chap-max-challenge 3\\n\n1164 0x0001dfc0 0x00025fc0 14  15   .rodata         ascii   pppoe_idletime\n1165 0x0001dfd0 0x00025fd0 15  16   .rodata         ascii   pppoe2_username\n1166 0x0001dfe0 0x00025fe0 13  14   .rodata         ascii   pppoe2_passwd\n1167 0x0001dff0 0x00025ff0 18  19   .rodata         ascii   pppoe2_servicename\n1168 0x0001e004 0x00026004 22  23   .rodata         ascii   /tmp/ppp/peers/options\n1169 0x0001e01c 0x0002601c 37  38   .rodata         ascii   pty '/tmp/pppoecd2 -I %s -S %s -P 1'\\n\n1170 0x0001e044 0x00026044 31  32   .rodata         ascii   pty '/tmp/pppoecd2 -I %s -P 1'\\n\n1171 0x0001e064 0x00026064 10  11   .rodata         ascii   pppoe2_dod\n1172 0x0001e070 0x00026070 21  22   .rodata         ascii   lcp-echo-interval 20\\n\n1173 0x0001e088 0x00026088 43  44   .rodata         ascii   disconnect 'killall pppoecd2 2> /dev/null'\\n\n1174 0x0001e0b4 0x000260b4 14  15   .rodata         ascii   pppoe2_localip\n1175 0x0001e0c4 0x000260c4 7   8    .rodata         ascii   unit 1\\n\n1176 0x0001e0cc 0x000260cc 15  16   .rodata         ascii   pppoe2_idletime\n1177 0x0001e0e0 0x000260e0 10  11   .rodata         ascii   /dev/ptys1\n1178 0x0001e0ec 0x000260ec 27  28   .rodata         ascii   Unable to create /dev/ptys1\n1179 0x0001e108 0x00026108 10  11   .rodata         ascii   /dev/ttys1\n1180 0x0001e114 0x00026114 27  28   .rodata         ascii   Unable to create /dev/ttys1\n1181 0x0001e130 0x00026130 8   9    .rodata         ascii   nvconfig\n1182 0x0001e13c 0x0002613c 47  48   .rodata         ascii   usage: nvconfig [get name] [set name value] ...\n1183 0x0001e174 0x00026174 115 116  .rodata         ascii   usage: firewall [addport if_name app_name protocol port_number] [delport if_name app_name protocol port_number] ...\n1184 0x0001e1e8 0x000261e8 7   8    .rodata         ascii   addport\n1185 0x0001e1f0 0x000261f0 16  17   .rodata         ascii   FIREWALL_PORT_%d\n1186 0x0001e204 0x00026204 7   8    .rodata         ascii   delport\n1187 0x0001e20c 0x0002620c 22  23   .rodata         ascii   usage: api <operation>\n1188 0x0001e228 0x00026228 4   5    .rodata         ascii   0.01\n1189 0x0001e230 0x00026230 57  58   .rodata         ascii   usage: internet <operation> <object> [<app name> <value>]\n1190 0x0001e26c 0x0002626c 17  18   .rodata         ascii   ether eth0 active\n1191 0x0001e280 0x00026280 17  18   .rodata         ascii   ether ppp0 active\n1192 0x0001e294 0x00026294 10  11   .rodata         ascii   connection\n1193 0x0001e2a0 0x000262a0 16  17   .rodata         ascii   connection_table\n1194 0x0001e2b8 0x000262b8 6   7    .rodata         ascii   %s %d\\n\n1195 0x0001e2c0 0x000262c0 22  23   .rodata         ascii   object does not exist!\n1196 0x0001e2d8 0x000262d8 12  13   .rodata         ascii   killall pppd\n1197 0x0001e2e8 0x000262e8 14  15   .rodata         ascii   Invalid value!\n1198 0x0001e2f8 0x000262f8 34  35   .rodata         ascii   usage: system <operation> <object>\n1199 0x0001e31c 0x0002631c 8   9    .rodata         ascii   dev_name\n1200 0x0001e328 0x00026328 10  11   .rodata         ascii   model_name\n1201 0x0001e334 0x00026334 5   6    .rodata         ascii   R6400\n1202 0x0001e33c 0x0002633c 13  14   .rodata         ascii   serial_number\n1203 0x0001e34c 0x0002634c 32  33   .rodata         ascii   usage: dlna <operation> <object>\n1204 0x0001e370 0x00026370 6   7    .rodata         ascii   status\n1205 0x0001e378 0x00026378 11  12   .rodata         ascii   dlna_enable\n1206 0x0001e384 0x00026384 6   7    .rodata         ascii   active\n1207 0x0001e38c 0x0002638c 8   9    .rodata         ascii   inactive\n1208 0x0001e398 0x00026398 13  14   .rodata         ascii   database-path\n1209 0x0001e3a8 0x000263a8 18  19   .rodata         ascii   /tmp/minidlna.conf\n1210 0x0001e3bc 0x000263bc 7   8    .rodata         ascii   db_dir=\n1211 0x0001e3c4 0x000263c4 52  53   .rodata         ascii   failed to read DLNA config file \"/tmp/minidlna.conf\"\n1212 0x0001e40c 0x0002640c 14  15   .rodata         ascii   l2tp_user\n1213 0x0001e41c 0x0002641c 16  17   .rodata         ascii   l2tp_user_passwd\n1214 0x0001e430 0x00026430 10  11   .rodata         ascii   /dev/ptys2\n1215 0x0001e43c 0x0002643c 27  28   .rodata         ascii   Unable to create /dev/ptys2\n1216 0x0001e458 0x00026458 10  11   .rodata         ascii   /dev/ttys2\n1217 0x0001e464 0x00026464 27  28   .rodata         ascii   Unable to create /dev/ttys2\n1218 0x0001e480 0x00026480 15  16   .rodata         ascii   /tmp/ppp/l2tpIp\n1219 0x0001e490 0x00026490 16  17   .rodata         ascii   l2tp_serv_ip %s\\n\n1220 0x0001e4a4 0x000264a4 21  22   .rodata         ascii   l2tp_user_ip 0.0.0.0\\n\n1221 0x0001e4bc 0x000264bc 16  17   .rodata         ascii   l2tp_user_ip %s\\n\n1222 0x0001e4d0 0x000264d0 19  20   .rodata         ascii   l2tp_gateway_ip %s\\n\n1223 0x0001e4e4 0x000264e4 26  27   .rodata         ascii   l2tp_user_netmask 0.0.0.0\\n\n1224 0x0001e500 0x00026500 21  22   .rodata         ascii   l2tp_user_netmask %s\\n\n1225 0x0001e518 0x00026518 10  11   .rodata         ascii   /tmp/l2tp/\n1226 0x0001e524 0x00026524 20  21   .rodata         ascii   /tmp/l2tp/l2tpd.conf\n1227 0x0001e53c 0x0002653c 9   10   .rodata         ascii   [lac %s]\\n\n1228 0x0001e548 0x00026548 9   10   .rodata         ascii   lns = %s\\n\n1229 0x0001e554 0x00026554 10  11   .rodata         ascii   name = %s\\n\n1230 0x0001e560 0x00026560 16  17   .rodata         ascii   ppp debug = yes\\n\n1231 0x0001e574 0x00026574 30  31   .rodata         ascii   pppoptfile = /tmp/ppp/options\\n\n1232 0x0001e594 0x00026594 17  18   .rodata         ascii   length bit = yes\\n\n1233 0x0001e5a8 0x000265a8 28  29   .rodata         ascii   require authentication = yes\n1234 0x0001e5c8 0x000265c8 39  40   .rodata         ascii   pty 'l2tpd -D -c /tmp/l2tp/l2tpd.conf'\\n\n1235 0x0001e5f0 0x000265f0 27  28   .rodata         ascii   disconnect 'killall l2tpd'\\n\n1236 0x0001e60c 0x0002660c 14  15   .rodata         ascii   lcp-restart 5\\n\n1237 0x0001e61c 0x0002661c 15  16   .rodata         ascii   ipcp-restart 5\\n\n1238 0x0001e62c 0x0002662c 12  13   .rodata         ascii   l2tp_localip\n1239 0x0001e63c 0x0002663c 11  12   .rodata         ascii   l2tp_ip_sel\n1240 0x0001e648 0x00026648 11  12   .rodata         ascii   linkname 0\\n\n1241 0x0001e654 0x00026654 14  15   .rodata         ascii   l2tp_idle_time\n1242 0x0001e664 0x00026664 20  21   .rodata         ascii   /tmp/l2tp/l2tpd.info\n1243 0x0001e67c 0x0002667c 30  31   .rodata         ascii   Failed to execute l2tpd. (%d)\\n\n1244 0x0001e69c 0x0002669c 14  15   .rodata         ascii   ipv6_auto_mode\n1245 0x0001e6ac 0x000266ac 12  13   .rodata         ascii   start_dhcp6c\n1246 0x0001e6bc 0x000266bc 17  18   .rodata         ascii   start_dhcp6c_iapd\n1247 0x0001e6d0 0x000266d0 4   5    .rodata         ascii   Down\n1248 0x0001e6d8 0x000266d8 14  15   .rodata         ascii   ipv6_auto_type\n1249 0x0001e6e8 0x000266e8 34  35   .rodata         ascii   the Internet port is not connected\n1250 0x0001e70c 0x0002670c 12  13   .rodata         ascii   Detecting...\n1251 0x0001e71c 0x0002671c 30  31   .rodata         ascii   /tmp/wan_ipv6_ra_detect.result\n1252 0x0001e73c 0x0002673c 15  16   .rodata         ascii   /tmp/wan_dhcp6c\n1253 0x0001e74c 0x0002674c 20  21   .rodata         ascii   /tmp/wan_dhcp6c_iapd\n1254 0x0001e764 0x00026764 16  17   .rodata         ascii   /tmp/dhcp6c.conf\n1255 0x0001e778 0x00026778 29  30   .rodata         ascii   request domain-name-servers;\\n\n1256 0x0001e798 0x00026798 14  15   .rodata         ascii   solicit-only;\\n\n1257 0x0001e7a8 0x000267a8 10  11   .rodata         ascii   rtsol -w &\n1258 0x0001e7b4 0x000267b4 12  13   .rodata         ascii   dhcp6c_debug\n1259 0x0001e7c4 0x000267c4 34  35   .rodata         ascii   %s: Unable to open '%s', errno=%d\\n\n1260 0x0001e7e8 0x000267e8 23  24   .rodata         ascii   dhcp6c -c %s -D -f %s &\n1261 0x0001e800 0x00026800 15  16   .rodata         ascii   dhcp6c -c %s %s\n1262 0x0001e810 0x00026810 14  15   .rodata         ascii   killall dhcp6c\n1263 0x0001e820 0x00026820 11  12   .rodata         ascii   6to4 Tunnel\n1264 0x0001e82c 0x0002682c 4   5    .rodata         ascii   DHCP\n1265 0x0001e834 0x00026834 11  12   .rodata         ascii   Auto Config\n1266 0x0001e840 0x00026840 12  13   .rodata         ascii   Pass Through\n1267 0x0001e850 0x00026850 46  47   .rodata         ascii   IPv6 Auto detect as 6to4! Retry in 10 seconds!\n1268 0x0001e880 0x00026880 32  33   .rodata         ascii   %s: IPv6 auto detect result: %d\\n\n1269 0x0001e8a4 0x000268a4 20  21   .rodata         ascii   radvd_lan_new_ipaddr\n1270 0x0001e8bc 0x000268bc 27  28   .rodata         ascii   radvd_lan_new_ipaddr_length\n1271 0x0001e8d8 0x000268d8 21  22   .rodata         ascii   ifconfig %s add %s/%s\n1272 0x0001e8f0 0x000268f0 15  16   .rodata         ascii   ipv6_wan_ipaddr\n1273 0x0001e900 0x00026900 15  16   .rodata         ascii   ipv6_wan_length\n1274 0x0001e910 0x00026910 19  20   .rodata         ascii   ipv6_wan_ipaddr_old\n1275 0x0001e924 0x00026924 19  20   .rodata         ascii   ipv6_wan_length_old\n1276 0x0001e938 0x00026938 14  15   .rodata         ascii   autoconfig_wan\n1277 0x0001e948 0x00026948 16  17   .rodata         ascii   ipv6_wan_gateway\n1278 0x0001e95c 0x0002695c 29  30   .rodata         ascii   route -A inet6 add ::/0 gw %s\n1279 0x0001e97c 0x0002697c 23  24   .rodata         ascii   ipv6_interfaceid_enable\n1280 0x0001e994 0x00026994 17  18   .rodata         ascii   ipv6_interface_id\n1281 0x0001e9a8 0x000269a8 19  20   .rodata         ascii   ipv6_lan_ipaddr_old\n1282 0x0001e9bc 0x000269bc 19  20   .rodata         ascii   ipv6_lan_length_old\n1283 0x0001e9d0 0x000269d0 13  14   .rodata         ascii   wla_wlanstate\n1284 0x0001e9e0 0x000269e0 6   7    .rodata         ascii   Enable\n1285 0x0001e9e8 0x000269e8 7   8    .rodata         ascii   wl down\n1286 0x0001e9f0 0x000269f0 13  14   .rodata         ascii   wlg_wlanstate\n1287 0x0001ea00 0x00026a00 15  16   .rodata         ascii   wl -i eth2 down\n1288 0x0001ea10 0x00026a10 16  17   .rodata         ascii   killall -9 radvd\n1289 0x0001ea24 0x00026a24 5   6    .rodata         ascii   wl up\n1290 0x0001ea2c 0x00026a2c 13  14   .rodata         ascii   wl -i eth2 up\n1291 0x0001ea3c 0x00026a3c 11  12   .rodata         ascii   fw_rsp_ping\n1292 0x0001ea48 0x00026a48 21  22   .rodata         ascii   ifconfig %s del %s/%s\n1293 0x0001ea60 0x00026a60 23  24   .rodata         ascii   route -A inet6 del ::/0\n1294 0x0001ea78 0x00026a78 16  17   .rodata         ascii   dhcp6c_iana_only\n1295 0x0001ea8c 0x00026a8c 15  16   .rodata         ascii   command = '%s'\\n\n1296 0x0001ea9c 0x00026a9c 16  17   .rodata         ascii   ipv6_proto_pppoe\n1297 0x0001eab0 0x00026ab0 22  23   .rodata         ascii   killall -SIGUSR1 rtsol\n1298 0x0001eac8 0x00026ac8 11  12   .rodata         ascii   64.64.64.64\n1299 0x0001ead4 0x00026ad4 30  31   .rodata         ascii   2002:%02X%02X:%02X%02X:%04X:%s\n1300 0x0001eaf4 0x00026af4 16  17   .rodata         ascii   ifconfig sit0 up\n1301 0x0001eb08 0x00026b08 15  16   .rodata         ascii   ipv6_6to4_relay\n1302 0x0001eb18 0x00026b18 16  17   .rodata         ascii   ipv6_6to4_router\n1303 0x0001eb2c 0x00026b2c 14  15   .rodata         ascii   ipv6_static_ip\n1304 0x0001eb3c 0x00026b3c 44  45   .rodata         ascii   route -A inet6 add 2000::/3 gw ::%s dev sit0\n1305 0x0001eb6c 0x00026b6c 16  17   .rodata         ascii   ipv6_6to4_tunnel\n1306 0x0001eb80 0x00026b80 36  37   .rodata         ascii   route -A inet6 del 2000::/3 dev sit0\n1307 0x0001eba8 0x00026ba8 18  19   .rodata         ascii   ifconfig sit0 down\n1308 0x0001ebc4 0x00026bc4 15  16   .rodata         ascii   ipv6_6rd_status\n1309 0x0001ebd4 0x00026bd4 15  16   .rodata         ascii   ipv6_6rd_tunnel\n1310 0x0001ebe8 0x00026be8 16  17   .rodata         ascii   DHCP/Auto Config\n1311 0x0001ebfc 0x00026bfc 6   7    .rodata         ascii   fe80::\n1312 0x0001ec04 0x00026c04 21  22   .rodata         ascii   ifconfig %s del %s/%d\n1313 0x0001ec1c 0x00026c1c 21  22   .rodata         ascii   ifconfig %s add %s/%d\n1314 0x0001ec34 0x00026c34 29  30   .rodata         ascii   user-class user_config_file;\\n\n1315 0x0001ec54 0x00026c54 21  22   .rodata         ascii   /tmp/dhcp6c_user.conf\n1316 0x0001ec6c 0x00026c6c 16  17   .rodata         ascii   ipv6_system_name\n1317 0x0001ec80 0x00026c80 14  15   .rodata         ascii   user_class %s\\n\n1318 0x0001ec90 0x00026c90 22  23   .rodata         ascii   /tmp/dhcp6c_debug.fifo\n1319 0x0001eca8 0x00026ca8 21  22   .rodata         ascii   /tmp/dhcp6c_debug.txt\n1320 0x0001ecc0 0x00026cc0 43  44   .rodata         ascii   echo '==========' >> /tmp/dhcp6c_debug.fifo\n1321 0x0001ecec 0x00026cec 55  56   .rodata         ascii   dhcp6c -D -f -c %s -u %s %s 2>>/tmp/dhcp6c_debug.fifo &\n1322 0x0001ed24 0x00026d24 21  22   .rodata         ascii   dhcp6c -c %s -u %s %s\n1323 0x0001ed3c 0x00026d3c 21  22   .rodata         ascii   /tmp/rtsol_debug.fifo\n1324 0x0001ed54 0x00026d54 20  21   .rodata         ascii   /tmp/rtsol_debug.txt\n1325 0x0001ed6c 0x00026d6c 42  43   .rodata         ascii   echo '==========' >> /tmp/rtsol_debug.fifo\n1326 0x0001ed98 0x00026d98 39  40   .rodata         ascii   rtsol -d -I %s 2>>/tmp/rtsol_debug.fifo\n1327 0x0001edc0 0x00026dc0 14  15   .rodata         ascii   rtsol -d -I %s\n1328 0x0001edd0 0x00026dd0 11  12   .rodata         ascii   iapd-only;\\n\n1329 0x0001eddc 0x00026ddc 27  28   .rodata         ascii   request prefix-delegation;\\n\n1330 0x0001edf8 0x00026df8 20  21   .rodata         ascii   /tmp/ppp/options.bak\n1331 0x0001ee10 0x00026e10 6   7    .rodata         ascii   demand\n1332 0x0001ee18 0x00026e18 4   5    .rodata         ascii   idle\n1333 0x0001ee20 0x00026e20 7   8    .rodata         ascii   persist\n1334 0x0001ee28 0x00026e28 20  21   .rodata         ascii   /tmp/client6.leases1\n1335 0x0001ee40 0x00026e40 13  14   .rodata         ascii   killall rtsol\n1336 0x0001ee50 0x00026e50 18  19   .rodata         ascii   killall IPv6-relay\n1337 0x0001ee64 0x00026e64 14  15   .rodata         ascii   killall pppdv6\n1338 0x0001ee74 0x00026e74 21  22   .rodata         ascii   ifconfig %s del %s/64\n1339 0x0001ee8c 0x00026e8c 21  22   .rodata         ascii   ifconfig %s add %s/64\n1340 0x0001eea4 0x00026ea4 19  20   .rodata         ascii   ipv6_proto_override\n1341 0x0001eeb8 0x00026eb8 11  12   .rodata         ascii   Passthrough\n1342 0x0001eec4 0x00026ec4 26  27   .rodata         ascii   pppd file /tmp/ppp/options\n1343 0x0001eee0 0x00026ee0 22  23   .rodata         ascii   IPv6-relay -C %s -S %s\n1344 0x0001eef8 0x00026ef8 24  25   .rodata         ascii   /tmp/dhcp6c_rfc3315.conf\n1345 0x0001ef14 0x00026f14 11  12   .rodata         ascii   iana-only;\\n\n1346 0x0001ef20 0x00026f20 28  29   .rodata         ascii   /tmp/dhcp6c_rfc3646_dns.conf\n1347 0x0001ef40 0x00026f40 31  32   .rodata         ascii   /tmp/dhcp6c_rfc3646_domain.conf\n1348 0x0001ef60 0x00026f60 21  22   .rodata         ascii   request domain-list;\\n\n1349 0x0001ef78 0x00026f78 28  29   .rodata         ascii   /tmp/dhcp6c_rfc3736_dns.conf\n1350 0x0001ef98 0x00026f98 18  19   .rodata         ascii   information-only;\\n\n1351 0x0001efac 0x00026fac 31  32   .rodata         ascii   /tmp/dhcp6c_rfc3736_domain.conf\n1352 0x0001efcc 0x00026fcc 35  36   .rodata         ascii   /tmp/dhcp6c_rfc3736_dns_domain.conf\n1353 0x0001eff0 0x00026ff0 15  16   .rodata         ascii   ipv6_pppoe_mode\n1354 0x0001f010 0x00027010 16  17   .rodata         ascii   rtsol -w -I %s &\n1355 0x0001f024 0x00027024 32  33   .rodata         ascii   route -A inet6 add ::/0 dev ppp1\n1356 0x0001f048 0x00027048 32  33   .rodata         ascii   route -A inet6 add ::/0 dev ppp0\n1357 0x0001f06c 0x0002706c 33  34   .rodata         ascii   %s: IPv6 PPPOE detect result: %d\\n\n1358 0x0001f090 0x00027090 19  20   .rodata         ascii   ipv6_pppoe_username\n1359 0x0001f0a4 0x000270a4 17  18   .rodata         ascii   ipv6_pppoe_passwd\n1360 0x0001f0b8 0x000270b8 22  23   .rodata         ascii   ipv6_pppoe_servicename\n1361 0x0001f0d0 0x000270d0 24  25   .rodata         ascii   /tmp/ppp/pppoev6_session\n1362 0x0001f0ec 0x000270ec 18  19   .rodata         ascii   pppoev6_server_mac\n1363 0x0001f100 0x00027100 18  19   .rodata         ascii   pppoev6_session_id\n1364 0x0001f114 0x00027114 18  19   .rodata         ascii   /tmp/ppp/optionsv6\n1365 0x0001f128 0x00027128 33  34   .rodata         ascii   pty 'pppoecdv6 -I %s -S %s -P 1'\\n\n1366 0x0001f14c 0x0002714c 27  28   .rodata         ascii   pty 'pppoecdv6 -I %s -P 1'\\n\n1367 0x0001f168 0x00027168 44  45   .rodata         ascii   disconnect 'killall pppoecdv6 2> /dev/null'\\n\n1368 0x0001f198 0x00027198 31  32   .rodata         ascii   disconnect 'killall pppoecdv6'\\n\n1369 0x0001f1b8 0x000271b8 5   6    .rodata         ascii   noip\\n\n1370 0x0001f1c0 0x000271c0 7   8    .rodata         ascii   ipv6 ,\\n\n1371 0x0001f1c8 0x000271c8 25  26   .rodata         ascii   /tmp/ppp/pap-secrets-ipv6\n1372 0x0001f1e4 0x000271e4 26  27   .rodata         ascii   /tmp/ppp/chap-secrets-ipv6\n1373 0x0001f200 0x00027200 35  36   .rodata         ascii   pppdv6 executed successfully. (%d)\\n\n1374 0x0001f224 0x00027224 31  32   .rodata         ascii   Failed to execute pppdv6. (%d)\\n\n1375 0x0001f244 0x00027244 56  57   .rodata         ascii   echo 'ipv6up-main argv[1]=%s, argv[2]=%s' > /dev/console\n1376 0x0001f280 0x00027280 35  36   .rodata         ascii   echo 'ipv6down-main' > /dev/console\n1377 0x0001f2a4 0x000272a4 20  21   .rodata         ascii   ipv6_dump_conn_table\n1378 0x0001f2bc 0x000272bc 13  14   .rodata         ascii   ipv6_spi_mode\n1379 0x0001f2cc 0x000272cc 17  18   .rodata         ascii   ipv6_spi_lan_hook\n1380 0x0001f2e0 0x000272e0 17  18   .rodata         ascii   ipv6_spi_wan_hook\n1381 0x0001f2f4 0x000272f4 20  21   .rodata         ascii   ipv6_drop_all_packet\n1382 0x0001f30c 0x0002730c 20  21   .rodata         ascii   ipv6_enable_wan_ping\n1383 0x0001f324 0x00027324 27  28   .rodata         ascii   ipv6_enable_wan_ping_to_lan\n1384 0x0001f340 0x00027340 22  23   .rodata         ascii   ipv6_enable_dns_hijack\n1385 0x0001f358 0x00027358 10  11   .rodata         ascii   /dev/spiv6\n1386 0x0001f364 0x00027364 27  28   .rodata         ascii   Can't open device file: %s\\n\n1387 0x0001f380 0x00027380 29  30   .rodata         ascii   [%s]:ioctl_set_msg failed:%d\\n\n1388 0x0001f3a0 0x000273a0 15  16   .rodata         ascii   /dev/mtdblock16\n1389 0x0001f3b0 0x000273b0 4   5    .rodata         ascii   open\n1390 0x0001f3b8 0x000273b8 10  11   .rodata         ascii   /dev/mtd16\n1391 0x0001f3c4 0x000273c4 4   5    .rodata         ascii   SIZE\n1392 0x0001f3cc 0x000273cc 7   8    .rodata         ascii   /tmp/%s\n1393 0x0001f3d4 0x000273d4 28  29   .rodata         ascii   mtd_netgear-streaming-db.zip\n1394 0x0001f3f4 0x000273f4 33  34   .rodata         ascii   cd /tmp/;unzip -P %s %s;rm -rf %s\n1395 0x0001f418 0x00027418 28  29   .rodata         ascii   netgearstreamingkey897624309\n1396 0x0001f438 0x00027438 14  15   .rodata         ascii   rm -rf /tmp/%s\n1397 0x0001f448 0x00027448 7   8    .rodata         ascii   /etc/%s\n1398 0x0001f450 0x00027450 20  21   .rodata         ascii   netgear-streaming-db\n1399 0x0001f46c 0x0002746c 20  21   .rodata         ascii   error!!!mtd_invalid\\n\n1400 0x0001f484 0x00027484 16  17   .rodata         ascii   erase /dev/mtd16\n1401 0x0001f498 0x00027498 10  11   .rodata         ascii   qos_db_ver\n1402 0x0001f8d1 0x00000005 40  41   .comment        ascii   (GNU) 3.3.2 20031005 (Debian prerelease)\n1403 0x0001f8fa 0x0000002e 30  31   .comment        ascii   GCC: (Buildroot 2012.02) 4.5.3\n1404 0x0001f91e 0x00000005 5   6    .ARM.attributes ascii   aeabi\n1405 0x0001f92f 0x00000016 4   5    .ARM.attributes ascii   \\n\\aA\\b\n1406 0x0001f945 0x00000001 9   10   .shstrtab       ascii   .shstrtab\n1407 0x0001f94f 0x0000000b 7   8    .shstrtab       ascii   .interp\n1408 0x0001f957 0x00000013 5   6    .shstrtab       ascii   .hash\n1409 0x0001f95d 0x00000019 7   8    .shstrtab       ascii   .dynsym\n1410 0x0001f965 0x00000021 7   8    .shstrtab       ascii   .dynstr\n1411 0x0001f96d 0x00000029 8   9    .shstrtab       ascii   .rel.dyn\n1412 0x0001f976 0x00000032 8   9    .shstrtab       ascii   .rel.plt\n1413 0x0001f97f 0x0000003b 5   6    .shstrtab       ascii   .init\n1414 0x0001f985 0x00000041 5   6    .shstrtab       ascii   .text\n1415 0x0001f98b 0x00000047 5   6    .shstrtab       ascii   .fini\n1416 0x0001f991 0x0000004d 7   8    .shstrtab       ascii   .rodata\n1417 0x0001f999 0x00000055 9   10   .shstrtab       ascii   .eh_frame\n1418 0x0001f9a3 0x0000005f 11  12   .shstrtab       ascii   .init_array\n1419 0x0001f9af 0x0000006b 11  12   .shstrtab       ascii   .fini_array\n1420 0x0001f9bb 0x00000077 4   5    .shstrtab       ascii   .jcr\n1421 0x0001f9c0 0x0000007c 8   9    .shstrtab       ascii   .dynamic\n1422 0x0001f9c9 0x00000085 4   5    .shstrtab       ascii   .got\n1423 0x0001f9ce 0x0000008a 5   6    .shstrtab       ascii   .data\n1424 0x0001f9d4 0x00000090 4   5    .shstrtab       ascii   .bss\n1425 0x0001f9d9 0x00000095 8   9    .shstrtab       ascii   .comment\n1426 0x0001f9e2 0x0000009e 15  16   .shstrtab       ascii   .ARM.attributes", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已经使用 r2 的 izz 命令成功列出了二进制文件中的所有字符串。这些字符串揭示了大量的潜在输入点，包括网络接口（如 eth0、br0、ppp0）、文件路径（如 /tmp/uboot.info、/tmp/register.txt）、环境变量/NVRAM 变量（如 lan_ipaddr、wan_ipaddr、pppoe_username）、系统命令（如 system、eval）和网络服务（如 httpd、telnetd）。这些输入点是安全分析的关键起点，因为它们可能成为攻击者注入恶意数据的入口。然而，仅凭字符串列表无法验证完整的攻击链；我需要进一步分析数据流和函数调用，以识别实际可利用的漏洞。接下来，我将使用 r2 分析主要函数（如 main）和关键函数（如那些处理 NVRAM 或系统命令的函数），以追踪不可信数据的传播路径。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ main\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ main\"}\n结果：\n int32_t main(int32_t param_1,int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uchar uVar4;\n    uchar uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    char *pcVar10;\n    uint uVar11;\n    uint uVar12;\n    int32_t iVar13;\n    uint32_t uVar14;\n    uint uVar15;\n    uint unaff_r4;\n    int32_t iVar16;\n    uint *puVar17;\n    uint unaff_r5;\n    uint *puVar18;\n    int32_t iVar19;\n    uint unaff_r6;\n    uint unaff_r7;\n    uint unaff_r8;\n    uint unaff_r9;\n    uint unaff_r10;\n    uint unaff_r11;\n    uint in_lr;\n    bool bVar20;\n    bool bVar21;\n    bool bVar22;\n    uint *puVar23;\n    uint32_t auStack_1d48 [9];\n    uint32_t auStack_1d24 [5];\n    uint auStack_1d10 [10];\n    uchar auStack_1ce8 [4056];\n    uint uStack_d10;\n    uchar auStack_d0c [2044];\n    uint auStack_510 [2];\n    ushort uStack_508;\n    uchar auStack_506 [246];\n    uint auStack_410 [3];\n    uchar auStack_404 [244];\n    uint32_t auStack_310 [64];\n    uint uStack_210;\n    uchar auStack_20c [252];\n    uint uStack_110;\n    uchar auStack_10c [124];\n    uchar auStack_90 [44];\n    int32_t aiStack_64 [12];\n    uint uStack_34;\n    uint uStack_30;\n    uint uStack_2c;\n    uint auStack_28 [10];\n    int32_t iVar24;\n    \n    *(*0x54 + -4) = in_lr;\n    puVar23 = *0x54 + -4 + -4;\n    *puVar23 = unaff_r11;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r10;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r9;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r8;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r7;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r6;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r5;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r4;\n    iVar24 = puVar23 + -4;\n    *(iVar24 + -0xe8) = 0;\n    sym.imp.memset(iVar24 + -0xe4,0,0x7c);\n    *(iVar24 + -0xce8) = 0;\n    sym.imp.memset(iVar24 + -0xce0 + -4,0,0x7fc);\n    iVar16 = *param_2;\n    iVar6 = sym.imp.strrchr(iVar16,0x2f);\n    if (iVar6 != 0) {\n        iVar16 = iVar6 + 1;\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9ac,*0xc9a8);\n    if (iVar6 != 0) {\n        sym.imp.abDisableLanEthernetPort();\n        sym.imp.acosNvramConfig_set(*0xc9ac,*0xc9cc);\n        sym.imp.sleep(1);\n        sym.imp.acosNvramConfig_save();\n        sym.imp.abEnableLanEthernetPort();\n    }\n    iVar6 = sym.imp.strstr(iVar16,*0xc9b0);\n    if (iVar6 == 0) {\n        iVar6 = sym.imp.strstr(iVar16,*0xca30);\n        if (iVar6 + 0 == 0) {\n            iVar6 = sym.imp.strstr(iVar16,*0xcae8);\n            if (iVar6 != 0) {\n                fcn.0000aae4();\n                return 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcb08);\n            if (iVar6 + 0 != 0) {\n                uVar8 = sym.imp.sys_uptime();\n                uVar7 = uVar8 * (0x8889 | 0x88880000) >> 0x25;\n                uVar14 = uVar7 * (0x8889 | 0x88880000) >> 0x25;\n                uVar1 = uVar14 * (0xaaab | 0xaaaa0000) >> 0x24;\n                if (uVar1 != 0) {\n                    uVar11 = *0xcb0c;\n                    if (uVar1 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb10,uVar1,uVar11);\n                }\n                if (uVar14 != 0) {\n                    iVar6 = uVar14 + (uVar14 * (0xaaab | 0xaaaa0000) >> 0x24) * -0x18;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb14,iVar6,uVar11);\n                }\n                if (uVar7 != 0) {\n                    iVar6 = uVar7 + (uVar7 * (0x8889 | 0x88880000) >> 0x25) * -0x3c;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb18,iVar6,uVar11);\n                }\n                if (uVar8 != 0) {\n                    iVar6 = uVar8 + (uVar8 * (0x8889 | 0x88880000) >> 0x25) * -0x3c;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb1c,iVar6,uVar11);\n                }\n                sym.imp.putchar(10);\n                return 0;\n            }\n            iVar9 = sym.imp.strstr(iVar16,*0xcb38);\n            if (iVar9 + 0 != 0) {\n                sym.imp.system(*0xcae8);\n                sym.imp.system(*0xcb3c);\n                sym.imp.system(*0xcb40);\n                sym.imp.system(*0xcb44);\n                sym.imp.system(*0xcb48);\n                sym.imp.system(*0xcb4c);\n                sym.imp.system(*0xcb50);\n                sym.imp.system(*0xcb54);\n                sym.imp.system(*0xcb58);\n                sym.imp.system(*0xcb5c);\n                return iVar6 + 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcb60);\n            if (iVar6 + 0 != 0) {\n                sym.imp.system(*0xcb64);\n                sym.imp.system(*0xcb68);\n                sym.imp.system(*0xcb6c);\n                sym.imp.system(*0xcb70);\n                sym.imp.system(*0xcb74);\n                sym.imp.system(*0xcb78);\n                sym.imp.system(*0xcb7c);\n                sym.imp.system(*0xcb80);\n                sym.imp.system(*0xcb84);\n                sym.imp.system(*0xcb88);\n                sym.imp.system(*0xcb8c);\n                sym.imp.system(*0xcb90);\n                sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,1);\n                sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,1);\n                return iVar9 + 0;\n            }\n            iVar9 = sym.imp.strstr(iVar16,*0xcb94);\n            if (iVar9 != 0) {\n                sym.imp.system(*0xcb98);\n                sym.imp.system(*0xcb9c);\n                sym.imp.system(*0xcba0);\n                sym.imp.system(*0xcba4);\n                sym.imp.system(*0xcba8);\n                sym.imp.system(*0xcbac);\n                sym.imp.system(*0xcbb0);\n                sym.imp.system(*0xcbb4);\n                sym.imp.system(*0xcbb8);\n                sym.imp.system(*0xcbbc);\n                sym.imp.system(*0xcbc0);\n                sym.imp.system(*0xcb90);\n                sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,0);\n                sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,0);\n                return iVar6 + 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcbc4);\n            if (iVar6 == 0) {\n                iVar6 = sym.imp.strstr(iVar16,*0xcc04);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.00017360(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcc08);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.00017a00(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcea0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001728c(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcea4);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001cd64(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xceb0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001cfec(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcebc);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001f96c(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001fa10(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec4);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001fa58();\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec8);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001d110(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcecc);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001d154(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xced0);\n                if (iVar6 == 0) {\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfb4);\n                    if (iVar6 != 0) {\n                        sym.imp.abEnableLanEthernetPort();\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfb8);\n                    if (iVar6 + 0 != 0) {\n                        sym.imp.abDisableLanEthernetPort();\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfbc);\n                    if (iVar6 != 0) {\n                        iVar6 = sym.imp.strcmp(param_2[1],*0xdfc0);\n                        if (iVar6 + 0 == 0) {\n                            fcn.0001fd5c(iVar6 + 1);\n                            return iVar6 + 0;\n                        }\n                        fcn.0001fd5c(0);\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfc4);\n                    if (iVar6 != 0) {\n                        iVar6 = fcn.0001a6fc(param_1,param_2);\n                        return iVar6;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfc8);\n                    if (iVar6 != 0) {\n                        iVar6 = fcn.0001aae8(param_1,param_2);\n                        return iVar6;\n                    }\n                    sym.imp.printf(*0xdfcc,iVar16);\n                    return 0x16;\n                }\n                if (param_1 == 2) {\n                    iVar6 = sym.imp.strcmp(param_2[1],*0xced4);\n                    if (iVar6 != 0) {\n                        iVar6 = 1;\n                    }\n                    fcn.0001fc6c(iVar6);\n                    return 0x16;\n                }\n            }\n            else {\n                sym.imp.system(*0xcbc8);\n                fcn.0000b8c0();\n                sym.imp.acosNvramConfig_unset(*0xcbcc);\n                sym.imp.acosNvramConfig_set(*0xcc94,*0xc9cc);\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd0,*0xc9a8);\n                if (iVar6 != 0) {\n                    sym.imp.puts(*0xcc60);\n                    sym.imp.acosNvramConfig_set(*0xcc64,*0xce98);\n                    sym.imp.acosNvramConfig_set(*0xcc68,*0xce98);\n                    sym.imp.system(*0xcc6c);\n                    sym.imp.acosNvramConfig_set(*0xcc70,*0xce98);\n                    sym.imp.system(*0xcc74);\n                    sym.imp.system(*0xcc78);\n                    sym.imp.system(*0xcc7c);\n                    sym.imp.system(*0xcc80);\n                    sym.imp.system(*0xcc84);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc88,*0xce98);\n                    if (iVar6 != 0) {\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xcd94,*0xcd84);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcd88);\n                            sym.imp.system(*0xcd8c);\n                            sym.imp.system(*0xcd90);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xcd94,*0xcd98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcd9c);\n                            sym.imp.system(*0xcda0);\n                            sym.imp.system(*0xcda4);\n                        }\n                    }\n                    sym.imp.system(*0xcc8c);\n                    sym.imp.system(*0xcc90);\n                    sym.imp.acosNvramConfig_set(*0xcc94,*0xce98);\n                }\n                sym.imp.sys_set_timezone();\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd4,*0xc9a8);\n                if (iVar6 != 0) {\n                    sym.imp.agApi_SetDayLightSaving(1);\n                }\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd8,*0xc9a8);\n                if (iVar6 == 0) {\n                    sym.imp.acosNvramConfig_set(*0xcc98,*0xced4);\n                }\n                iVar6 = param_2[1];\n                if (iVar6 == 0) {\n                    sym.imp.fwrite(*0xcc0c,1,0x34,**0xcda8);\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbdc);\n                if (iVar16 == 0) {\n                    fcn.0001dc60();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xcc10);\n                    if (iVar6 == 0) {\n                        sym.imp.acosNvramConfig_match(*0xcea8,*0xcc14);\n                    }\n                    fcn.0001fc6c(1);\n                    sym.imp.single_session_pppoe_check();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc18);\n                    if ((iVar6 != 0) ||\n                       ((iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc20), iVar6 != 0 &&\n                        (iVar6 = sym.imp.acosNvramConfig_match(*0xccec,*0xccf0), iVar6 != 0)))) {\n                        sym.imp.agApi_fwPolicyClear();\n                        fcn.0000ff08();\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc24,*0xce98);\n                    if (iVar6 == 0) {\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xcce0,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcce4);\n                            sym.imp.system(*0xcce8);\n                        }\n                    }\n                    else {\n                        sym.imp.system(*0xcce4);\n                        sym.imp.system(*0xcc28);\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc2c,*0xce98);\n                    if (iVar6 != 0) {\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                        *(iVar24 + -0x1d20) = *0xccf4;\n                        sym.imp.sprintf(iVar24 + -0x1e8,*0xccfc,*0xccf8,uVar11);\n                        sym.imp.system(iVar24 + -0x1e8);\n                        sym.imp.mkdir(*0xcd00,0x1ff);\n                        sym.imp.mkdir(*0xcd04,0x1ff);\n                        sym.imp.mkdir(*0xcd08,0x1ff);\n                        sym.imp.mkdir(*0xcd0c,0x1ff);\n                        sym.imp.mkdir(*0xcdf0,0x1ff);\n                        sym.imp.system(*0xcd10);\n                        sym.imp.system(*0xcd14);\n                        sym.imp.system(*0xcd18);\n                        sym.imp.system(*0xcd1c);\n                        sym.imp.sleep(1);\n                        sym.imp.system(*0xcd20);\n                    }\n                    sym.imp.mkdir(*0xcc30,0x1ff);\n                    *(iVar24 + -0x1d20) = 0;\n                    sym.imp.mount(*0xcc34,*0xcc30,*0xcdd4);\n                    sym.imp.puts(*0xcc38);\n                    fcn.000150a8();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xce98);\n                    if (iVar6 != 0) {\n                        puVar23 = iVar24 + -0x1ce8;\n                        *(iVar24 + -0x1cf4) = iVar24 + -0x1cc0;\n                    }\n                    else {\n                        *(iVar24 + -0x1cf4) = iVar24 + -0x1cc0;\n                        iVar16 = iVar24 + -0x1cc0 + -0x28;\n                        sym.imp.sleep(1);\n                        sym.imp.system(*0xcd24);\n                        iVar6 = iVar24 + -0x2e8;\n                        sym.imp.system(*0xcd28);\n                        sym.imp.system(*0xcd2c);\n                        sym.imp.system(*0xcd30);\n                        sym.imp.system(*0xcd34);\n                        sym.imp.system(*0xcd38);\n                        sym.imp.system(*0xcd3c);\n                        sym.imp.system(*0xcd40);\n                        sym.imp.system(*0xcd44);\n                        sym.imp.system(*0xcd48);\n                        sym.imp.system(*0xcd4c);\n                        sym.imp.system(*0xcd50);\n                        sym.imp.system(*0xcd54);\n                        sym.imp.system(*0xcd58);\n                        sym.imp.memcpy(iVar16,*0xcd5c,0x4d);\n                        sym.imp.system(iVar16);\n                        sym.imp.memcpy(iVar6,*0xcd60,0x49);\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                        sym.imp.sprintf(iVar6,*0xcd68,uVar11);\n                        sym.imp.system(iVar6);\n                        iVar6 = sym.imp.system(*0xcd6c);\n                        if (iVar6 == -1) {\n                            sym.imp.puts(*0xcd70);\n                        }\n                        iVar6 = sym.imp.mkdir(*0xcd74,0x1ff);\n                        if (iVar6 == -1) {\n                            sym.imp.puts(*0xcd78);\n                        }\n                        sym.imp.acosNvramConfig_get(*0xcd7c);\n                        iVar6 = sym.imp.atoi();\n                        iVar9 = 0;\n                        iVar19 = iVar24 + -0xe8;\n                        do {\n                            iVar13 = iVar9;\n                            iVar9 = iVar9 + 1;\n                            sym.imp.sprintf(iVar19,*0xcd80,iVar13);\n                            iVar13 = sym.imp.mkdir(iVar19,0x1ff);\n                            if (iVar13 + 0 < 0) {\n                                sym.imp.printf(*0xcdcc,iVar19);\n                            }\n                        } while (iVar9 != 0x14);\n                        iVar13 = 0;\n                        iVar9 = 0x61;\n                        *(iVar24 + -0x1d00) = 0;\n                        *(iVar24 + -0x1cf8) = 0x61;\n                        *(iVar24 + -0x1cfc) = 8;\n                        *(iVar24 + -0x1cf0) = iVar16;\n                        while( true ) {\n                            uVar7 = *(iVar24 + -0x1d00);\n                            uVar11 = *(iVar24 + -0x1cfc);\n                            if (iVar9 != 0x70 && iVar9 + -0x70 < 0 == SBORROW4(iVar9,0x70)) {\n                                uVar11 = 0x41;\n                            }\n                            if (uVar7 != 0xff && uVar7 + -0xff < 0 == SBORROW4(uVar7,0xff)) {\n                                uVar7 = uVar7 & 0xff;\n                            }\n                            *(iVar24 + -0x1cfc) = uVar11;\n                            if (-1 < iVar6 + 0) {\n                                uVar14 = *(iVar24 + -0x1cfc);\n                                *(iVar24 + -0x1d08) = 0;\n                                *(iVar24 + -0x1d0c) = iVar6;\n                                *(iVar24 + -0x1cec) = iVar13;\n                                *(iVar24 + -0x1d04) = uVar14 & 0xfffff000;\n                                iVar16 = 0;\n                                *(iVar24 + -0x1d10) = (uVar14 << 0x14) >> 0xc;\n                                do {\n                                    if (iVar16 == 0) {\n                                        sym.imp.sprintf(iVar19,*0xcdb8,iVar13 + 0x61,iVar16);\n                                    }\n                                    else {\n                                        sym.imp.sprintf(iVar19,*0xcdbc,iVar13 + 0x61,iVar16);\n                                    }\n                                    uVar14 = iVar16 + uVar7;\n                                    iVar16 = iVar16 + 1;\n                                    iVar6 = sym.imp.mknod(iVar19,0x6180,\n                                                          (uVar14 & 0xffffff00) << 0xc |\n                                                          uVar14 & 0xff | *(iVar24 + -0x1d10) | *(iVar24 + -0x1d08),\n                                                          uVar14 >> 0x14 | *(iVar24 + -0x1d04));\n                                    if (iVar6 + 0 < 0 != false) {\n                                        sym.imp.printf(*0xcdc0,iVar19);\n                                    }\n                                    iVar6 = *(iVar24 + -0x1d0c);\n                                } while (iVar16 <= iVar6);\n                                iVar13 = *(iVar24 + -0x1cec);\n                            }\n                            sym.imp.sprintf(iVar19,*0xcdc4,iVar13);\n                            iVar16 = sym.imp.mkdir(iVar19,0x1ff);\n                            if (iVar16 + 0 < 0 != false) {\n                                sym.imp.printf(*0xcdcc,iVar19);\n                            }\n                            if (-1 < iVar6 + 0) {\n                                iVar16 = 0;\n                                do {\n                                    sym.imp.sprintf(iVar19,*0xcdc8,iVar13,iVar16);\n                                    iVar9 = sym.imp.mkdir(iVar19,0x1ff);\n                                    iVar16 = iVar16 + 1;\n                                    if (iVar9 + 0 < 0) {\n                                        sym.imp.printf(*0xcdcc,iVar19);\n                                    }\n                                } while (iVar16 <= iVar6);\n                            }\n                            uVar7 = *(iVar24 + -0x1cf8) + 1;\n                            *(iVar24 + -0x1d00) = *(iVar24 + -0x1d00) + 0x10;\n                            *(iVar24 + -0x1cf8) = uVar7 & 0xff;\n                            iVar9 = uVar7;\n                            if (iVar9 == 0x7b) break;\n                            iVar13 = iVar13 + 1;\n                        }\n                        puVar23 = *(iVar24 + -0x1cf0);\n                        sym.imp.mkdir(*0xcdd8,0x1ff);\n                        sym.imp.mkdir(*0xcddc,0x1ff);\n                        sym.imp.mkdir(*0xcde0,0x1ff);\n                        sym.imp.mkdir(*0xcde4,0x1ff);\n                        sym.imp.mkdir(*0xcde8,0x1ff);\n                        *(iVar24 + -0x1e8) = 0;\n                        sym.imp.memset(iVar24 + -0x1e4,0,0x7c);\n                        *(iVar24 + -0xb) = 0;\n                        iVar6 = iVar24 + -0xc;\n                        iVar16 = 0;\n                        uVar4 = *(*0xcdec + 0x28);\n                        *(iVar24 + -10) = 0;\n                        *(iVar24 + -0xc) = uVar4;\n                        do {\n                            uVar7 = sym.imp.rand();\n                            uVar7 = uVar7 & 0x8000003f;\n                            bVar20 = uVar7 < 0;\n                            if (bVar20) {\n                                uVar7 = uVar7 + -1;\n                            }\n                            if (bVar20) {\n                                uVar7 = ~(uVar7 << 0x1a);\n                            }\n                            if (bVar20) {\n                                uVar7 = ~(uVar7 >> 0x1a);\n                            }\n                            if (bVar20) {\n                                uVar7 = uVar7 + 1;\n                            }\n                            bVar22 = SBORROW4(uVar7,9);\n                            bVar20 = uVar7 + -9 < 0;\n                            bVar21 = uVar7 == 9;\n                            if (bVar21 || bVar20 != bVar22) {\n                                uVar7 = uVar7 + 0x30;\n                            }\n                            if (bVar21 || bVar20 != bVar22) {\n                                *(iVar6 + iVar16) = uVar7;\n                            }\n                            if (!bVar21 && bVar20 == bVar22) {\n                                bVar22 = SBORROW4(uVar7,0x23);\n                                bVar20 = uVar7 + -0x23 < 0;\n                                bVar21 = uVar7 == 0x23;\n                                if (bVar21 || bVar20 != bVar22) {\n                                    uVar7 = uVar7 + 0x37;\n                                }\n                                if (bVar21 || bVar20 != bVar22) {\n                                    *(iVar6 + iVar16) = uVar7;\n                                }\n                                if (!bVar21 && bVar20 == bVar22) {\n                                    bVar22 = SBORROW4(uVar7,0x3d);\n                                    bVar20 = uVar7 + -0x3d < 0;\n                                    bVar21 = uVar7 == 0x3d;\n                                    if (bVar21 || bVar20 != bVar22) {\n                                        uVar7 = uVar7 + 0x3d;\n                                    }\n                                    if (bVar21 || bVar20 != bVar22) {\n                                        *(iVar6 + iVar16) = uVar7;\n                                    }\n                                    if (!bVar21 && bVar20 == bVar22) {\n                                        if (uVar7 == 0x3e) {\n                                            *(iVar6 + iVar16) = 0x2e;\n                                        }\n                                        else {\n                                            *(iVar6 + iVar16) = 0x2f;\n                                        }\n                                    }\n                                }\n                            }\n                            iVar16 = iVar16 + 1;\n                        } while (iVar16 != 2);\n                        iVar16 = sym.imp.access(*0xcdf0,0);\n                        if (iVar16 != 0) {\n                            sym.imp.mkdir(*0xcdf0,0x1ff);\n                        }\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcdf4);\n                        iVar16 = iVar24 + -0x1e8;\n                        uVar11 = sym.imp.crypt(uVar11,iVar6);\n                        sym.imp.strncpy(iVar16,uVar11,0x7f);\n                        iVar6 = sym.imp.fopen(*0xcdf8,*0xce08);\n                        iVar9 = iVar6 + 0;\n                        if (iVar9 == 0) {\n                            sym.imp.puts(*0xceb8);\n                        }\n                        else {\n                            sym.imp.fprintf(iVar6,*0xcdfc,iVar16);\n                            sym.imp.fwrite(*0xce00,1,0x19,iVar9);\n                            sym.imp.fclose(iVar9);\n                        }\n                        iVar6 = sym.imp.fopen(*0xce04,*0xce08);\n                        if (iVar6 + 0 == 0) {\n                            sym.imp.puts(*0xceb4);\n                        }\n                        else {\n                            sym.imp.fprintf(iVar6,*0xce0c,iVar16);\n                            sym.imp.fclose(iVar6 + 0);\n                        }\n                        sym.imp.system(*0xce10);\n                        sym.imp.system(*0xce14);\n                        sym.imp.system(*0xce18);\n                        sym.imp.system(*0xce1c);\n                        sym.imp.system(*0xce20);\n                    }\n                    puVar18 = iVar24 + -1000;\n                    puVar17 = iVar24 + -0x4e8;\n                    sym.imp.memset(puVar18,0,0x100);\n                    sym.imp.memset(puVar17,0,0x100);\n                    uVar11 = (*0xcc3c)[1];\n                    uVar12 = (*0xcc3c)[2];\n                    uVar15 = (*0xcc3c)[3];\n                    *puVar18 = **0xcc3c;\n                    *(iVar24 + -0x3e4) = uVar11;\n                    *(iVar24 + -0x3e0) = uVar12;\n                    *(iVar24 + -0x3dc) = uVar15;\n                    uVar11 = (*0xcc40)[1];\n                    uVar12 = (*0xcc40)[2];\n                    *puVar17 = **0xcc40;\n                    *(iVar24 + -0x4e4) = uVar11;\n                    *(iVar24 + -0x4e0) = uVar12;\n                    *(iVar24 + -0x4de) = uVar12 >> 0x10;\n                    uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                    sym.imp.sprintf(puVar18,*0xcc44,uVar11);\n                    uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                    sym.imp.sprintf(puVar17,*0xcc48,uVar11);\n                    sym.imp.system(puVar18);\n                    sym.imp.system(puVar17);\n                    sym.imp.system(*0xcc4c);\n                    iVar6 = sym.imp.fopen(*0xcc50,*0xcc54);\n                    iVar6 = iVar6 + 0;\n                    if (iVar6 != 0) {\n                        do {\n                            iVar16 = sym.imp.fgets(puVar23,0x1000,iVar6);\n                            if (iVar16 == 0) {\n                                puVar17 = *0xcda8;\n                                goto code_r0x0000d1e4;\n                            }\n                            iVar16 = sym.imp.sscanf(puVar23,*0xcc58,iVar24 + -4);\n                        } while ((iVar16 == 0) || (iVar16 = sym.imp.strstr(puVar23,*0xcdb0), iVar16 == 0));\n                        sym.imp.snprintf(puVar23,0x1000,*0xcc5c,*(iVar24 + -4));\n                        iVar16 = sym.imp.stat(*0xcdd0,iVar24 + -0x1e8);\n                        if (iVar16 != 0) {\n                            sym.imp.mkdir(*0xcdd0,0x1ff);\n                        }\n                        *(iVar24 + -0x1d20) = 0;\n                        iVar16 = sym.imp.mount(puVar23,*0xcdd0,*0xcdd4,0);\n                        if (iVar16 != 0) {\n                            puVar17 = *0xcda8;\n                            sym.imp.fwrite(*0xcdac,1,0x2b,*puVar17);\n                            iVar16 = sym.imp.mtd_erase(*0xcdb0);\n                            if (iVar16 + 0 == 0) {\n                                *(iVar24 + -0x1d20) = 0;\n                                iVar16 = sym.imp.mount(puVar23,*0xcdd0,*0xcdd4,0);\n                                sym.imp.fclose(iVar6);\n                                if (iVar16 == 0) goto code_r0x0000d200;\n                            }\n                            else {\n                                sym.imp.fprintf(*puVar17,*0xcdb4,puVar23,iVar16 + 0);\ncode_r0x0000d1e4:\n                                sym.imp.fclose(iVar6);\n                            }\n                            sym.imp.fprintf(*puVar17,*0xcc9c,puVar23,*0xcdd0);\n                        }\n                        else {\n                            sym.imp.fclose(iVar6);\n                        }\n                    }\ncode_r0x0000d200:\n                    puVar17 = *0xcca0;\n                    sym.imp.system(*0xcca4);\n                    uVar11 = puVar17[1];\n                    uVar12 = puVar17[2];\n                    uVar15 = puVar17[3];\n                    *puVar23 = *puVar17;\n                    puVar23[1] = uVar11;\n                    puVar23[2] = uVar12;\n                    puVar23[3] = uVar15;\n                    sym.imp._eval(puVar23,*0xccb8,0,0);\n                    uVar11 = puVar17[5];\n                    uVar12 = puVar17[6];\n                    uVar15 = puVar17[7];\n                    *puVar23 = puVar17[4];\n                    puVar23[1] = uVar11;\n                    puVar23[2] = uVar12;\n                    puVar23[3] = uVar15;\n                    sym.imp._eval(puVar23,*0xccb8,0,0);\n                    fcn.000111dc();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xcca8);\n                    if (iVar6 == 0) {\n                        sym.imp.sleep(5);\n                        fcn.0001e46c();\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcce0,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.system(*0xce60);\n                        iVar6 = iVar24 + -0x1e8;\n                        sym.imp.system(*0xce64);\n                        sym.imp.system(*0xce68);\n                        sym.imp.system(*0xce6c);\n                        sym.imp.system(*0xce70);\n                        sym.imp.system(*0xce74);\n                        sym.imp.bd_read_eth_mac(iVar24 + -0xc,puVar23);\n                        uVar2 = *(puVar23 + 5);\n                        uVar3 = *(puVar23 + 3);\n                        uVar4 = *(puVar23 + 1);\n                        uVar5 = *(puVar23 + 2);\n                        *(iVar24 + -0x1d1c) = *(puVar23 + 1);\n                        *(iVar24 + -0x1d18) = uVar2;\n                        *(iVar24 + -0x1d20) = uVar3;\n                        sym.imp.sprintf(iVar6,*0xce78,uVar4,uVar5);\n                        sym.imp.system(iVar6);\n                        *(iVar24 + -0x1d1c) = *(iVar24 + -8);\n                        *(iVar24 + -0x1d18) = *(iVar24 + -7);\n                        *(iVar24 + -0x1d20) = *(iVar24 + -9);\n                        sym.imp.sprintf(iVar6,*0xce7c,*(iVar24 + -0xb),*(iVar24 + -10));\n                        sym.imp.system(iVar6);\n                        sym.imp.system(*0xce80);\n                        sym.imp.system(*0xce84);\n                        sym.imp.system(*0xce88);\n                        sym.imp.system(*0xce8c);\n                        sym.imp.system(*0xce90);\n                        sym.imp.sleep(3);\n                        fcn.00013c3c();\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xce94,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xce9c);\n                        }\n                    }\n                    sym.imp.acosNvramConfig_match(*0xccac,*0xce98);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xccb0,*0xce98);\n                    if (iVar6 != 0) {\n                        fcn.0001eb04();\n                    }\n                    iVar6 = *(iVar24 + -0x1cf4);\n                    *(iVar24 + (0xe318 | 0xffff0000)) = *0xccb4;\n                    puVar23[1] = 0;\n                    sym.imp._eval(iVar6 + -0x28,*0xccb8,0,0);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce5c,*0xced4);\n                    }\n                    sym.imp.system(*0xccbc);\n                    fcn.0000b7dc();\n                    iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce40,*0xce3c);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce40,*0xce3c);\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce44,*0xced4);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce44,*0xced4);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce48,*0xce4c);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce48,*0xce4c);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce50,*0xce54);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce50,*0xce54);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce58,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce58,*0xce98);\n                        }\n                        sym.imp.acosNvramConfig_save();\n                    }\n                    sym.imp.system(*0xccc0);\n                    sym.imp.system(*0xccc4);\n                    sym.imp.puts(*0xccc8);\n                    iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce38,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce38,*0xce98);\n                        sym.imp.acosNvramConfig_save();\n                    }\n                    sym.imp.system(*0xcccc);\n                    *(iVar24 + -0x3c) = 0;\n                    sym.imp.stat(*0xccd0,iVar24 + -0x68);\n                    sym.imp.printf(*0xccd4,*(iVar24 + -0x3c));\n                    iVar6 = *(iVar24 + -0x3c);\n                    if (iVar6 != 0) {\n                        return 0;\n                    }\n                    pcVar10 = sym.imp.acosNvramConfig_get(*0xce30);\n                    if (*pcVar10 == 0) {\n                        iVar16 = *pcVar10;\n                        sym.imp.acosNvramConfig_set(*0xce30,*0xced4);\n                        sym.imp.printf(*0xce34,0);\n                    }\n                    else {\n                        sym.imp.acosNvramConfig_get(*0xce30);\n                        iVar16 = sym.imp.atoi();\n                        sym.imp.printf(*0xce34,iVar16);\n                        if (iVar16 != 2 && iVar16 + -2 < 0 == SBORROW4(iVar16,2)) {\n                            sym.imp.printf(*0xce2c,iVar16);\n                            return iVar6;\n                        }\n                    }\n                    *(iVar24 + -0xc) = 0;\n                    sym.imp.sprintf(iVar24 + -0xc,*0xccd8,iVar16 + 1);\n                    sym.imp.acosNvramConfig_set(*0xce30,iVar24 + -0xc);\n                    sym.imp.system(*0xccdc);\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe0);\n                if (iVar16 + 0 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n                    if (iVar6 + 0 != 0) {\n                        sym.imp.agApi_natUnhook(0);\n                        sym.imp.agApi_natLanUnhook(0);\n                        return 0;\n                    }\n                    fcn.00015490();\n                    fcn.0000e884();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe4);\n                if (iVar16 + 0 == 0) {\n                    fcn.0000e884();\n                    fcn.000111dc();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe8);\n                if (iVar16 + 0 == 0) {\n                    fcn.00015490();\n                    fcn.0000e884();\n                    fcn.000150a8();\n                    fcn.000111dc();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbec);\n                if (iVar16 == 0) {\n                    fcn.00013794();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf0);\n                if (iVar16 == 0) {\n                    fcn.00013908();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf4);\n                if (iVar16 == 0) {\n                    fcn.000157c4(3);\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf8);\n                if (iVar16 == 0) {\n                    fcn.0001096c();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbfc);\n                if (iVar16 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xceac);\n                    if (iVar6 != 0) {\n                        sym.imp.sleep(4);\n                    }\n                    fcn.0001e46c();\n                    return 0;\n                }\n                iVar6 = sym.imp.strcmp(iVar6,*0xcc00);\n                if (iVar6 + 0 == 0) {\n                    sym.imp.system(*0xce24);\n                    sym.imp.system(*0xce28);\n                    sym.imp.sleep(2);\n                    fcn.000140d4();\n                    fcn.000149c8();\n                    return 0;\n                }\n            }\n            return 0x16;\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca34,*0xc9a8);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcad8);\n            if (iVar6 != 0) {\n                sym.imp.acosNvramConfig_set(*0xcb00,*0xc9cc);\n            }\n            else {\n                iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcadc);\n                if (iVar6 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcb24);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xcb28,*0xc9cc);\n                    }\n                }\n                else {\n                    sym.imp.acosNvramConfig_set(*0xcae0,*0xc9cc);\n                }\n            }\n            sym.imp.acosNvramConfig_set(*0xca34,*0xc9a8);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca38,*0xca3c);\n        if (iVar6 != 0) {\n            sym.imp.system(*0xcac8);\n            sym.imp.system(*0xcacc);\n            sym.imp.system(*0xcad0);\n            sym.imp.system(*0xcad4);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xca44);\n        if (iVar6 != 0) {\n            sym.imp.acosNvramConfig_set(*0xcac4,*0xc9cc);\n        }\n        else {\n            sym.imp.acosNvramConfig_set(*0xca4c,*0xca48);\n        }\n        sym.imp.acosNvramConfig_set(*0xca50,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca54,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca58,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca5c,*0xc9cc);\n        sym.imp.acosNvramConfig_set(*0xca60,*0xc9cc);\n        sym.imp.acosNvramConfig_match(*0xca64,*0xc9a8);\n        sym.imp.system(*0xca68);\n        sym.imp.system(*0xca6c);\n        sym.imp.system(*0xca70);\n        sym.imp.system(*0xca74);\n        sym.imp.abEnableLanEthernetPort();\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.system(*0xcae4);\n        }\n        else {\n            sym.imp.system(*0xca78);\n        }\n        fcn.0000acf8();\n        sym.imp.acosNvramConfig_get(*0xca7c);\n        iVar6 = sym.imp.atoi();\n        if (iVar6 == 100) {\n            iVar6 = 1;\ncode_r0x0000c3f8:\n            uVar7 = iVar6 * -0x3c;\n        }\n        else {\n            if (iVar6 != 0x65) {\n                if (iVar6 == 0x37) {\n                    *(iVar24 + -0x2e8) = 0xfeb6 | 0xffff0000;\n                    goto code_r0x0000bf24;\n                }\n                if (iVar6 == -0x23) {\n                    *(iVar24 + -0x2e8) = 0xd2;\n                    goto code_r0x0000bf24;\n                }\n                goto code_r0x0000c3f8;\n            }\n            uVar7 = 0xfda8 | 0xffff0000;\n        }\n        *(iVar24 + -0x2e8) = uVar7;\ncode_r0x0000bf24:\n        *(iVar24 + -0x2e4) = 0;\n        *(iVar24 + -8) = 0;\n        *(iVar24 + -0xc) = *(iVar24 + -0x2e8) * 0x3c + (0x2f80 | 0x3e120000);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.settimeofday(iVar24 + -0xc,iVar24 + -0x2e8);\n        }\n        else {\n            iVar6 = sym.imp.settimeofday(0,iVar24 + -0x2e8);\n        }\n        if (iVar6 + 0 < 0 != false) {\n            sym.imp.perror(*0xcb20);\n        }\n        sym.imp.system(*0xca80);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 == 0) {\n            sym.imp.system(*0xcaf0);\n            sym.imp.system(*0xcaf4);\n            sym.imp.system(*0xcaf8);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca84,*0xca88);\n        if (iVar6 == 0) {\n            sym.imp.acosNvramConfig_get(*0xca84);\n            sym.imp.atoi();\n            sym.imp.ambitSetLogFilter();\n        }\n        else {\n            sym.imp.acosNvramConfig_set(*0xca84,*0xca8c);\n            sym.imp.ambitSetLogFilter(0xffff);\n        }\n        iVar6 = sym.imp.fopen(*0xca90,*0xca94);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\n            sym.imp.perror(*0xcb2c);\n        }\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca98,*0xc9a8);\n        if (iVar16 == 0) {\n            sym.imp.fputc(0x30,iVar6);\n        }\n        else {\n            sym.imp.fputc(0x31,iVar6);\n        }\n        iVar16 = iVar24 + -0xce0 + -8;\n        sym.imp.fclose(iVar6);\n        uVar11 = sym.imp.acosNvramConfig_get(*0xca9c);\n        sym.imp.strcpy(iVar16,uVar11);\n        iVar6 = sym.imp.fopen(*0xcaa0,*0xca94);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\n            sym.imp.perror(*0xcb34);\n        }\n        sym.imp.fputs(iVar16,iVar6);\n        sym.imp.fclose(iVar6);\n        iVar6 = sym.imp.fopen(*0xcaa4,*0xca94);\n        if (iVar6 + 0 == 0) {\n            sym.imp.perror(*0xcb30);\n        }\n        sym.imp.fclose(iVar6 + 0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if ((iVar6 == 0) && (iVar6 = sym.imp.acosNvramConfig_match(*0xca98,*0xc9a8), iVar6 != 0)) {\n            sym.imp.system(*0xcaec);\n        }\n        sym.imp.system(*0xcaa8);\n        sym.imp.system(*0xcaac);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xcab0,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.agApi_natSetWanLanConflictFlag(1);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xcab4);\n        if (iVar6 + 0 != 0) {\n            sym.imp.set_led_settings(1);\n            return 0;\n        }\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca08,*0xcab8);\n        if (iVar16 + 0 != 0) {\n            sym.imp.set_led_settings(2);\n            return iVar6 + 0;\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 + 0 == 0) {\n            return iVar6 + 0;\n        }\n        sym.imp.set_led_settings(3);\n        return iVar16 + 0;\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b4,*0xc9a8);\n    if (iVar6 != 0) {\n        fcn.0000acf8();\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9bc);\n        if (iVar6 == 0) goto code_r0x0000bb80;\ncode_r0x0000bb04:\n        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xc9c0,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.acosNvramConfig_set(*0xc9dc,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9e0,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9e8,*0xcac0);\n            sym.imp.acosNvramConfig_set(*0xc9ec,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f0,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f4,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f8,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9c0,*0xc9a8);\n        }\n    }\n    else {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9bc);\n        if (iVar6 != 0) goto code_r0x0000bb04;\ncode_r0x0000bb80:\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d0);\n        if (iVar6 != 0) goto code_r0x0000bb04;\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d4);\n        if ((iVar6 != 0) && (iVar6 = sym.imp.acosNvramConfig_invmatch(*0xc9c0,*0xc9a8), iVar6 != 0)) {\n            sym.imp.acosNvramConfig_set(*0xc9dc,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9e0,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9e8,*0xc9e4);\n            sym.imp.acosNvramConfig_set(*0xc9ec,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f0,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f4,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f8,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9c0,*0xc9a8);\n        }\n    }\n    puVar23 = *0xc9c4;\n    puVar17 = iVar24 + -0x1ce8;\n    uVar11 = (*0xc9c4)[1];\n    uVar12 = (*0xc9c4)[2];\n    puVar18 = *0xc9c4 + 3;\n    *puVar17 = **0xc9c4;\n    *(iVar24 + -0x1ce4) = uVar11;\n    *(iVar24 + -0x1ce0) = uVar12;\n    sym.imp._eval(puVar17,*0xc9c8,0,0);\n    uVar11 = puVar23[4];\n    uVar12 = puVar23[5];\n    *puVar17 = *puVar18;\n    *(iVar24 + -0x1ce4) = uVar11;\n    *(iVar24 + -0x1ce0) = uVar12;\n    sym.imp._eval(puVar17,*0xc9c8,0,0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b4,*0xc9cc);\n    if (iVar6 != 0) {\n        return 0;\n    }\n    sym.imp.convert_wlan_params(0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if (iVar6 + 0 != 0) {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24 + -0x2e8,*0xcb04,9);\n            sym.imp.system(iVar24 + -0x2e8);\n        }\n        sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,1);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 != 0) goto code_r0x0000bc7c;\ncode_r0x0000c1a8:\n        sym.imp.sprintf(iVar24 + -0x2e8,*0xca00,8);\n        sym.imp.system(iVar24 + -0x2e8);\n        sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,iVar6);\n    }\n    else {\n        sym.imp.sprintf(iVar24 + -0x2e8,*0xca00,9);\n        sym.imp.system(iVar24 + -0x2e8);\n        sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,iVar6 + 0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) goto code_r0x0000c1a8;\ncode_r0x0000bc7c:\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24 + -0x2e8,*0xcb04,8);\n            sym.imp.system(iVar24 + -0x2e8);\n        }\n        sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,1);\n    }\n    iVar24 = iVar24 + -0x2e8;\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if ((iVar6 != 0) || (iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8), iVar6 != 0)) {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24,*0xca00,0xb);\n        }\n    }\n    else {\n        sym.imp.sprintf(iVar24,*0xcb04,0xb);\n    }\n    sym.imp.system(iVar24);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d4);\n    if (iVar6 != 0) {\n        sym.imp.restore_guest_led();\n    }\n    sym.imp.load_rf_param();\n    iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc20);\n    if (((iVar6 != 0) && (iVar6 = sym.imp.acosNvramConfig_match(*0xca10,*0xca14), iVar6 != 0)) ||\n       (iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xca18), iVar6 + 0 != 0)) {\n        sym.imp.printf(*0xca20,*0xca1c,0x52c);\n        sym.imp.acosNvramConfig_setPAParam_RU2(1);\n    }\n    else {\n        sym.imp.printf(*0xcafc,*0xca1c,0x531);\n        sym.imp.acosNvramConfig_setPAParam_RU2(0);\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if (iVar6 + 0 == 0) {\n        sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,0);\n        sym.imp.send_wps_led_cmd(0x570d | 0xc0040000,0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) goto code_r0x0000c280;\n    }\n    else {\n        sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca28);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca2c);\n            if (iVar6 != 0) {\n                sym.imp.send_wps_led_cmd(0x570d | 0xc0040000,2);\n            }\n        }\n        else {\n            sym.imp.send_wps_led_cmd(0x570c | 0xc0040000,3);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\ncode_r0x0000c280:\n            sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,iVar6);\n            sym.imp.send_wps_led_cmd(0x570f | 0xc0040000,iVar6);\n            return iVar6;\n        }\n    }\n    sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca28);\n    if (iVar6 + 0 != 0) {\n        sym.imp.send_wps_led_cmd(0x570e | 0xc0040000,3);\n        iVar16 = 0;\n    }\n    else {\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca24,*0xca2c);\n        iVar16 = iVar16 + 0;\n        if (iVar16 != 0) {\n            sym.imp.send_wps_led_cmd(0x570f | 0xc0040000,2);\n            iVar16 = iVar6 + 0;\n        }\n    }\n    return iVar16;\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已经使用 r2 的 izz 命令列出了二进制文件中的所有字符串，识别了潜在的输入点，包括网络接口（如 eth0、br0、ppp0）、文件路径（如 /tmp/uboot.info、/tmp/register.txt）、NVRAM/环境变量（如 lan_ipaddr、wan_ipaddr、pppoe_username）和系统命令（如 system、eval）。随后，我反编译了 main 函数以分析数据流。虽然发现了 NVRAM 变量被用于 system 命令执行的可疑模式（例如，通过 acosNvramConfig_get 获取变量值，然后使用 sprintf 构建命令字符串，最后调用 system），但由于缺乏完整的证据链（如确切的 NVRAM 变量名和远程设置机制），我无法验证一个实际可利用的攻击链。因此，我决定结束当前任务，报告已识别的输入点，并建议进一步分析特定函数（如 nvconfig 或 api 处理函数）以寻找完整的攻击链。\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": \"基于 r2 的 izz 命令和 main 函数反编译分析，我已识别了以下潜在输入点和数据流，但未找到完整且可验证的攻击链。以下是总结：\\n\\n### 输入点识别\\n- **网络接口**：eth0、br0、ppp0 等网络设备名称，可能用于网络配置或数据包处理。\\n- **文件路径**：/tmp/uboot.info、/tmp/register.txt、/tmp/opendns.flag 等临时文件，可能作为配置或数据输入源。\\n- **NVRAM/环境变量**：lan_ipaddr、wan_ipaddr、pppoe_username、pppoe_passwd 等变量，可通过网络接口（如 HTTP API）设置。\\n- **系统命令**：system、eval、strcpy、sprintf 等危险函数被广泛使用，增加了命令注入或缓冲区溢出风险。\\n\\n### 数据流追踪\\n在 main 函数中，观察到 NVRAM 变量（通过 acosNvramConfig_get 获取）被用于构建命令字符串（使用 sprintf），并直接传递给 system 函数执行。例如：\\n```c\\nuVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\\nsym.imp.sprintf(iVar24 + -0x1e8, *0xccfc, *0xccf8, uVar11);\\nsym.imp.system(iVar24 + -0x1e8);\\n```\\n如果 NVRAM 变量（如 *0xcd64）被恶意控制，可能导致命令注入。然而，由于无法验证确切的变量名和远程设置机制，攻击链不完整。\\n\\n### 组件交互分析\\n- NVRAM 操作函数（如 acosNvramConfig_get/set）与系统命令执行（system）交互，可能使外部可控数据影响系统行为。\\n- 函数如 fcn.0001a6fc（对应 nvconfig）和 fcn.0001aae8（对应 api）处理命令行参数，可能暴露 NVRAM 设置接口，但未分析其内部数据流。\\n\\n### 利用链评估\\n未找到完整且可验证的攻击链。潜在漏洞（如命令注入）缺乏以下证据：\\n- **精确的触发条件**：需要确认程序如何被调用（如通过特定命令行参数或系统服务）。\\n- **完整的污点传播**：从网络输入到 NVRAM 变量设置，再到 system 执行的路径未完全追踪。\\n- **可利用性验证**：缺少证据证明 NVRAM 变量可通过远程接口（如 HTTP）设置并触发漏洞。\\n\\n### 建议\\n- 使用 FunctionDelegator 深入分析 nvconfig、api 等函数，追踪命令行参数到 NVRAM 设置的数据流。\\n- 分析网络服务组件（如 httpd）如何处理用户输入并设置 NVRAM 变量。\\n- 使用 r2 进一步检查特定地址（如 0xcd64、0xccfc）对应的字符串，以识别确切的 NVRAM 变量和命令格式。\\n\\n当前未发现实际可利用的漏洞，但识别了潜在风险点。进一步分析可能揭示完整的攻击链。\"\n  },\n  \"status\": \"complete\"\n}"}
{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（sbin）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 'sbin' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: FunctionDelegator\n  Description: \n    函数分析委托器 - 专门分析二进制文件中函数调用链的代理。它的职责是正向追踪函数调用之间的污点数据流。你可以将潜在的外部入口点委托给此代理进行深入追踪。\n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"task\": {\n            \"type\": \"string\",\n            \"description\": \"为子函数创建分析任务时，你的描述必须清楚地包括以下四点：\\n1. **目标函数**：要分析的子函数的名称和地址。\\n2. **污点入口**：污点在子函数中所在的特定寄存器或栈地址（例如，'污点在第一个参数寄存器 r0 中'）。\\n3. **污点来源**：这个污点数据在父函数中是如何产生的（例如，'这个值是父函数 main 通过调用 nvram_get(\\\"lan_ipaddr\\\") 获取的'）。\\n4. **分析目标**：清楚地指出新任务应该追踪这个新的污点入口（例如，'在子函数内追踪 r0'）。\"\n          },\n          \"task_context\": {\n            \"type\": \"string\",\n            \"description\": \"（可选）提供可能影响分析的补充上下文。这些信息不是污点流本身的一部分，但可能影响子函数的执行路径。例如：\\n- '此时寄存器 r2 的值为 0x500，表示最大缓冲区长度。'\\n- '在此调用之前，全局变量 `is_admin` 被设置为 1。'\\n- '在分析期间假设文件已成功打开。'\"\n          }\n        },\n        \"required\": [\n          \"task\"\n        ]\n      },\n      \"description\": \"要执行的函数分析任务列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 用于查询此固件文件系统的所有已知信息。可以查询文件的已知发现以及其他文件的已知发现。你可以优先查询文件的已知发现，然后通过结果链接到其他文件的已知发现。注意：没有发现意味着当前还没有发现。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前具体任务：\n反编译或分析函数 fcn.0001aae8 (地址 0x0001aae8) 以了解其功能，重点关注输入验证、NVRAM 交互和潜在命令注入或缓冲区溢出漏洞。"}
{"role": "assistant", "content": "{\n  \"thought\": \"当前任务是分析函数 fcn.0001aae8 在地址 0x0001aae8，重点关注输入验证、NVRAM 交互和潜在命令注入或缓冲区溢出漏洞。我将使用 r2 工具反编译该函数来获取代码片段，作为分析的起点。基于反编译结果，我将评估数据流和漏洞可能性。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ fcn.0001aae8\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ fcn.0001aae8\"}\n结果：\n int32_t fcn.0001aae8(int32_t param_1,int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint unaff_r4;\n    uint unaff_r5;\n    uint uVar2;\n    uint in_lr;\n    uint *puVar3;\n    int32_t aiStack_34 [8];\n    uchar auStack_14 [8];\n    uint auStack_c [3];\n    \n    *(*0x54 + -4) = in_lr;\n    puVar3 = *0x54 + -4 + -4;\n    *puVar3 = unaff_r5;\n    puVar3 = puVar3 + -4;\n    *puVar3 = unaff_r4;\n    if ((param_1 == 2 || param_1 + -2 < 0 != SBORROW4(param_1,2)) ||\n       (iVar1 = sym.imp.strcmp(*(param_2 + 4),*0x1ac3c), iVar1 != 0)) {\n        sym.imp.puts(*0x1ac4c);\n        iVar1 = 1;\n    }\n    else {\n        uVar2 = *(param_2 + 8);\n        iVar1 = sym.imp.strcmp(uVar2,*0x1ac40);\n        if (iVar1 + 0 == 0) {\n            sym.imp.acosNvramConfig_get(*0x1ac54);\n            sym.imp.puts();\n            iVar1 = iVar1 + 0;\n        }\n        else {\n            iVar1 = sym.imp.strcmp(uVar2,*0x1ac44);\n            if (iVar1 == 0) {\n                iVar1 = sym.imp.acosNvramConfig_match(*0x1ac58,*0x1ac5c);\n                if (iVar1 == 0) {\n                    iVar1 = sym.imp.acosNvramConfig_match(*0x1ac58,*0x1ac60);\n                    if (iVar1 + 0 == 0) {\n                        iVar1 = sym.imp.acosNvramConfig_match(*0x1ac58,*0x1ac68);\n                        if (iVar1 + 0 != 0) {\n                            sym.imp.puts(*0x1ac6c);\n                            return 0;\n                        }\n                        sym.imp.puts(*0x1ac70);\n                        return 0;\n                    }\n                }\n                sym.imp.puts(*0x1ac64);\n                iVar1 = 0;\n            }\n            else {\n                iVar1 = sym.imp.strcmp(uVar2,*0x1ac48);\n                iVar1 = iVar1 + 0;\n                if (iVar1 != 0) {\n                    sym.imp.puts(*0x1ac50);\n                    iVar1 = 1;\n                }\n                else {\n                    *(puVar3 + -0x20) = iVar1;\n                    *(puVar3 + -0x1c) = iVar1;\n                    *(puVar3 + -0x18) = iVar1;\n                    *(puVar3 + -0x14) = iVar1;\n                    *(puVar3 + -0x10) = iVar1;\n                    *(puVar3 + -0xc) = iVar1;\n                    *(puVar3 + -8) = iVar1;\n                    *(puVar3 + -0x28) = iVar1;\n                    *(puVar3 + -0x24) = iVar1;\n                    sym.imp.bd_read_sn(puVar3 + -0x28,0x20);\n                    sym.imp.puts(puVar3 + -0x28);\n                }\n            }\n        }\n    }\n    return iVar1;\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have the decompiled code for function fcn.0001aae8. To understand its functionality and identify vulnerabilities, I need to examine the strings and functions it references. Specifically, I'll look at the addresses used in strcmp calls and the NVRAM-related functions to see what data is being handled. This will help me trace data flow and check for input validation issues, command injection, or buffer overflows. I'll use r2 to print strings at the referenced addresses and then analyze the function behavior.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"ps @ 0x1ac3c; ps @ 0x1ac4c; ps @ 0x1ac40; ps @ 0x1ac44; ps @ 0x1ac48; ps @ 0x1ac50; ps @ 0x1ac54; ps @ 0x1ac58; ps @ 0x1ac5c; ps @ 0x1ac60; ps @ 0x1ac68; ps @ 0x1ac6c; ps @ 0x1ac70\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"ps @ 0x1ac3c; ps @ 0x1ac4c; ps @ 0x1ac40; ps @ 0x1ac44; ps @ 0x1ac48; ps @ 0x1ac50; ps @ 0x1ac54; ps @ 0x1ac58; ps @ 0x1ac5c; ps @ 0x1ac60; ps @ 0x1ac68; ps @ 0x1ac6c; ps @ 0x1ac70\"}\n结果：\n la\n\n\n(c\n<c\n\n\\\\\n4\n@\nT\n\n\n4c", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the decompiled code of function fcn.0001aae8 and examined the referenced strings. The function appears to handle command-line arguments, with specific checks for strings like 'la', '<c', '\\\\\\\\', and '@'. Key observations:\\n- When argv[2] is '@', the function calls bd_read_sn with a stack buffer of size 0x20 (32 bytes) and then prints the buffer. This could be a buffer overflow if bd_read_sn does not respect the size limit or if it reads from a controllable source.\\n- There are NVRAM interactions via acosNvramConfig_get and acosNvramConfig_match, but the data is not directly used in a vulnerable manner in this function.\\n- No command injection is evident, as there are no system calls or command execution.\\n\\nTo assess exploitability, I need to:\\n1. Analyze the bd_read_sn function to understand its behavior and if it can overflow the buffer.\\n2. Check if the input source for bd_read_sn is attacker-controllable.\\n3. Trace the data flow to see if there's a complete attack chain.\\n\\nI'll use r2 to get information about bd_read_sn and check for cross-references to understand the context. If bd_read_sn is unsafe or the data is controllable, this could lead to a buffer overflow.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"is | grep bd_read_sn\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"is | grep bd_read_sn\"}\n结果：\n 43  0x00002374 0x0000a374 GLOBAL FUNC   16       imp.bd_read_sn", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the decompiled code of function fcn.0001aae8 and the referenced strings. The function handles command-line arguments, with specific checks for strings like 'la', '<c', '\\\\\\\\', and '@'. When argv[2] is '@', it calls bd_read_sn with a stack buffer of size 0x20 (32 bytes) and then prints the buffer. This could indicate a potential buffer overflow if bd_read_sn does not respect the buffer size or reads from an attacker-controllable source. However, bd_read_sn is an imported function, and its behavior is not defined in this binary. To assess exploitability, I need to trace how this function is called and if the command-line arguments are controllable from an external input point. I'll check cross-references to fcn.0001aae8 to understand its invocation context and then analyze bd_read_sn if possible. If no complete chain is found, I'll report the findings with limitations.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"axt fcn.0001aae8\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"axt fcn.0001aae8\"}\n结果：\n main 0xdf98 [CALL:--x] bl fcn.0001aae8", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the function fcn.0001aae8 and found that it is called from main. To understand the full context and potential exploitability, I need to examine the main function to see how arguments are passed to fcn.0001aae8. This will help determine if the command-line arguments are controllable from an external source, such as user input. I'll decompile the main function to trace the data flow and identify any input validation issues.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ main\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ main\"}\n结果：\n int32_t main(int32_t param_1,int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uchar uVar4;\n    uchar uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    char *pcVar10;\n    uint uVar11;\n    uint uVar12;\n    int32_t iVar13;\n    uint32_t uVar14;\n    uint uVar15;\n    uint unaff_r4;\n    int32_t iVar16;\n    uint *puVar17;\n    uint unaff_r5;\n    uint *puVar18;\n    int32_t iVar19;\n    uint unaff_r6;\n    uint unaff_r7;\n    uint unaff_r8;\n    uint unaff_r9;\n    uint unaff_r10;\n    uint unaff_r11;\n    uint in_lr;\n    bool bVar20;\n    bool bVar21;\n    bool bVar22;\n    uint *puVar23;\n    uint32_t auStack_1d48 [9];\n    uint32_t auStack_1d24 [5];\n    uint auStack_1d10 [10];\n    uchar auStack_1ce8 [4056];\n    uint uStack_d10;\n    uchar auStack_d0c [2044];\n    uint auStack_510 [2];\n    ushort uStack_508;\n    uchar auStack_506 [246];\n    uint auStack_410 [3];\n    uchar auStack_404 [244];\n    uint32_t auStack_310 [64];\n    uint uStack_210;\n    uchar auStack_20c [252];\n    uint uStack_110;\n    uchar auStack_10c [124];\n    uchar auStack_90 [44];\n    int32_t aiStack_64 [12];\n    uint uStack_34;\n    uint uStack_30;\n    uint uStack_2c;\n    uint auStack_28 [10];\n    int32_t iVar24;\n    \n    *(*0x54 + -4) = in_lr;\n    puVar23 = *0x54 + -4 + -4;\n    *puVar23 = unaff_r11;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r10;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r9;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r8;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r7;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r6;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r5;\n    puVar23 = puVar23 + -4;\n    *puVar23 = unaff_r4;\n    iVar24 = puVar23 + -4;\n    *(iVar24 + -0xe8) = 0;\n    sym.imp.memset(iVar24 + -0xe4,0,0x7c);\n    *(iVar24 + -0xce8) = 0;\n    sym.imp.memset(iVar24 + -0xce0 + -4,0,0x7fc);\n    iVar16 = *param_2;\n    iVar6 = sym.imp.strrchr(iVar16,0x2f);\n    if (iVar6 != 0) {\n        iVar16 = iVar6 + 1;\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9ac,*0xc9a8);\n    if (iVar6 != 0) {\n        sym.imp.abDisableLanEthernetPort();\n        sym.imp.acosNvramConfig_set(*0xc9ac,*0xc9cc);\n        sym.imp.sleep(1);\n        sym.imp.acosNvramConfig_save();\n        sym.imp.abEnableLanEthernetPort();\n    }\n    iVar6 = sym.imp.strstr(iVar16,*0xc9b0);\n    if (iVar6 == 0) {\n        iVar6 = sym.imp.strstr(iVar16,*0xca30);\n        if (iVar6 + 0 == 0) {\n            iVar6 = sym.imp.strstr(iVar16,*0xcae8);\n            if (iVar6 != 0) {\n                fcn.0000aae4();\n                return 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcb08);\n            if (iVar6 + 0 != 0) {\n                uVar8 = sym.imp.sys_uptime();\n                uVar7 = uVar8 * (0x8889 | 0x88880000) >> 0x25;\n                uVar14 = uVar7 * (0x8889 | 0x88880000) >> 0x25;\n                uVar1 = uVar14 * (0xaaab | 0xaaaa0000) >> 0x24;\n                if (uVar1 != 0) {\n                    uVar11 = *0xcb0c;\n                    if (uVar1 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb10,uVar1,uVar11);\n                }\n                if (uVar14 != 0) {\n                    iVar6 = uVar14 + (uVar14 * (0xaaab | 0xaaaa0000) >> 0x24) * -0x18;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb14,iVar6,uVar11);\n                }\n                if (uVar7 != 0) {\n                    iVar6 = uVar7 + (uVar7 * (0x8889 | 0x88880000) >> 0x25) * -0x3c;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb18,iVar6,uVar11);\n                }\n                if (uVar8 != 0) {\n                    iVar6 = uVar8 + (uVar8 * (0x8889 | 0x88880000) >> 0x25) * -0x3c;\n                    uVar11 = *0xcb0c;\n                    if (iVar6 == 1) {\n                        uVar11 = *0xca88;\n                    }\n                    sym.imp.printf(*0xcb1c,iVar6,uVar11);\n                }\n                sym.imp.putchar(10);\n                return 0;\n            }\n            iVar9 = sym.imp.strstr(iVar16,*0xcb38);\n            if (iVar9 + 0 != 0) {\n                sym.imp.system(*0xcae8);\n                sym.imp.system(*0xcb3c);\n                sym.imp.system(*0xcb40);\n                sym.imp.system(*0xcb44);\n                sym.imp.system(*0xcb48);\n                sym.imp.system(*0xcb4c);\n                sym.imp.system(*0xcb50);\n                sym.imp.system(*0xcb54);\n                sym.imp.system(*0xcb58);\n                sym.imp.system(*0xcb5c);\n                return iVar6 + 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcb60);\n            if (iVar6 + 0 != 0) {\n                sym.imp.system(*0xcb64);\n                sym.imp.system(*0xcb68);\n                sym.imp.system(*0xcb6c);\n                sym.imp.system(*0xcb70);\n                sym.imp.system(*0xcb74);\n                sym.imp.system(*0xcb78);\n                sym.imp.system(*0xcb7c);\n                sym.imp.system(*0xcb80);\n                sym.imp.system(*0xcb84);\n                sym.imp.system(*0xcb88);\n                sym.imp.system(*0xcb8c);\n                sym.imp.system(*0xcb90);\n                sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,1);\n                sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,1);\n                return iVar9 + 0;\n            }\n            iVar9 = sym.imp.strstr(iVar16,*0xcb94);\n            if (iVar9 != 0) {\n                sym.imp.system(*0xcb98);\n                sym.imp.system(*0xcb9c);\n                sym.imp.system(*0xcba0);\n                sym.imp.system(*0xcba4);\n                sym.imp.system(*0xcba8);\n                sym.imp.system(*0xcbac);\n                sym.imp.system(*0xcbb0);\n                sym.imp.system(*0xcbb4);\n                sym.imp.system(*0xcbb8);\n                sym.imp.system(*0xcbbc);\n                sym.imp.system(*0xcbc0);\n                sym.imp.system(*0xcb90);\n                sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,0);\n                sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,0);\n                return iVar6 + 0;\n            }\n            iVar6 = sym.imp.strstr(iVar16,*0xcbc4);\n            if (iVar6 == 0) {\n                iVar6 = sym.imp.strstr(iVar16,*0xcc04);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.00017360(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcc08);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.00017a00(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcea0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001728c(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcea4);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001cd64(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xceb0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001cfec(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcebc);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001f96c(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec0);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001fa10(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec4);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001fa58();\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcec8);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001d110(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xcecc);\n                if (iVar6 != 0) {\n                    iVar6 = fcn.0001d154(param_1,param_2);\n                    return iVar6;\n                }\n                iVar6 = sym.imp.strstr(iVar16,*0xced0);\n                if (iVar6 == 0) {\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfb4);\n                    if (iVar6 != 0) {\n                        sym.imp.abEnableLanEthernetPort();\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfb8);\n                    if (iVar6 + 0 != 0) {\n                        sym.imp.abDisableLanEthernetPort();\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfbc);\n                    if (iVar6 != 0) {\n                        iVar6 = sym.imp.strcmp(param_2[1],*0xdfc0);\n                        if (iVar6 + 0 == 0) {\n                            fcn.0001fd5c(iVar6 + 1);\n                            return iVar6 + 0;\n                        }\n                        fcn.0001fd5c(0);\n                        return 0;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfc4);\n                    if (iVar6 != 0) {\n                        iVar6 = fcn.0001a6fc(param_1,param_2);\n                        return iVar6;\n                    }\n                    iVar6 = sym.imp.strstr(iVar16,*0xdfc8);\n                    if (iVar6 != 0) {\n                        iVar6 = fcn.0001aae8(param_1,param_2);\n                        return iVar6;\n                    }\n                    sym.imp.printf(*0xdfcc,iVar16);\n                    return 0x16;\n                }\n                if (param_1 == 2) {\n                    iVar6 = sym.imp.strcmp(param_2[1],*0xced4);\n                    if (iVar6 != 0) {\n                        iVar6 = 1;\n                    }\n                    fcn.0001fc6c(iVar6);\n                    return 0x16;\n                }\n            }\n            else {\n                sym.imp.system(*0xcbc8);\n                fcn.0000b8c0();\n                sym.imp.acosNvramConfig_unset(*0xcbcc);\n                sym.imp.acosNvramConfig_set(*0xcc94,*0xc9cc);\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd0,*0xc9a8);\n                if (iVar6 != 0) {\n                    sym.imp.puts(*0xcc60);\n                    sym.imp.acosNvramConfig_set(*0xcc64,*0xce98);\n                    sym.imp.acosNvramConfig_set(*0xcc68,*0xce98);\n                    sym.imp.system(*0xcc6c);\n                    sym.imp.acosNvramConfig_set(*0xcc70,*0xce98);\n                    sym.imp.system(*0xcc74);\n                    sym.imp.system(*0xcc78);\n                    sym.imp.system(*0xcc7c);\n                    sym.imp.system(*0xcc80);\n                    sym.imp.system(*0xcc84);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc88,*0xce98);\n                    if (iVar6 != 0) {\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xcd94,*0xcd84);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcd88);\n                            sym.imp.system(*0xcd8c);\n                            sym.imp.system(*0xcd90);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xcd94,*0xcd98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcd9c);\n                            sym.imp.system(*0xcda0);\n                            sym.imp.system(*0xcda4);\n                        }\n                    }\n                    sym.imp.system(*0xcc8c);\n                    sym.imp.system(*0xcc90);\n                    sym.imp.acosNvramConfig_set(*0xcc94,*0xce98);\n                }\n                sym.imp.sys_set_timezone();\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd4,*0xc9a8);\n                if (iVar6 != 0) {\n                    sym.imp.agApi_SetDayLightSaving(1);\n                }\n                iVar6 = sym.imp.acosNvramConfig_match(*0xcbd8,*0xc9a8);\n                if (iVar6 == 0) {\n                    sym.imp.acosNvramConfig_set(*0xcc98,*0xced4);\n                }\n                iVar6 = param_2[1];\n                if (iVar6 == 0) {\n                    sym.imp.fwrite(*0xcc0c,1,0x34,**0xcda8);\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbdc);\n                if (iVar16 == 0) {\n                    fcn.0001dc60();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xcc10);\n                    if (iVar6 == 0) {\n                        sym.imp.acosNvramConfig_match(*0xcea8,*0xcc14);\n                    }\n                    fcn.0001fc6c(1);\n                    sym.imp.single_session_pppoe_check();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc18);\n                    if ((iVar6 != 0) ||\n                       ((iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc20), iVar6 != 0 &&\n                        (iVar6 = sym.imp.acosNvramConfig_match(*0xccec,*0xccf0), iVar6 != 0)))) {\n                        sym.imp.agApi_fwPolicyClear();\n                        fcn.0000ff08();\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc24,*0xce98);\n                    if (iVar6 == 0) {\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xcce0,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xcce4);\n                            sym.imp.system(*0xcce8);\n                        }\n                    }\n                    else {\n                        sym.imp.system(*0xcce4);\n                        sym.imp.system(*0xcc28);\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcc2c,*0xce98);\n                    if (iVar6 != 0) {\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                        *(iVar24 + -0x1d20) = *0xccf4;\n                        sym.imp.sprintf(iVar24 + -0x1e8,*0xccfc,*0xccf8,uVar11);\n                        sym.imp.system(iVar24 + -0x1e8);\n                        sym.imp.mkdir(*0xcd00,0x1ff);\n                        sym.imp.mkdir(*0xcd04,0x1ff);\n                        sym.imp.mkdir(*0xcd08,0x1ff);\n                        sym.imp.mkdir(*0xcd0c,0x1ff);\n                        sym.imp.mkdir(*0xcdf0,0x1ff);\n                        sym.imp.system(*0xcd10);\n                        sym.imp.system(*0xcd14);\n                        sym.imp.system(*0xcd18);\n                        sym.imp.system(*0xcd1c);\n                        sym.imp.sleep(1);\n                        sym.imp.system(*0xcd20);\n                    }\n                    sym.imp.mkdir(*0xcc30,0x1ff);\n                    *(iVar24 + -0x1d20) = 0;\n                    sym.imp.mount(*0xcc34,*0xcc30,*0xcdd4);\n                    sym.imp.puts(*0xcc38);\n                    fcn.000150a8();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xce98);\n                    if (iVar6 != 0) {\n                        puVar23 = iVar24 + -0x1ce8;\n                        *(iVar24 + -0x1cf4) = iVar24 + -0x1cc0;\n                    }\n                    else {\n                        *(iVar24 + -0x1cf4) = iVar24 + -0x1cc0;\n                        iVar16 = iVar24 + -0x1cc0 + -0x28;\n                        sym.imp.sleep(1);\n                        sym.imp.system(*0xcd24);\n                        iVar6 = iVar24 + -0x2e8;\n                        sym.imp.system(*0xcd28);\n                        sym.imp.system(*0xcd2c);\n                        sym.imp.system(*0xcd30);\n                        sym.imp.system(*0xcd34);\n                        sym.imp.system(*0xcd38);\n                        sym.imp.system(*0xcd3c);\n                        sym.imp.system(*0xcd40);\n                        sym.imp.system(*0xcd44);\n                        sym.imp.system(*0xcd48);\n                        sym.imp.system(*0xcd4c);\n                        sym.imp.system(*0xcd50);\n                        sym.imp.system(*0xcd54);\n                        sym.imp.system(*0xcd58);\n                        sym.imp.memcpy(iVar16,*0xcd5c,0x4d);\n                        sym.imp.system(iVar16);\n                        sym.imp.memcpy(iVar6,*0xcd60,0x49);\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                        sym.imp.sprintf(iVar6,*0xcd68,uVar11);\n                        sym.imp.system(iVar6);\n                        iVar6 = sym.imp.system(*0xcd6c);\n                        if (iVar6 == -1) {\n                            sym.imp.puts(*0xcd70);\n                        }\n                        iVar6 = sym.imp.mkdir(*0xcd74,0x1ff);\n                        if (iVar6 == -1) {\n                            sym.imp.puts(*0xcd78);\n                        }\n                        sym.imp.acosNvramConfig_get(*0xcd7c);\n                        iVar6 = sym.imp.atoi();\n                        iVar9 = 0;\n                        iVar19 = iVar24 + -0xe8;\n                        do {\n                            iVar13 = iVar9;\n                            iVar9 = iVar9 + 1;\n                            sym.imp.sprintf(iVar19,*0xcd80,iVar13);\n                            iVar13 = sym.imp.mkdir(iVar19,0x1ff);\n                            if (iVar13 + 0 < 0) {\n                                sym.imp.printf(*0xcdcc,iVar19);\n                            }\n                        } while (iVar9 != 0x14);\n                        iVar13 = 0;\n                        iVar9 = 0x61;\n                        *(iVar24 + -0x1d00) = 0;\n                        *(iVar24 + -0x1cf8) = 0x61;\n                        *(iVar24 + -0x1cfc) = 8;\n                        *(iVar24 + -0x1cf0) = iVar16;\n                        while( true ) {\n                            uVar7 = *(iVar24 + -0x1d00);\n                            uVar11 = *(iVar24 + -0x1cfc);\n                            if (iVar9 != 0x70 && iVar9 + -0x70 < 0 == SBORROW4(iVar9,0x70)) {\n                                uVar11 = 0x41;\n                            }\n                            if (uVar7 != 0xff && uVar7 + -0xff < 0 == SBORROW4(uVar7,0xff)) {\n                                uVar7 = uVar7 & 0xff;\n                            }\n                            *(iVar24 + -0x1cfc) = uVar11;\n                            if (-1 < iVar6 + 0) {\n                                uVar14 = *(iVar24 + -0x1cfc);\n                                *(iVar24 + -0x1d08) = 0;\n                                *(iVar24 + -0x1d0c) = iVar6;\n                                *(iVar24 + -0x1cec) = iVar13;\n                                *(iVar24 + -0x1d04) = uVar14 & 0xfffff000;\n                                iVar16 = 0;\n                                *(iVar24 + -0x1d10) = (uVar14 << 0x14) >> 0xc;\n                                do {\n                                    if (iVar16 == 0) {\n                                        sym.imp.sprintf(iVar19,*0xcdb8,iVar13 + 0x61,iVar16);\n                                    }\n                                    else {\n                                        sym.imp.sprintf(iVar19,*0xcdbc,iVar13 + 0x61,iVar16);\n                                    }\n                                    uVar14 = iVar16 + uVar7;\n                                    iVar16 = iVar16 + 1;\n                                    iVar6 = sym.imp.mknod(iVar19,0x6180,\n                                                          (uVar14 & 0xffffff00) << 0xc |\n                                                          uVar14 & 0xff | *(iVar24 + -0x1d10) | *(iVar24 + -0x1d08),\n                                                          uVar14 >> 0x14 | *(iVar24 + -0x1d04));\n                                    if (iVar6 + 0 < 0 != false) {\n                                        sym.imp.printf(*0xcdc0,iVar19);\n                                    }\n                                    iVar6 = *(iVar24 + -0x1d0c);\n                                } while (iVar16 <= iVar6);\n                                iVar13 = *(iVar24 + -0x1cec);\n                            }\n                            sym.imp.sprintf(iVar19,*0xcdc4,iVar13);\n                            iVar16 = sym.imp.mkdir(iVar19,0x1ff);\n                            if (iVar16 + 0 < 0 != false) {\n                                sym.imp.printf(*0xcdcc,iVar19);\n                            }\n                            if (-1 < iVar6 + 0) {\n                                iVar16 = 0;\n                                do {\n                                    sym.imp.sprintf(iVar19,*0xcdc8,iVar13,iVar16);\n                                    iVar9 = sym.imp.mkdir(iVar19,0x1ff);\n                                    iVar16 = iVar16 + 1;\n                                    if (iVar9 + 0 < 0) {\n                                        sym.imp.printf(*0xcdcc,iVar19);\n                                    }\n                                } while (iVar16 <= iVar6);\n                            }\n                            uVar7 = *(iVar24 + -0x1cf8) + 1;\n                            *(iVar24 + -0x1d00) = *(iVar24 + -0x1d00) + 0x10;\n                            *(iVar24 + -0x1cf8) = uVar7 & 0xff;\n                            iVar9 = uVar7;\n                            if (iVar9 == 0x7b) break;\n                            iVar13 = iVar13 + 1;\n                        }\n                        puVar23 = *(iVar24 + -0x1cf0);\n                        sym.imp.mkdir(*0xcdd8,0x1ff);\n                        sym.imp.mkdir(*0xcddc,0x1ff);\n                        sym.imp.mkdir(*0xcde0,0x1ff);\n                        sym.imp.mkdir(*0xcde4,0x1ff);\n                        sym.imp.mkdir(*0xcde8,0x1ff);\n                        *(iVar24 + -0x1e8) = 0;\n                        sym.imp.memset(iVar24 + -0x1e4,0,0x7c);\n                        *(iVar24 + -0xb) = 0;\n                        iVar6 = iVar24 + -0xc;\n                        iVar16 = 0;\n                        uVar4 = *(*0xcdec + 0x28);\n                        *(iVar24 + -10) = 0;\n                        *(iVar24 + -0xc) = uVar4;\n                        do {\n                            uVar7 = sym.imp.rand();\n                            uVar7 = uVar7 & 0x8000003f;\n                            bVar20 = uVar7 < 0;\n                            if (bVar20) {\n                                uVar7 = uVar7 + -1;\n                            }\n                            if (bVar20) {\n                                uVar7 = ~(uVar7 << 0x1a);\n                            }\n                            if (bVar20) {\n                                uVar7 = ~(uVar7 >> 0x1a);\n                            }\n                            if (bVar20) {\n                                uVar7 = uVar7 + 1;\n                            }\n                            bVar22 = SBORROW4(uVar7,9);\n                            bVar20 = uVar7 + -9 < 0;\n                            bVar21 = uVar7 == 9;\n                            if (bVar21 || bVar20 != bVar22) {\n                                uVar7 = uVar7 + 0x30;\n                            }\n                            if (bVar21 || bVar20 != bVar22) {\n                                *(iVar6 + iVar16) = uVar7;\n                            }\n                            if (!bVar21 && bVar20 == bVar22) {\n                                bVar22 = SBORROW4(uVar7,0x23);\n                                bVar20 = uVar7 + -0x23 < 0;\n                                bVar21 = uVar7 == 0x23;\n                                if (bVar21 || bVar20 != bVar22) {\n                                    uVar7 = uVar7 + 0x37;\n                                }\n                                if (bVar21 || bVar20 != bVar22) {\n                                    *(iVar6 + iVar16) = uVar7;\n                                }\n                                if (!bVar21 && bVar20 == bVar22) {\n                                    bVar22 = SBORROW4(uVar7,0x3d);\n                                    bVar20 = uVar7 + -0x3d < 0;\n                                    bVar21 = uVar7 == 0x3d;\n                                    if (bVar21 || bVar20 != bVar22) {\n                                        uVar7 = uVar7 + 0x3d;\n                                    }\n                                    if (bVar21 || bVar20 != bVar22) {\n                                        *(iVar6 + iVar16) = uVar7;\n                                    }\n                                    if (!bVar21 && bVar20 == bVar22) {\n                                        if (uVar7 == 0x3e) {\n                                            *(iVar6 + iVar16) = 0x2e;\n                                        }\n                                        else {\n                                            *(iVar6 + iVar16) = 0x2f;\n                                        }\n                                    }\n                                }\n                            }\n                            iVar16 = iVar16 + 1;\n                        } while (iVar16 != 2);\n                        iVar16 = sym.imp.access(*0xcdf0,0);\n                        if (iVar16 != 0) {\n                            sym.imp.mkdir(*0xcdf0,0x1ff);\n                        }\n                        uVar11 = sym.imp.acosNvramConfig_get(*0xcdf4);\n                        iVar16 = iVar24 + -0x1e8;\n                        uVar11 = sym.imp.crypt(uVar11,iVar6);\n                        sym.imp.strncpy(iVar16,uVar11,0x7f);\n                        iVar6 = sym.imp.fopen(*0xcdf8,*0xce08);\n                        iVar9 = iVar6 + 0;\n                        if (iVar9 == 0) {\n                            sym.imp.puts(*0xceb8);\n                        }\n                        else {\n                            sym.imp.fprintf(iVar6,*0xcdfc,iVar16);\n                            sym.imp.fwrite(*0xce00,1,0x19,iVar9);\n                            sym.imp.fclose(iVar9);\n                        }\n                        iVar6 = sym.imp.fopen(*0xce04,*0xce08);\n                        if (iVar6 + 0 == 0) {\n                            sym.imp.puts(*0xceb4);\n                        }\n                        else {\n                            sym.imp.fprintf(iVar6,*0xce0c,iVar16);\n                            sym.imp.fclose(iVar6 + 0);\n                        }\n                        sym.imp.system(*0xce10);\n                        sym.imp.system(*0xce14);\n                        sym.imp.system(*0xce18);\n                        sym.imp.system(*0xce1c);\n                        sym.imp.system(*0xce20);\n                    }\n                    puVar18 = iVar24 + -1000;\n                    puVar17 = iVar24 + -0x4e8;\n                    sym.imp.memset(puVar18,0,0x100);\n                    sym.imp.memset(puVar17,0,0x100);\n                    uVar11 = (*0xcc3c)[1];\n                    uVar12 = (*0xcc3c)[2];\n                    uVar15 = (*0xcc3c)[3];\n                    *puVar18 = **0xcc3c;\n                    *(iVar24 + -0x3e4) = uVar11;\n                    *(iVar24 + -0x3e0) = uVar12;\n                    *(iVar24 + -0x3dc) = uVar15;\n                    uVar11 = (*0xcc40)[1];\n                    uVar12 = (*0xcc40)[2];\n                    *puVar17 = **0xcc40;\n                    *(iVar24 + -0x4e4) = uVar11;\n                    *(iVar24 + -0x4e0) = uVar12;\n                    *(iVar24 + -0x4de) = uVar12 >> 0x10;\n                    uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                    sym.imp.sprintf(puVar18,*0xcc44,uVar11);\n                    uVar11 = sym.imp.acosNvramConfig_get(*0xcd64);\n                    sym.imp.sprintf(puVar17,*0xcc48,uVar11);\n                    sym.imp.system(puVar18);\n                    sym.imp.system(puVar17);\n                    sym.imp.system(*0xcc4c);\n                    iVar6 = sym.imp.fopen(*0xcc50,*0xcc54);\n                    iVar6 = iVar6 + 0;\n                    if (iVar6 != 0) {\n                        do {\n                            iVar16 = sym.imp.fgets(puVar23,0x1000,iVar6);\n                            if (iVar16 == 0) {\n                                puVar17 = *0xcda8;\n                                goto code_r0x0000d1e4;\n                            }\n                            iVar16 = sym.imp.sscanf(puVar23,*0xcc58,iVar24 + -4);\n                        } while ((iVar16 == 0) || (iVar16 = sym.imp.strstr(puVar23,*0xcdb0), iVar16 == 0));\n                        sym.imp.snprintf(puVar23,0x1000,*0xcc5c,*(iVar24 + -4));\n                        iVar16 = sym.imp.stat(*0xcdd0,iVar24 + -0x1e8);\n                        if (iVar16 != 0) {\n                            sym.imp.mkdir(*0xcdd0,0x1ff);\n                        }\n                        *(iVar24 + -0x1d20) = 0;\n                        iVar16 = sym.imp.mount(puVar23,*0xcdd0,*0xcdd4,0);\n                        if (iVar16 != 0) {\n                            puVar17 = *0xcda8;\n                            sym.imp.fwrite(*0xcdac,1,0x2b,*puVar17);\n                            iVar16 = sym.imp.mtd_erase(*0xcdb0);\n                            if (iVar16 + 0 == 0) {\n                                *(iVar24 + -0x1d20) = 0;\n                                iVar16 = sym.imp.mount(puVar23,*0xcdd0,*0xcdd4,0);\n                                sym.imp.fclose(iVar6);\n                                if (iVar16 == 0) goto code_r0x0000d200;\n                            }\n                            else {\n                                sym.imp.fprintf(*puVar17,*0xcdb4,puVar23,iVar16 + 0);\ncode_r0x0000d1e4:\n                                sym.imp.fclose(iVar6);\n                            }\n                            sym.imp.fprintf(*puVar17,*0xcc9c,puVar23,*0xcdd0);\n                        }\n                        else {\n                            sym.imp.fclose(iVar6);\n                        }\n                    }\ncode_r0x0000d200:\n                    puVar17 = *0xcca0;\n                    sym.imp.system(*0xcca4);\n                    uVar11 = puVar17[1];\n                    uVar12 = puVar17[2];\n                    uVar15 = puVar17[3];\n                    *puVar23 = *puVar17;\n                    puVar23[1] = uVar11;\n                    puVar23[2] = uVar12;\n                    puVar23[3] = uVar15;\n                    sym.imp._eval(puVar23,*0xccb8,0,0);\n                    uVar11 = puVar17[5];\n                    uVar12 = puVar17[6];\n                    uVar15 = puVar17[7];\n                    *puVar23 = puVar17[4];\n                    puVar23[1] = uVar11;\n                    puVar23[2] = uVar12;\n                    puVar23[3] = uVar15;\n                    sym.imp._eval(puVar23,*0xccb8,0,0);\n                    fcn.000111dc();\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xcca8);\n                    if (iVar6 == 0) {\n                        sym.imp.sleep(5);\n                        fcn.0001e46c();\n                    }\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcce0,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.system(*0xce60);\n                        iVar6 = iVar24 + -0x1e8;\n                        sym.imp.system(*0xce64);\n                        sym.imp.system(*0xce68);\n                        sym.imp.system(*0xce6c);\n                        sym.imp.system(*0xce70);\n                        sym.imp.system(*0xce74);\n                        sym.imp.bd_read_eth_mac(iVar24 + -0xc,puVar23);\n                        uVar2 = *(puVar23 + 5);\n                        uVar3 = *(puVar23 + 3);\n                        uVar4 = *(puVar23 + 1);\n                        uVar5 = *(puVar23 + 2);\n                        *(iVar24 + -0x1d1c) = *(puVar23 + 1);\n                        *(iVar24 + -0x1d18) = uVar2;\n                        *(iVar24 + -0x1d20) = uVar3;\n                        sym.imp.sprintf(iVar6,*0xce78,uVar4,uVar5);\n                        sym.imp.system(iVar6);\n                        *(iVar24 + -0x1d1c) = *(iVar24 + -8);\n                        *(iVar24 + -0x1d18) = *(iVar24 + -7);\n                        *(iVar24 + -0x1d20) = *(iVar24 + -9);\n                        sym.imp.sprintf(iVar6,*0xce7c,*(iVar24 + -0xb),*(iVar24 + -10));\n                        sym.imp.system(iVar6);\n                        sym.imp.system(*0xce80);\n                        sym.imp.system(*0xce84);\n                        sym.imp.system(*0xce88);\n                        sym.imp.system(*0xce8c);\n                        sym.imp.system(*0xce90);\n                        sym.imp.sleep(3);\n                        fcn.00013c3c();\n                        iVar6 = sym.imp.acosNvramConfig_match(*0xce94,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.system(*0xce9c);\n                        }\n                    }\n                    sym.imp.acosNvramConfig_match(*0xccac,*0xce98);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xccb0,*0xce98);\n                    if (iVar6 != 0) {\n                        fcn.0001eb04();\n                    }\n                    iVar6 = *(iVar24 + -0x1cf4);\n                    *(iVar24 + (0xe318 | 0xffff0000)) = *0xccb4;\n                    puVar23[1] = 0;\n                    sym.imp._eval(iVar6 + -0x28,*0xccb8,0,0);\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce5c,*0xced4);\n                    }\n                    sym.imp.system(*0xccbc);\n                    fcn.0000b7dc();\n                    iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce40,*0xce3c);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce40,*0xce3c);\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce44,*0xced4);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce44,*0xced4);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce48,*0xce4c);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce48,*0xce4c);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce50,*0xce54);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce50,*0xce54);\n                        }\n                        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce58,*0xce98);\n                        if (iVar6 != 0) {\n                            sym.imp.acosNvramConfig_set(*0xce58,*0xce98);\n                        }\n                        sym.imp.acosNvramConfig_save();\n                    }\n                    sym.imp.system(*0xccc0);\n                    sym.imp.system(*0xccc4);\n                    sym.imp.puts(*0xccc8);\n                    iVar6 = sym.imp.acosNvramConfig_invmatch(*0xce38,*0xce98);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xce38,*0xce98);\n                        sym.imp.acosNvramConfig_save();\n                    }\n                    sym.imp.system(*0xcccc);\n                    *(iVar24 + -0x3c) = 0;\n                    sym.imp.stat(*0xccd0,iVar24 + -0x68);\n                    sym.imp.printf(*0xccd4,*(iVar24 + -0x3c));\n                    iVar6 = *(iVar24 + -0x3c);\n                    if (iVar6 != 0) {\n                        return 0;\n                    }\n                    pcVar10 = sym.imp.acosNvramConfig_get(*0xce30);\n                    if (*pcVar10 == 0) {\n                        iVar16 = *pcVar10;\n                        sym.imp.acosNvramConfig_set(*0xce30,*0xced4);\n                        sym.imp.printf(*0xce34,0);\n                    }\n                    else {\n                        sym.imp.acosNvramConfig_get(*0xce30);\n                        iVar16 = sym.imp.atoi();\n                        sym.imp.printf(*0xce34,iVar16);\n                        if (iVar16 != 2 && iVar16 + -2 < 0 == SBORROW4(iVar16,2)) {\n                            sym.imp.printf(*0xce2c,iVar16);\n                            return iVar6;\n                        }\n                    }\n                    *(iVar24 + -0xc) = 0;\n                    sym.imp.sprintf(iVar24 + -0xc,*0xccd8,iVar16 + 1);\n                    sym.imp.acosNvramConfig_set(*0xce30,iVar24 + -0xc);\n                    sym.imp.system(*0xccdc);\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe0);\n                if (iVar16 + 0 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n                    if (iVar6 + 0 != 0) {\n                        sym.imp.agApi_natUnhook(0);\n                        sym.imp.agApi_natLanUnhook(0);\n                        return 0;\n                    }\n                    fcn.00015490();\n                    fcn.0000e884();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe4);\n                if (iVar16 + 0 == 0) {\n                    fcn.0000e884();\n                    fcn.000111dc();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbe8);\n                if (iVar16 + 0 == 0) {\n                    fcn.00015490();\n                    fcn.0000e884();\n                    fcn.000150a8();\n                    fcn.000111dc();\n                    return 0;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbec);\n                if (iVar16 == 0) {\n                    fcn.00013794();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf0);\n                if (iVar16 == 0) {\n                    fcn.00013908();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf4);\n                if (iVar16 == 0) {\n                    fcn.000157c4(3);\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbf8);\n                if (iVar16 == 0) {\n                    fcn.0001096c();\n                    return 0x16;\n                }\n                iVar16 = sym.imp.strcmp(iVar6,*0xcbfc);\n                if (iVar16 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xcea8,*0xceac);\n                    if (iVar6 != 0) {\n                        sym.imp.sleep(4);\n                    }\n                    fcn.0001e46c();\n                    return 0;\n                }\n                iVar6 = sym.imp.strcmp(iVar6,*0xcc00);\n                if (iVar6 + 0 == 0) {\n                    sym.imp.system(*0xce24);\n                    sym.imp.system(*0xce28);\n                    sym.imp.sleep(2);\n                    fcn.000140d4();\n                    fcn.000149c8();\n                    return 0;\n                }\n            }\n            return 0x16;\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca34,*0xc9a8);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcad8);\n            if (iVar6 != 0) {\n                sym.imp.acosNvramConfig_set(*0xcb00,*0xc9cc);\n            }\n            else {\n                iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcadc);\n                if (iVar6 == 0) {\n                    iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xcb24);\n                    if (iVar6 != 0) {\n                        sym.imp.acosNvramConfig_set(*0xcb28,*0xc9cc);\n                    }\n                }\n                else {\n                    sym.imp.acosNvramConfig_set(*0xcae0,*0xc9cc);\n                }\n            }\n            sym.imp.acosNvramConfig_set(*0xca34,*0xc9a8);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca38,*0xca3c);\n        if (iVar6 != 0) {\n            sym.imp.system(*0xcac8);\n            sym.imp.system(*0xcacc);\n            sym.imp.system(*0xcad0);\n            sym.imp.system(*0xcad4);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca40,*0xca44);\n        if (iVar6 != 0) {\n            sym.imp.acosNvramConfig_set(*0xcac4,*0xc9cc);\n        }\n        else {\n            sym.imp.acosNvramConfig_set(*0xca4c,*0xca48);\n        }\n        sym.imp.acosNvramConfig_set(*0xca50,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca54,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca58,*0xc9a8);\n        sym.imp.acosNvramConfig_set(*0xca5c,*0xc9cc);\n        sym.imp.acosNvramConfig_set(*0xca60,*0xc9cc);\n        sym.imp.acosNvramConfig_match(*0xca64,*0xc9a8);\n        sym.imp.system(*0xca68);\n        sym.imp.system(*0xca6c);\n        sym.imp.system(*0xca70);\n        sym.imp.system(*0xca74);\n        sym.imp.abEnableLanEthernetPort();\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.system(*0xcae4);\n        }\n        else {\n            sym.imp.system(*0xca78);\n        }\n        fcn.0000acf8();\n        sym.imp.acosNvramConfig_get(*0xca7c);\n        iVar6 = sym.imp.atoi();\n        if (iVar6 == 100) {\n            iVar6 = 1;\ncode_r0x0000c3f8:\n            uVar7 = iVar6 * -0x3c;\n        }\n        else {\n            if (iVar6 != 0x65) {\n                if (iVar6 == 0x37) {\n                    *(iVar24 + -0x2e8) = 0xfeb6 | 0xffff0000;\n                    goto code_r0x0000bf24;\n                }\n                if (iVar6 == -0x23) {\n                    *(iVar24 + -0x2e8) = 0xd2;\n                    goto code_r0x0000bf24;\n                }\n                goto code_r0x0000c3f8;\n            }\n            uVar7 = 0xfda8 | 0xffff0000;\n        }\n        *(iVar24 + -0x2e8) = uVar7;\ncode_r0x0000bf24:\n        *(iVar24 + -0x2e4) = 0;\n        *(iVar24 + -8) = 0;\n        *(iVar24 + -0xc) = *(iVar24 + -0x2e8) * 0x3c + (0x2f80 | 0x3e120000);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.settimeofday(iVar24 + -0xc,iVar24 + -0x2e8);\n        }\n        else {\n            iVar6 = sym.imp.settimeofday(0,iVar24 + -0x2e8);\n        }\n        if (iVar6 + 0 < 0 != false) {\n            sym.imp.perror(*0xcb20);\n        }\n        sym.imp.system(*0xca80);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if (iVar6 == 0) {\n            sym.imp.system(*0xcaf0);\n            sym.imp.system(*0xcaf4);\n            sym.imp.system(*0xcaf8);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca84,*0xca88);\n        if (iVar6 == 0) {\n            sym.imp.acosNvramConfig_get(*0xca84);\n            sym.imp.atoi();\n            sym.imp.ambitSetLogFilter();\n        }\n        else {\n            sym.imp.acosNvramConfig_set(*0xca84,*0xca8c);\n            sym.imp.ambitSetLogFilter(0xffff);\n        }\n        iVar6 = sym.imp.fopen(*0xca90,*0xca94);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\n            sym.imp.perror(*0xcb2c);\n        }\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca98,*0xc9a8);\n        if (iVar16 == 0) {\n            sym.imp.fputc(0x30,iVar6);\n        }\n        else {\n            sym.imp.fputc(0x31,iVar6);\n        }\n        iVar16 = iVar24 + -0xce0 + -8;\n        sym.imp.fclose(iVar6);\n        uVar11 = sym.imp.acosNvramConfig_get(*0xca9c);\n        sym.imp.strcpy(iVar16,uVar11);\n        iVar6 = sym.imp.fopen(*0xcaa0,*0xca94);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\n            sym.imp.perror(*0xcb34);\n        }\n        sym.imp.fputs(iVar16,iVar6);\n        sym.imp.fclose(iVar6);\n        iVar6 = sym.imp.fopen(*0xcaa4,*0xca94);\n        if (iVar6 + 0 == 0) {\n            sym.imp.perror(*0xcb30);\n        }\n        sym.imp.fclose(iVar6 + 0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xce5c,*0xc9a8);\n        if ((iVar6 == 0) && (iVar6 = sym.imp.acosNvramConfig_match(*0xca98,*0xc9a8), iVar6 != 0)) {\n            sym.imp.system(*0xcaec);\n        }\n        sym.imp.system(*0xcaa8);\n        sym.imp.system(*0xcaac);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xcab0,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.agApi_natSetWanLanConflictFlag(1);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xcab4);\n        if (iVar6 + 0 != 0) {\n            sym.imp.set_led_settings(1);\n            return 0;\n        }\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca08,*0xcab8);\n        if (iVar16 + 0 != 0) {\n            sym.imp.set_led_settings(2);\n            return iVar6 + 0;\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 + 0 == 0) {\n            return iVar6 + 0;\n        }\n        sym.imp.set_led_settings(3);\n        return iVar16 + 0;\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b4,*0xc9a8);\n    if (iVar6 != 0) {\n        fcn.0000acf8();\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9bc);\n        if (iVar6 == 0) goto code_r0x0000bb80;\ncode_r0x0000bb04:\n        iVar6 = sym.imp.acosNvramConfig_invmatch(*0xc9c0,*0xc9a8);\n        if (iVar6 != 0) {\n            sym.imp.acosNvramConfig_set(*0xc9dc,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9e0,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9e8,*0xcac0);\n            sym.imp.acosNvramConfig_set(*0xc9ec,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f0,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f4,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9f8,*0xcabc);\n            sym.imp.acosNvramConfig_set(*0xc9c0,*0xc9a8);\n        }\n    }\n    else {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9bc);\n        if (iVar6 != 0) goto code_r0x0000bb04;\ncode_r0x0000bb80:\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d0);\n        if (iVar6 != 0) goto code_r0x0000bb04;\n        iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d4);\n        if ((iVar6 != 0) && (iVar6 = sym.imp.acosNvramConfig_invmatch(*0xc9c0,*0xc9a8), iVar6 != 0)) {\n            sym.imp.acosNvramConfig_set(*0xc9dc,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9e0,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9e8,*0xc9e4);\n            sym.imp.acosNvramConfig_set(*0xc9ec,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f0,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f4,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9f8,*0xc9d8);\n            sym.imp.acosNvramConfig_set(*0xc9c0,*0xc9a8);\n        }\n    }\n    puVar23 = *0xc9c4;\n    puVar17 = iVar24 + -0x1ce8;\n    uVar11 = (*0xc9c4)[1];\n    uVar12 = (*0xc9c4)[2];\n    puVar18 = *0xc9c4 + 3;\n    *puVar17 = **0xc9c4;\n    *(iVar24 + -0x1ce4) = uVar11;\n    *(iVar24 + -0x1ce0) = uVar12;\n    sym.imp._eval(puVar17,*0xc9c8,0,0);\n    uVar11 = puVar23[4];\n    uVar12 = puVar23[5];\n    *puVar17 = *puVar18;\n    *(iVar24 + -0x1ce4) = uVar11;\n    *(iVar24 + -0x1ce0) = uVar12;\n    sym.imp._eval(puVar17,*0xc9c8,0,0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b4,*0xc9cc);\n    if (iVar6 != 0) {\n        return 0;\n    }\n    sym.imp.convert_wlan_params(0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if (iVar6 + 0 != 0) {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24 + -0x2e8,*0xcb04,9);\n            sym.imp.system(iVar24 + -0x2e8);\n        }\n        sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,1);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 != 0) goto code_r0x0000bc7c;\ncode_r0x0000c1a8:\n        sym.imp.sprintf(iVar24 + -0x2e8,*0xca00,8);\n        sym.imp.system(iVar24 + -0x2e8);\n        sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,iVar6);\n    }\n    else {\n        sym.imp.sprintf(iVar24 + -0x2e8,*0xca00,9);\n        sym.imp.system(iVar24 + -0x2e8);\n        sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,iVar6 + 0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) goto code_r0x0000c1a8;\ncode_r0x0000bc7c:\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24 + -0x2e8,*0xcb04,8);\n            sym.imp.system(iVar24 + -0x2e8);\n        }\n        sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,1);\n    }\n    iVar24 = iVar24 + -0x2e8;\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if ((iVar6 != 0) || (iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8), iVar6 != 0)) {\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca08,*0xca0c);\n        if (iVar6 == 0) {\n            sym.imp.sprintf(iVar24,*0xca00,0xb);\n        }\n    }\n    else {\n        sym.imp.sprintf(iVar24,*0xcb04,0xb);\n    }\n    sym.imp.system(iVar24);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9b8,*0xc9d4);\n    if (iVar6 != 0) {\n        sym.imp.restore_guest_led();\n    }\n    sym.imp.load_rf_param();\n    iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xcc20);\n    if (((iVar6 != 0) && (iVar6 = sym.imp.acosNvramConfig_match(*0xca10,*0xca14), iVar6 != 0)) ||\n       (iVar6 = sym.imp.acosNvramConfig_match(*0xcc1c,*0xca18), iVar6 + 0 != 0)) {\n        sym.imp.printf(*0xca20,*0xca1c,0x52c);\n        sym.imp.acosNvramConfig_setPAParam_RU2(1);\n    }\n    else {\n        sym.imp.printf(*0xcafc,*0xca1c,0x531);\n        sym.imp.acosNvramConfig_setPAParam_RU2(0);\n    }\n    iVar6 = sym.imp.acosNvramConfig_match(*0xc9fc,*0xc9a8);\n    if (iVar6 + 0 == 0) {\n        sym.imp.send_wps_led_cmd(0x5707 | 0xc0040000,0);\n        sym.imp.send_wps_led_cmd(0x570d | 0xc0040000,0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) goto code_r0x0000c280;\n    }\n    else {\n        sym.imp.send_wps_led_cmd(0x5706 | 0xc0040000,0);\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca28);\n        if (iVar6 == 0) {\n            iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca2c);\n            if (iVar6 != 0) {\n                sym.imp.send_wps_led_cmd(0x570d | 0xc0040000,2);\n            }\n        }\n        else {\n            sym.imp.send_wps_led_cmd(0x570c | 0xc0040000,3);\n        }\n        iVar6 = sym.imp.acosNvramConfig_match(*0xca04,*0xc9a8);\n        iVar6 = iVar6 + 0;\n        if (iVar6 == 0) {\ncode_r0x0000c280:\n            sym.imp.send_wps_led_cmd(0x5709 | 0xc0040000,iVar6);\n            sym.imp.send_wps_led_cmd(0x570f | 0xc0040000,iVar6);\n            return iVar6;\n        }\n    }\n    sym.imp.send_wps_led_cmd(0x5708 | 0xc0040000,0);\n    iVar6 = sym.imp.acosNvramConfig_match(*0xca24,*0xca28);\n    if (iVar6 + 0 != 0) {\n        sym.imp.send_wps_led_cmd(0x570e | 0xc0040000,3);\n        iVar16 = 0;\n    }\n    else {\n        iVar16 = sym.imp.acosNvramConfig_match(*0xca24,*0xca2c);\n        iVar16 = iVar16 + 0;\n        if (iVar16 != 0) {\n            sym.imp.send_wps_led_cmd(0x570f | 0xc0040000,2);\n            iVar16 = iVar6 + 0;\n        }\n    }\n    return iVar16;\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed function fcn.0001aae8 at address 0x0001aae8 through decompilation and examination of its context in the main function. The function handles command-line arguments (argc and argv) and performs checks based on argv[1] and argv[2]. Key observations:\\n- When argv[2] is \\\"@\\\", the function calls bd_read_sn with a stack buffer of size 0x20 (32 bytes) and then prints the buffer using puts.\\n- There are NVRAM interactions via acosNvramConfig_get and acosNvramConfig_match, but these are used for conditional checks and do not directly involve user input in a vulnerable manner.\\n- No command injection vulnerabilities are present, as there are no system calls or command execution within this function.\\n- The potential buffer overflow in bd_read_sn depends on the implementation of bd_read_sn, which is an imported function and not defined in this binary. However, the data source for bd_read_sn is internal (likely reading a serial number from hardware or fixed storage), not attacker-controllable via command-line arguments or NVRAM. Therefore, even if bd_read_sn were to overflow the buffer, the lack of attacker control over the data makes exploitation unlikely.\\n- The function is only invoked from main when the program name contains a specific substring, but this does not change the data flow analysis.\\nBased on the evidence, I cannot verify a complete, exploitable attack chain from an untrusted input point to a dangerous operation. Thus, I will report no exploitable vulnerabilities for this function.\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": \"No exploitable vulnerabilities were identified in function fcn.0001aae8 (address 0x0001aae8) based on the analysis of input validation, NVRAM interactions, and potential command injection or buffer overflow issues.\\n\\n### Analysis Summary:\\n- **Input Validation**: The function checks command-line arguments (argv[1] and argv[2]) against hardcoded strings (e.g., \\\"la\\\", \\\"@\\\"). No insufficient validation was found that could lead to vulnerabilities.\\n- **NVRAM Interactions**: Uses acosNvramConfig_get and acosNvramConfig_match for conditional checks, but no user input is passed to these functions in a way that could cause injection or overflow.\\n- **Buffer Overflow**: The call to bd_read_sn with a stack buffer of size 0x20 could theoretically overflow if bd_read_sn does not respect the size limit. However, bd_read_sn is an imported function, and its data source is internal (not attacker-controllable), making exploitation unlikely.\\n- **Command Injection**: No system calls or command execution found in this function.\\n\\n### Core Fields for No Findings:\\n- **description**: No complete, exploitable attack chain was verified. The function uses command-line arguments for comparisons but does not propagate them to dangerous operations. The bd_read_sn call lacks attacker control over the data source, preventing reliable exploitation.\\n- **link_identifiers**: None identified for exploitable vulnerabilities.\\n- **location**: Function fcn.0001aae8 at address 0x0001aae8.\\n- **code_snippet**: Relevant code when argv[2] is \\\"@\\\":\\n  ```c\\n  else {\\n      iVar1 = sym.imp.strcmp(uVar2,*0x1ac48); // uVar2 is argv[2]\\n      iVar1 = iVar1 + 0;\\n      if (iVar1 != 0) {\\n          sym.imp.puts(*0x1ac50);\\n          iVar1 = 1;\\n      } else {\\n          // Stack buffer setup\\n          *(puVar3 + -0x20) = iVar1;\\n          // ... additional stack initialization ...\\n          sym.imp.bd_read_sn(puVar3 + -0x28, 0x20); // Call to bd_read_sn with buffer and size\\n          sym.imp.puts(puVar3 + -0x28); // Print the buffer\\n      }\\n  }\\n  ```\\n- **risk_score**: 0.0 (No exploitable vulnerability verified).\\n- **confidence**: 8.0 (High confidence based on decompilation and data flow analysis; no attacker-controllable input reaches dangerous operations).\\n- **notes**: The function is called from main when the program name matches a specific substring (e.g., via strstr). While bd_read_sn could be unsafe, its data source is not external, so no exploit chain exists. Further analysis would require examining bd_read_sn in other binaries or libraries.\"\n  },\n  \"status\": \"complete\"\n}"}
