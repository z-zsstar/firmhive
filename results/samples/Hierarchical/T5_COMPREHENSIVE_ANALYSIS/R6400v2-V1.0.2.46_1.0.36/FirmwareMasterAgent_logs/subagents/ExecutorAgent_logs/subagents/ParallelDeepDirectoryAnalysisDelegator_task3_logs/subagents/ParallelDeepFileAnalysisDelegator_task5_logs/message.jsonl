{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（sbin）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 'sbin' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 助手可以与文件交互以执行特定的文件分析任务。使用场景：当你需要单步任务的分析结果后再决定下一个分析任务时。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n- Name: ParallelTaskDelegator\n  Description: 每个助手可以与文件交互，并行执行多个文件分析子任务。使用场景：1. 当复杂任务需要分解为多个独立的子任务时。2. 子任务之间没有严格的执行顺序依赖。3. 建议对大规模和复杂任务并行执行多个子任务，提高分析效率。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"description\": \"要执行的子任务的详细描述。每个任务描述都是独立的，应指定分析对象。\"\n      },\n      \"description\": \"要分配给子代理并行执行的独立任务描述列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前任务：\n专注于分析文件 'hdparm' 的内容，寻找可利用的信息和线索。"}
{"role": "assistant", "content": "{\n  \"thought\": \"当前任务是分析文件 'hdparm'，寻找可利用的信息和线索。我需要先确认文件的存在和类型，然后深入分析其代码以识别输入点、数据流和潜在漏洞。我将使用 'execute_shell' 检查文件类型，然后使用 'r2' 进行反编译和代码分析。\",\n  \"action\": \"execute_shell\",\n  \"action_input\": {\n    \"command\": \"file hdparm\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：execute_shell\n参数：{\"command\": \"file hdparm\"}\n结果：\n 退出代码：0\n标准输出：\nhdparm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped\n\n", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have confirmed that 'hdparm' is an ELF 32-bit ARM executable. Now, I need to analyze it for potential vulnerabilities. I'll use Radare2 to disassemble and decompile the binary to identify input points, data flow, and exploitable code paths. Starting with basic analysis to get an overview of functions and strings.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"aaa\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"aaa\"}\n结果：\n [aaa 命令无输出]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"The 'aaa' command in Radare2 has been executed, likely setting up the analysis. Now, I need to gather more detailed information about the binary. I'll list all functions using 'afl' to identify potential entry points and interesting functions. This will help in tracing input sources and data flow.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"afl\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"afl\"}\n结果：\n 0x00008e70    1     12 sym.imp.putchar\n0x00008e7c    1     12 sym.imp.strcpy\n0x00008e88    1     12 sym.imp.ioctl\n0x00008e94    1     12 sym.imp.munlockall\n0x00008ea0    1     12 sym.imp.printf\n0x00008eac    1     12 sym.imp.strerror\n0x00008eb8    1     12 sym.imp.strndup\n0x00008ec4    1     12 sym.imp.stat64\n0x00008ed0    1     12 sym.imp.syscall\n0x00008edc    1     12 sym.imp.munmap\n0x00008ee8    1     12 sym.imp.fscanf\n0x00008ef4    1     12 sym.imp.fgets\n0x00008f00    1     12 sym.imp.memcpy\n0x00008f0c    1     12 sym.imp.setitimer\n0x00008f18    1     12 sym.imp.perror\n0x00008f24    1     12 sym.imp.puts\n0x00008f30    1     12 sym.imp.malloc\n0x00008f3c    1     12 sym.imp.sleep\n0x00008f48    1     12 sym.imp.strtoll\n0x00008f54    1     12 sym.imp.readdir\n0x00008f60    1     12 sym.imp.fflush\n0x00008f6c    1     12 sym.imp.lseek\n0x00008f78    1     12 sym.imp.mmap\n0x00008f84    1     12 sym.imp.abort\n0x00008f90    1     12 sym.imp.fstat64\n0x00008f9c    1     12 sym.imp.mlock\n0x00008fa8    1     12 sym.imp.strtol\n0x00008fb4    1     12 sym.imp.strrchr\n0x00008fc0    1     12 sym.imp.fstat\n0x00008fcc    1     12 sym.imp.fdatasync\n0x00008fd8    1     12 sym.imp.fprintf\n0x00008fe4    1     12 sym.imp.strcat\n0x00008ffc    1     12 sym.imp.read\n0x00009008    1     12 sym.imp.unlink\n0x00009014    1     12 sym.imp.sync\n0x00009020    1     12 sym.imp.strcasecmp\n0x0000902c    1     12 sym.imp.readdir64\n0x00009038    1     12 sym.imp.memcmp\n0x00009044    1     12 sym.imp.__uClibc_main\n0x00009050    1     12 sym.imp.strdup\n0x0000905c    1     12 sym.imp.fopen\n0x00009068    1     12 sym.imp.memset\n0x00009074    1     12 sym.imp.fclose\n0x00009080    1     12 sym.imp.open64\n0x0000908c    1     12 sym.imp.opendir\n0x00009098    1     12 sym.imp.getitimer\n0x000090a4    1     12 sym.imp.strcmp\n0x000090b0    1     12 sym.imp.fgetc\n0x000090bc    1     12 sym.imp.sprintf\n0x000090c8    1     12 sym.imp.scanf\n0x000090d4    1     12 sym.imp.fsync\n0x000090e0    1     12 sym.imp.fputc\n0x000090ec    1     12 sym.imp.__ctype_b_loc\n0x000090f8    1     12 sym.imp.__errno_location\n0x00009104    1     12 sym.imp.exit\n0x00009110    1     12 sym.imp.atoi\n0x0000911c    1     12 sym.imp.munlock\n0x00009128    1     12 sym.imp.strlen\n0x00009134    1     12 sym.imp.lseek64\n0x00009140    1     12 sym.imp.open\n0x0000914c    1     12 sym.imp.fputs\n0x00009158    1     12 sym.imp.closedir\n0x00009170    1     12 sym.imp.close\n0x0000917c    1     12 sym.imp.mlockall\n0x00009188    1     12 sym.imp.raise\n0x00009194    1     12 sym.imp.free\n0x000091a0    1     12 sym.imp.fopen64\n0x000091ac    1     44 entry0\n0x0000922c    3     64 entry.init0\n0x00009164    1     12 loc.imp.__register_frame_info\n0x000091e8    3     56 entry.fini0\n0x00008ff0    1     12 loc.imp.__deregister_frame_info\n0x00009308    3     60 fcn.00009308\n0x00009344    1     92 fcn.00009344\n0x0000fc28  451   8224 fcn.0000fc28\n0x00012ed0   17    352 fcn.00012ed0\n0x00009a24    4    172 fcn.00009a24\n0x0001303c   74   1764 fcn.0001303c\n0x0001402c   50   1224 fcn.0001402c\n0x00013fc8    5     96 fcn.00013fc8\n0x00009db8   19    384 fcn.00009db8\n0x0000a024    4     88 fcn.0000a024\n0x000127b4    3    152 fcn.000127b4\n0x00012674   26    248 fcn.00012674\n0x000128a4   58   1508 fcn.000128a4\n0x0000a4a4    1     20 fcn.0000a4a4\n0x0000a518    1     20 fcn.0000a518\n0x0000a52c    1      8 fcn.0000a52c\n0x0000a534    2     52 fcn.0000a534\n0x0000a53c    1     12 fcn.0000a53c\n0x0000a548    2     32 fcn.0000a548\n0x0000a164    1     76 fcn.0000a164\n0x000093e8    1     52 fcn.000093e8\n0x00009280    5    136 fcn.00009280\n0x00013cc8    3     80 fcn.00013cc8\n0x00013ad4   14    368 fcn.00013ad4\n0x000138b8    9    168 fcn.000138b8\n0x0000a080    4    212 fcn.0000a080\n0x00015b50    5     76 fcn.00015b50\n0x00015c8c   10    184 fcn.00015c8c\n0x00015b9c   10    212 fcn.00015b9c\n0x00015a98    5     92 fcn.00015a98\n0x00015930    1     96 fcn.00015930\n0x000157ac    3     80 fcn.000157ac\n0x000157fc    1    160 fcn.000157fc\n0x00015998    1    124 fcn.00015998\n0x000093a8    1     52 fcn.000093a8\n0x000099a8    1     24 fcn.000099a8\n0x00013d18   25    288 fcn.00013d18\n0x000156b8    1    244 fcn.000156b8\n0x00009b54    5    120 fcn.00009b54\n0x00015d34    2     32 fcn.00015d34\n0x00016c34    3     60 fcn.00016c34\n0x00009ad8    3    116 fcn.00009ad8\n0x000120d8   82   1016 fcn.000120d8\n0x00013780    7    264 fcn.00013780\n0x00009bd4   14    468 fcn.00009bd4\n0x00014fc4   63   1224 fcn.00014fc4\n0x0000a3c8    4     88 fcn.0000a3c8\n0x00015af4    5     92 fcn.00015af4\n0x000158a4    1    132 fcn.000158a4\n0x000096ac    7     76 fcn.000096ac\n0x0000a31c    7    164 fcn.0000a31c\n0x00009ff8    1     40 fcn.00009ff8\n0x00009f5c   10    140 fcn.00009f5c\n0x00016030   11    216 fcn.00016030\n0x00016378   19    592 fcn.00016378\n0x00015d60   27    508 fcn.00015d60\n0x00016658    1     20 fcn.00016658\n0x00016630    1     20 fcn.00016630\n0x0001658c    7    136 fcn.0001658c\n0x00015d5c    1      4 fcn.00015d5c\n0x0001600c    1     36 fcn.0001600c\n0x00016680    1     20 fcn.00016680\n0x00016614    1     28 fcn.00016614\n0x0001610c    6    228 fcn.0001610c\n0x00016694    1     20 fcn.00016694\n0x0000a60c  654  12748 fcn.0000a60c\n0x0000a1c8   11    324 fcn.0000a1c8\n0x00009458   24    432 fcn.00009458\n0x00009614    7    140 fcn.00009614\n0x000147a4    6    148 fcn.000147a4\n0x00014bbc   30    864 fcn.00014bbc\n0x00009428    1     36 fcn.00009428\n0x000096f8   16    344 fcn.000096f8\n0x000098ac   12    224 fcn.000098ac\n0x000099c8    6     88 fcn.000099c8\n0x0000fa70   17    176 fcn.0000fa70\n0x00016844    5    108 fcn.00016844\n0x000168f8   23    408 fcn.000168f8\n0x00016058    1     64 fcn.00016058\n0x0000fba0    7    128 fcn.0000fba0\n0x0000fa10    6     92 fcn.0000fa10\n0x0001284c    1     88 fcn.0001284c\n0x0001258c    6     96 fcn.0001258c\n0x0001276c   10     72 fcn.0001276c\n0x00013888    1     48 fcn.00013888\n0x00013964    1     20 fcn.00013964\n0x00013978   14    332 fcn.00013978\n0x00013e3c   12    204 fcn.00013e3c\n0x00013f14    3     52 fcn.00013f14\n0x00013f4c    1     20 fcn.00013f4c\n0x00014838    7    260 fcn.00014838\n0x00014530   16    484 fcn.00014530\n0x00014950   13    488 fcn.00014950\n0x00016bf0    3     68 fcn.00016bf0\n0x00015550    1     20 fcn.00015550\n0x000155c4    1     20 fcn.000155c4\n0x000155d8    1      8 fcn.000155d8\n0x000155e0    2     52 fcn.000155e0\n0x000155e8    1     12 fcn.000155e8\n0x000155f4    2     32 fcn.000155f4\n0x000162ec   17    196 fcn.000162ec\n0x0001650c   12    112 fcn.0001650c\n0x00016c80    1     60 fcn.00016c80\n0x00016cf8   49   1124 fcn.00016cf8\n0x00016cbc    1     60 fcn.00016cbc\n0x0001715c   44   1020 fcn.0001715c\n0x00008e5c    1     16 fcn.00008e5c", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have the list of functions from 'afl'. Now, I need to identify potential input points and analyze data flow. I'll start by listing strings in the binary to understand what kind of input or data it handles, then decompile key functions like the main entry point to trace how input is processed. I'll focus on functions that use dangerous operations like strcpy, strcat, sprintf, and ioctl.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"iz\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"iz\"}\n结果：\n nth paddr      vaddr      len  size section type    string\n――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0   0x0000f67a 0x0001767a 6    14   .rodata utf16le \\a±À±Á遑\n1   0x0000f6c8 0x000176c8 22   23   .rodata ascii   bad char: '%c' 0x%02x\\n\n2   0x0000f6df 0x000176df 126  127  .rodata ascii   Use of %s is VERY DANGEROUS.\\n%s\\nPlease supply the --yes-i-know-what-i-am-doing flag if you really want this.\\nProgram aborted.\\n\n3   0x0000f75e 0x0001775e 133  134  .rodata ascii   Use of %s is EXTREMELY DANGEROUS.\\n%s\\nPlease also supply the --please-destroy-my-drive flag if you really want this.\\nProgram aborted.\\n\n4   0x0000f7e4 0x000177e4 1160 1161 .rodata ascii   \\nATA Security Commands:\\n Most of these are VERY DANGEROUS and can destroy all of your data!\\n Due to bugs in older Linux kernels, use of these commands may even\\n trigger kernel segfaults or worse.  EXPERIMENT AT YOUR OWN RISK!\\n\\n --security-freeze           Freeze security settings until reset.\\n\\n --security-set-pass PASSWD  Lock drive, using password PASSWD:\\n                                  Use 'NULL' to set empty password.\\n                                  Drive gets locked if user-passwd is selected.\\n --security-unlock   PASSWD  Unlock drive.\\n --security-disable  PASSWD  Disable drive locking.\\n --security-erase    PASSWD  Erase a (locked) drive.\\n --security-erase-enhanced PASSWD   Enhanced-erase a (locked) drive.\\n\\n The above four commands may optionally be preceded by these options:\\n --security-mode  LEVEL      Use LEVEL to select security level:\\n                                  h   high security (default).\\n                                  m   maximum security.\\n --user-master    WHICH      Use WHICH to choose password type:\\n                                  u   user-password (default).\\n                                  m   master-password\\n\n5   0x0000fc6d 0x00017c6d 9    10   .rodata ascii     %s: %s\\n\n6   0x0000fc77 0x00017c77 37   38   .rodata ascii     %s: bad/missing filename parameter\\n\n7   0x0000fc9d 0x00017c9d 47   48   .rodata ascii   read only %u/256 IDENTIFY words from stdin: %s\\n\n8   0x0000fccd 0x00017ccd 15   16   .rodata ascii   missing PASSWD\\n\n9   0x0000fcdd 0x00017cdd 39   40   .rodata ascii   PASSWD too long (must be %d chars max)\\n\n10  0x0000fd05 0x00017d05 4    5    .rodata ascii   NULL\n11  0x0000fd0a 0x00017d0a 23   24   .rodata ascii   security_password=\"%s\"\\n\n12  0x0000fd22 0x00017d22 6    7    .rodata ascii    (on)\\n\n13  0x0000fd29 0x00017d29 7    8    .rodata ascii    (off)\\n\n14  0x0000fd31 0x00017d31 32   33   .rodata ascii    HDIO_DRIVE_CMD(identify) failed\n15  0x0000fd52 0x00017d52 36   37   .rodata ascii    HDIO_DRIVE_CMD(dco_identify) failed\n16  0x0000fd77 0x00017d77 34   35   .rodata ascii    HDIO_DRIVE_CMD(flushcache) failed\n17  0x0000fd9a 0x00017d9a 35   36   .rodata ascii    READ_NATIVE_MAX_ADDRESS_EXT failed\n18  0x0000fdbe 0x00017dbe 80   81   .rodata ascii   READ_NATIVE_MAX_ADDRESS_EXT response: hob={%02x %02x %02x} lob={%02x %02x %02x}\\n\n19  0x0000fe0f 0x00017e0f 31   32   .rodata ascii    READ_NATIVE_MAX_ADDRESS failed\n20  0x0000fe2f 0x00017e2f 13   14   .rodata ascii   the full disk\n21  0x0000fe3d 0x00017e3d 96   97   .rodata ascii   %s is a RAID device: please specify an absolute LBA of a raw member device instead (raid1 only)\\n\n22  0x0000fe9e 0x00017e9e 52   53   .rodata ascii   Device %s has non-zero LBA starting offset of %llu.\\n\n23  0x0000fed3 0x00017ed3 106  107  .rodata ascii   Please use an absolute LBA with the /dev/ entry for the raw device, rather than a partition or raid name.\\n\n24  0x0000ff3e 0x00017f3e 37   38   .rodata ascii   %s is probably a partition of %s (?)\\n\n25  0x0000ff64 0x00017f64 55   56   .rodata ascii   The absolute LBA of sector %llu from %s should be %llu\\n\n26  0x0000ff9c 0x00017f9c 10   11   .rodata ascii   Aborting.\\n\n27  0x0000ffa7 0x00017fa7 13   14   .rodata ascii   read() failed\n28  0x0000ffb5 0x00017fb5 27   28   .rodata ascii   read(%u) returned %u bytes\\n\n29  0x0000ffd1 0x00017fd1 34   35   .rodata ascii   read() hit EOF - device too small\\n\n30  0x0000fff4 0x00017ff4 14   15   .rodata ascii   lseek() failed\n31  0x00010003 0x00018003 16   17   .rodata ascii   BLKFLSBUF failed\n32  0x00010014 0x00018014 37   38   .rodata ascii   trimming %llu sectors from %d ranges\\n\n33  0x0001003a 0x0001803a 6    7    .rodata ascii   FAILED\n34  0x00010041 0x00018041 9    10   .rodata ascii   succeeded\n35  0x0001004b 0x0001804b 67   68   .rodata ascii   \\n%s - get/set hard disk parameters - version v9.43, by Mark Lord.\\n\\n\n36  0x0001008f 0x0001808f 36   37   .rodata ascii   Usage:  %s  [options] [device ...]\\n\\n\n37  0x000100b4 0x000180b4 3734 3735 .rodata ascii   Options:\\n -a   Get/set fs readahead\\n -A   Get/set the drive look-ahead flag (0/1)\\n -b   Get/set bus state (0 == off, 1 == on, 2 == tristate)\\n -B   Set Advanced Power Management setting (1-255)\\n -c   Get/set IDE 32-bit IO setting\\n -C   Check drive power mode status\\n -d   Get/set using_dma flag\\n -D   Enable/disable drive defect management\\n -E   Set cd/dvd drive speed\\n -f   Flush buffer cache for device on exit\\n -F   Flush drive write cache\\n -g   Display drive geometry\\n -h   Display terse usage information\\n -H   Read temperature from drive (Hitachi only)\\n -i   Display drive identification\\n -I   Detailed/current information directly from drive\\n -J   Get/set Western DIgital \"Idle3\" timeout for a WDC \"Green\" drive (DANGEROUS)\\n -k   Get/set keep_settings_over_reset flag (0/1)\\n -K   Set drive keep_features_over_reset flag (0/1)\\n -L   Set drive doorlock (0/1) (removable harddisks only)\\n -m   Get/set multiple sector count\\n -M   Get/set acoustic management (0-254, 128: quiet, 254: fast)\\n -n   Get/set ignore-write-errors flag (0/1)\\n -N   Get/set max visible number of sectors (HPA) (VERY DANGEROUS)\\n -p   Set PIO mode on IDE interface chipset (0,1,2,3,4,...)\\n -P   Set drive prefetch count\\n -q   Change next setting quietly\\n -Q   Get/set DMA queue_depth (if supported)\\n -r   Get/set device readonly flag (DANGEROUS to set)\\n -R   Get/set device write-read-verify flag\\n -s   Set power-up in standby flag (0/1) (DANGEROUS)\\n -S   Set standby (spindown) timeout\\n -t   Perform device read timings\\n -T   Perform cache read timings\\n -u   Get/set unmaskirq flag (0/1)\\n -U   Obsolete\\n -v   Use defaults; same as -acdgkmur for IDE drives\\n -V   Display program version and exit immediately\\n -w   Perform device reset (DANGEROUS)\\n -W   Get/set drive write-caching flag (0/1)\\n -x   Obsolete\\n -X   Set IDE xfer mode (DANGEROUS)\\n -y   Put drive in standby mode\\n -Y   Put drive to sleep\\n -z   Re-read partition table\\n -Z   Disable Seagate auto-powersaving mode\\n --dco-freeze      Freeze/lock current device configuration until next power cycle\\n --dco-identify    Read/dump device configuration identify data\\n --dco-restore     Reset device configuration back to factory defaults\\n --direct          Use O_DIRECT to bypass page cache for timings\\n --drq-hsm-error   Crash system with a \"stuck DRQ\" error (VERY DANGEROUS)\\n --fallocate       Create a file without writing data to disk\\n --fibmap          Show device extents (and fragmentation) for a file\\n --fwdownload            Download firmware file to drive (EXTREMELY DANGEROUS)\\n --fwdownload-mode3      Download firmware using min-size segments (EXTREMELY DANGEROUS)\\n --fwdownload-mode3-max  Download firmware using max-size segments (EXTREMELY DANGEROUS)\\n --fwdownload-mode7      Download firmware using a single segment (EXTREMELY DANGEROUS)\\n --idle-immediate  Idle drive immediately\\n --idle-unload     Idle immediately and unload heads\\n --Istdin          Read identify data from stdin as ASCII hex\\n --Istdout         Write identify data to stdout as ASCII hex\\n --make-bad-sector Deliberately corrupt a sector directly on the media (VERY DANGEROUS)\\n --offset          use with -t, to begin timings at given offset (in GiB) from start of drive\\n --prefer-ata12    Use 12-byte (instead of 16-byte) SAT commands when possible\\n --read-sector     Read and dump (in hex) a sector directly from the media\\n --security-help   Display help for ATA security commands\\n --trim-sector-ranges        Tell SSD firmware to discard unneeded data sectors: lba:count ..\\n --trim-sector-ranges-stdin  Same as above, but reads lba:count pairs from stdin\\n --verbose         Display extra diagnostics from some commands\\n --write-sector    Repair/overwrite a (possibly bad) sector directly on the media (VERY DANGEROUS)\\n\\n\n38  0x00010f4b 0x00018f4b 37   38   .rodata ascii     -%c: bad/missing %s value (%d..%d)\\n\n39  0x00010f71 0x00018f71 29   30   .rodata ascii   could not allocate timing buf\n40  0x00010f8f 0x00018f8f 28   29   .rodata ascii   mlock() failed on timing buf\n41  0x00010fac 0x00018fac 16   17   .rodata ascii   SECURITY_DISABLE\n42  0x00010fbd 0x00018fbd 14   15   .rodata ascii   SECURITY_ERASE\n43  0x00010fcc 0x00018fcc 15   16   .rodata ascii   SECURITY_UNLOCK\n44  0x00010fdc 0x00018fdc 17   18   .rodata ascii   SECURITY_SET_PASS\n45  0x00010fee 0x00018fee 4    5    .rodata ascii   user\n46  0x00010ff3 0x00018ff3 4    5    .rodata ascii   high\n47  0x00010ff8 0x00018ff8 9    10   .rodata ascii   permanent\n48  0x00011002 0x00019002 9    10   .rodata ascii   temporary\n49  0x0001100c 0x0001900c 7    8    .rodata ascii   flagged\n50  0x00011014 0x00019014 6    7    .rodata ascii   pseudo\n51  0x00011022 0x00019022 16   17   .rodata ascii   NVcache_spindown\n52  0x00011033 0x00019033 14   15   .rodata ascii   NVcache_spinup\n53  0x00011042 0x00019042 11   12   .rodata ascii   active/idle\n54  0x0001104e 0x0001904e 6    7    .rodata ascii   on/off\n55  0x00011057 0x00019057 11   12   .rodata ascii    ATA/ATAPI-\n56  0x00011063 0x00019063 9    10   .rodata ascii   O_DIRECT\n57  0x0001106d 0x0001906d 8    9    .rodata ascii   O_DIRECT\n58  0x00011076 0x00019076 8    9    .rodata ascii   buffered\n59  0x0001107f 0x0001907f 5    6    .rodata ascii   \\n%s:\\n\n60  0x00011085 0x00019085 26   27   .rodata ascii   --trim-sector-ranges-stdin\n61  0x000110a0 0x000190a0 51   52   .rodata ascii   This might destroy the drive and/or all data on it.\n62  0x000110d4 0x000190d4 13   14   .rodata ascii   OCZ VERTEX-LE\n63  0x000110e2 0x000190e2 10   11   .rodata ascii   OCZ-VERTEX\n64  0x000110ed 0x000190ed 20   21   .rodata ascii   queue/max_sectors_kb\n65  0x00011102 0x00019102 19   20   .rodata ascii   mmap(MAP_ANONYMOUS)\n66  0x00011116 0x00019116 9    10   .rodata ascii   %llu:%llu\n67  0x00011120 0x00019120 39   40   .rodata ascii   stdin: error at lba:count pair #%d: %s\\n\n68  0x0001114b 0x0001914b 89   90   .rodata ascii   This implementation is not as thorough as the official WDIDLE3.EXE. Use at your own risk!\n69  0x000111a5 0x000191a5 20   21   .rodata ascii    setting wdidle3 to\n70  0x000111ba 0x000191ba 28   29   .rodata ascii    setting fs readahead to %d\\n\n71  0x000111d7 0x000191d7 16   17   .rodata ascii    BLKRASET failed\n72  0x000111e8 0x000191e8 33   34   .rodata ascii    attempting to auto-tune PIO mode\n73  0x0001120a 0x0001920a 34   35   .rodata ascii    attempting to set PIO mode to %d\\n\n74  0x0001122d 0x0001922d 35   36   .rodata ascii    attempting to set MDMA mode to %d\\n\n75  0x00011251 0x00019251 35   36   .rodata ascii    attempting to set UDMA mode to %d\\n\n76  0x00011275 0x00019275 25   26   .rodata ascii    HDIO_SET_PIO_MODE failed\n77  0x0001128f 0x0001928f 38   39   .rodata ascii    setting 32-bit IO_support flag to %d\\n\n78  0x000112b6 0x000192b6 22   23   .rodata ascii    HDIO_SET_32BIT failed\n79  0x000112cd 0x000192cd 25   26   .rodata ascii    setting multcount to %d\\n\n80  0x000112e7 0x000192e7 26   27   .rodata ascii    HDIO_SET_MULTCOUNT failed\n81  0x00011305 0x00019305 141  142  .rodata ascii   Only the old IDE drivers work correctly with -m with kernels up to at least 2.6.29.\\nlibata drives may fail and get hung if you set this flag.\n82  0x00011393 0x00019393 39   40   .rodata ascii    HDIO_DRIVE_CMD(set_multi_count) failed\n83  0x000113bb 0x000193bb 23   24   .rodata ascii    setting readonly to %d\n84  0x000113d3 0x000193d3 16   17   .rodata ascii    BLKROSET failed\n85  0x000113e4 0x000193e4 24   25   .rodata ascii    setting unmaskirq to %d\n86  0x000113fd 0x000193fd 27   28   .rodata ascii    HDIO_SET_UNMASKINTR failed\n87  0x00011419 0x00019419 24   25   .rodata ascii    setting using_dma to %d\n88  0x00011432 0x00019432 20   21   .rodata ascii    HDIO_SET_DMA failed\n89  0x00011447 0x00019447 27   28   .rodata ascii    setting queue_depth to %d\\n\n90  0x00011463 0x00019463 18   19   .rodata ascii   device/queue_depth\n91  0x00011476 0x00019476 21   22   .rodata ascii    setting nowerr to %d\n92  0x0001148c 0x0001948c 23   24   .rodata ascii    HDIO_SET_NOWERR failed\n93  0x000114a4 0x000194a4 28   29   .rodata ascii    setting keep_settings to %d\n94  0x000114c1 0x000194c1 29   30   .rodata ascii    HDIO_SET_KEEPSETTINGS failed\n95  0x000114df 0x000194df 29   30   .rodata ascii    setting drive doorlock to %d\n96  0x000114fd 0x000194fd 32   33   .rodata ascii    HDIO_DRIVE_CMD(doorlock) failed\n97  0x0001151e 0x0001951e 34   35   .rodata ascii    setting drive keep features to %d\n98  0x00011541 0x00019541 36   37   .rodata ascii    HDIO_DRIVE_CMD(keepsettings) failed\n99  0x00011566 0x00019566 39   40   .rodata ascii    setting drive defect management to %d\\n\n100 0x0001158e 0x0001958e 34   35   .rodata ascii    HDIO_DRIVE_CMD(defectmgmt) failed\n101 0x000115b1 0x000195b1 30   31   .rodata ascii    setting drive prefetch to %d\\n\n102 0x000115d0 0x000195d0 35   36   .rodata ascii    HDIO_DRIVE_CMD(setprefetch) failed\n103 0x000115f4 0x000195f4 23   24   .rodata ascii    setting xfermode to %d\n104 0x0001160c 0x0001960c 16   17   .rodata ascii   default PIO mode\n105 0x0001161d 0x0001961d 31   32   .rodata ascii   default PIO mode, disable IORDY\n106 0x0001163d 0x0001963d 23   24   .rodata ascii   PIO flow control mode%u\n107 0x00011655 0x00019655 21   22   .rodata ascii   singleword DMA mode%u\n108 0x0001166b 0x0001966b 20   21   .rodata ascii   multiword DMA mode%u\n109 0x00011680 0x00019680 15   16   .rodata ascii   UltraDMA mode%u\n110 0x00011690 0x00019690 27   28   .rodata ascii   unknown, probably not valid\n111 0x000116ac 0x000196ac 35   36   .rodata ascii    HDIO_DRIVE_CMD(setxfermode) failed\n112 0x000116d0 0x000196d0 35   36   .rodata ascii    setting drive read-lookahead to %d\n113 0x000116f4 0x000196f4 36   37   .rodata ascii    HDIO_DRIVE_CMD(setreadahead) failed\n114 0x00011719 0x00019719 9    10   .rodata ascii    spin-up:\n115 0x00011727 0x00019727 66   67   .rodata ascii   This requires BIOS and kernel support to recognize/boot the drive.\n116 0x0001176a 0x0001976a 34   35   .rodata ascii    setting power-up in standby to %d\n117 0x0001178d 0x0001978d 42   43   .rodata ascii    HDIO_DRIVE_CMD(powerup_in_standby) failed\n118 0x000117b8 0x000197b8 43   44   .rodata ascii    setting Advanced Power Management level to\n119 0x000117e4 0x000197e4 13   14   .rodata ascii    0x%02x (%d)\\n\n120 0x000117f2 0x000197f2 22   23   .rodata ascii    HDIO_DRIVE_CMD failed\n121 0x00011809 0x00019809 27   28   .rodata ascii   setting cd/dvd speed to %d\\n\n122 0x00011825 0x00019825 45   46   .rodata ascii    SET_STREAMING/CDROM_SELECT_SPEED both failed\n123 0x00011853 0x00019853 35   36   .rodata ascii    setting acoustic management to %d\\n\n124 0x00011877 0x00019877 31   32   .rodata ascii    HDIO_DRIVE_CMD:ACOUSTIC failed\n125 0x00011897 0x00019897 33   34   .rodata ascii    setting write-read-verify to %d\\n\n126 0x000118b9 0x000198b9 26   27   .rodata ascii    HDIO_DRIVE_CMD:WRV failed\n127 0x000118d4 0x000198d4 34   35   .rodata ascii    setting drive write-caching to %d\n128 0x000118f7 0x000198f7 32   33   .rodata ascii    HDIO_DRIVE_CMD(setcache) failed\n129 0x00011918 0x00019918 22   23   .rodata ascii    setting standby to %u\n130 0x0001192f 0x0001992f 10   11   .rodata ascii   21 minutes\n131 0x0001193a 0x0001993a 15   16   .rodata ascii   vendor-specific\n132 0x0001194a 0x0001994a 9    10   .rodata ascii   ?reserved\n133 0x00011954 0x00019954 23   24   .rodata ascii   21 minutes + 15 seconds\n134 0x0001196c 0x0001996c 10   11   .rodata ascii   %u minutes\n135 0x0001197b 0x0001997b 10   11   .rodata ascii   %u seconds\n136 0x00011986 0x00019986 8    9    .rodata ascii   %u hours\n137 0x0001198f 0x0001998f 13   14   .rodata ascii   illegal value\n138 0x0001199d 0x0001999d 31   32   .rodata ascii    HDIO_DRIVE_CMD(setidle) failed\n139 0x000119bd 0x000199bd 8    9    .rodata ascii   malloc()\n140 0x000119c6 0x000199c6 40   41   .rodata ascii   BUG in do_set_security(), command1=0x%x\\n\n141 0x000119ef 0x000199ef 43   44   .rodata ascii    Issuing %s command, password=\"%s\", user=%s\n142 0x00011a1b 0x00019a1b 9    10   .rodata ascii   , mode=%s\n143 0x00011a25 0x00019a25 13   14   .rodata ascii   ERASE_PREPARE\n144 0x00011a33 0x00019a33 40   41   .rodata ascii   BUG in do_set_security(), command2=0x%x\\n\n145 0x00011a5c 0x00019a5c 13   14   .rodata ascii   --dco-restore\n146 0x00011a6a 0x00019a6a 224  225  .rodata ascii   You are trying to deliberately reset your drive configuration back to the factory defaults.\\nThis may change the apparent capacity and feature set of the drive, making all data on it inaccessible.\\nYou could lose *everything*.\n147 0x00011b4b 0x00019b4b 28   29   .rodata ascii    issuing DCO restore command\n148 0x00011b68 0x00019b68 35   36   .rodata ascii    HDIO_DRIVE_CMD(dco_restore) failed\n149 0x00011b8c 0x00019b8c 27   28   .rodata ascii    issuing DCO freeze command\n150 0x00011ba8 0x00019ba8 34   35   .rodata ascii    HDIO_DRIVE_CMD(dco_freeze) failed\n151 0x00011bcb 0x00019bcb 32   33   .rodata ascii    issuing security freeze command\n152 0x00011bec 0x00019bec 39   40   .rodata ascii    HDIO_DRIVE_CMD(security_freeze) failed\n153 0x00011c14 0x00019c14 40   41   .rodata ascii    disabling Seagate auto powersaving mode\n154 0x00011c3d 0x00019c3d 38   39   .rodata ascii    HDIO_DRIVE_CMD(seagatepwrsave) failed\n155 0x00011c64 0x00019c64 30   31   .rodata ascii    setting bus state to %d (%s)\\n\n156 0x00011c83 0x00019c83 25   26   .rodata ascii    HDIO_SET_BUSSTATE failed\n157 0x00011c9d 0x00019c9d 42   43   .rodata ascii    setting max visible sectors to %llu (%s)\\n\n158 0x00011cc8 0x00019cc8 7    8    .rodata ascii   -Nnnnnn\n159 0x00011cd0 0x00019cd0 131  132  .rodata ascii   You have requested reducing the apparent size of the drive.\\nThis is a BAD idea, and can easily destroy all of the drive's contents.\n160 0x00011d54 0x00019d54 23   24   .rodata ascii    SET_MAX_ADDRESS failed\n161 0x00011d6c 0x00019d6c 17   18   .rodata ascii   --make-bad-sector\n162 0x00011d7e 0x00019d7e 133  134  .rodata ascii   You are trying to deliberately corrupt a low-level sector on the media.\\nThis is a BAD idea, and can easily result in total data loss.\n163 0x00011e04 0x00019e04 128  129  .rodata ascii   Device does not claim to implement the required WRITE_UNC_EXT command\\nThis operation will probably fail (continuing regardless).\n164 0x00011e85 0x00019e85 46   47   .rodata ascii   Corrupting sector %llu (WRITE_UNC_EXT as %s):\n165 0x00011eb4 0x00019eb4 37   38   .rodata ascii   Corrupting sector %llu (WRITE_LONG):\n166 0x00011eda 0x00019eda 20   21   .rodata ascii   --trim-sector-ranges\n167 0x00011eef 0x00019eef 14   15   .rodata ascii   --write-sector\n168 0x00011efe 0x00019efe 135  136  .rodata ascii   You are trying to deliberately overwrite a low-level sector on the media.\\nThis is a BAD idea, and can easily result in total data loss.\n169 0x00011f86 0x00019f86 24   25   .rodata ascii   re-writing sector %llu:\n170 0x00011f9f 0x00019f9f 54   55   .rodata ascii   --fwdownload requires the raw device, not a partition.\n171 0x00011fd6 0x00019fd6 12   13   .rodata ascii   --fwdownload\n172 0x00011fe3 0x00019fe3 198  199  .rodata ascii   This flag has not been tested with many drives to date.\\nYou are trying to deliberately overwrite the drive firmware with the contents of the specified file.\\nIf this fails, your drive could be toast.\n173 0x000120aa 0x0001a0aa 63   64   .rodata ascii   This might destroy the drive and well as all of the data on it.\n174 0x000120ea 0x0001a0ea 21   22   .rodata ascii   reading sector %llu:\n175 0x00012100 0x0001a100 48   49   .rodata ascii    triggering \"stuck DRQ\" host state machine error\n176 0x00012131 0x0001a131 13   14   .rodata ascii   drq_hsm_error\n177 0x0001213f 0x0001a13f 35   36   .rodata ascii   ata status=0x%02x ata error=0x%02x\\n\n178 0x00012163 0x0001a163 45   46   .rodata ascii    HDIO_DRIVE_CMD(hitachisensecondition) failed\n179 0x00012191 0x0001a191 34   35   .rodata ascii    drive temperature (celsius) is:\n180 0x000121b4 0x0001a1b4 9    10   .rodata ascii   under -20\n181 0x000121be 0x0001a1be 8    9    .rodata ascii   over 107\n182 0x000121c7 0x0001a1c7 34   35   .rodata ascii   \\n drive temperature in range:  %s\\n\n183 0x000121ea 0x0001a1ea 26   27   .rodata ascii    HDIO_GET_MULTCOUNT failed\n184 0x00012205 0x0001a205 21   22   .rodata ascii    multcount     = %2ld\n185 0x0001221b 0x0001a21b 22   23   .rodata ascii    IO_support    =%3ld (\n186 0x00012232 0x0001a232 9    10   .rodata ascii   default)\n187 0x0001223c 0x0001a23c 7    8    .rodata ascii   16-bit)\n188 0x00012244 0x0001a244 7    8    .rodata ascii   32-bit)\n189 0x0001224c 0x0001a24c 14   15   .rodata ascii   32-bit w/sync)\n190 0x0001225b 0x0001a25b 21   22   .rodata ascii   Request-Queue-Bypass)\n191 0x00012271 0x0001a271 4    5    .rodata ascii   ???)\n192 0x00012276 0x0001a276 22   23   .rodata ascii    HDIO_GET_32BIT failed\n193 0x0001228d 0x0001a28d 21   22   .rodata ascii    unmaskirq     = %2ld\n194 0x000122a3 0x0001a2a3 27   28   .rodata ascii    HDIO_GET_UNMASKINTR failed\n195 0x000122bf 0x0001a2bf 21   22   .rodata ascii    using_dma     = %2ld\n196 0x000122d5 0x0001a2d5 19   20   .rodata ascii    (DMA-Assisted-PIO)\n197 0x000122e9 0x0001a2e9 20   21   .rodata ascii    HDIO_GET_DMA failed\n198 0x000122fe 0x0001a2fe 21   22   .rodata ascii    queue_depth   = %2u\\n\n199 0x00012314 0x0001a314 21   22   .rodata ascii    keepsettings  = %2ld\n200 0x0001232a 0x0001a32a 29   30   .rodata ascii    HDIO_GET_KEEPSETTINGS failed\n201 0x00012348 0x0001a348 23   24   .rodata ascii    HDIO_GET_NOWERR failed\n202 0x00012360 0x0001a360 21   22   .rodata ascii    nowerr        = %2ld\n203 0x00012376 0x0001a376 16   17   .rodata ascii    BLKROGET failed\n204 0x00012387 0x0001a387 21   22   .rodata ascii    readonly      = %2ld\n205 0x0001239d 0x0001a39d 16   17   .rodata ascii    BLKRAGET failed\n206 0x000123ae 0x0001a3ae 21   22   .rodata ascii    readahead     = %2ld\n207 0x000123c4 0x0001a3c4 51   52   .rodata ascii    geometry      = %u/%u/%u, sectors = %lld, start =\n208 0x000123f8 0x0001a3f8 5    6    .rodata ascii   %lld\\n\n209 0x000123fe 0x0001a3fe 16   17   .rodata ascii    wdidle3      =\n210 0x0001240f 0x0001a40f 21   22   .rodata ascii    drive state is:  %s\\n\n211 0x00012425 0x0001a425 41   42   .rodata ascii   \\n Model=%.40s, FwRev=%.8s, SerialNo=%.20s\n212 0x0001244f 0x0001a44f 10   11   .rodata ascii   \\n Config={\n213 0x0001245d 0x0001a45d 55   56   .rodata ascii    RawCHS=%u/%u/%u, TrkSize=%u, SectSize=%u, ECCbytes=%u\\n\n214 0x00012495 0x0001a495 4    5    .rodata ascii   %s%u\n215 0x0001249a 0x0001a49a 10   11   .rodata ascii    BuffType=\n216 0x000124a5 0x0001a4a5 4    5    .rodata ascii   %s%s\n217 0x000124aa 0x0001a4aa 15   16   .rodata ascii   , BuffSize=%ukB\n218 0x000124ba 0x0001a4ba 18   19   .rodata ascii   , BuffSize=unknown\n219 0x000124cd 0x0001a4cd 16   17   .rodata ascii   , MaxMultSect=%u\n220 0x000124de 0x0001a4de 11   12   .rodata ascii   , MultSect=\n221 0x000124ea 0x0001a4ea 4    5    .rodata ascii   ?%u?\n222 0x000124ef 0x0001a4ef 5    6    .rodata ascii   pio0\n223 0x000124f5 0x0001a4f5 5    6    .rodata ascii   pio1\n224 0x000124fb 0x0001a4fb 5    6    .rodata ascii   pio2\n225 0x00012501 0x0001a501 9    10   .rodata ascii    (maybe):\n226 0x0001250b 0x0001a50b 29   30   .rodata ascii    CurCHS=%u/%u/%u, CurSects=%u\n227 0x00012529 0x0001a529 8    9    .rodata ascii   , LBA=%s\n228 0x00012532 0x0001a532 15   16   .rodata ascii   , LBAsects=%llu\n229 0x00012542 0x0001a542 6    7    .rodata ascii   sdma0\n230 0x00012549 0x0001a549 6    7    .rodata ascii   sdma1\n231 0x00012550 0x0001a550 6    7    .rodata ascii   sdma2\n232 0x00012557 0x0001a557 6    7    .rodata ascii   sdma?\n233 0x0001255e 0x0001a55e 6    7    .rodata ascii   mdma0\n234 0x00012565 0x0001a565 6    7    .rodata ascii   mdma1\n235 0x0001256c 0x0001a56c 6    7    .rodata ascii   mdma2\n236 0x00012573 0x0001a573 6    7    .rodata ascii   mdma?\n237 0x0001257a 0x0001a57a 8    9    .rodata ascii   \\n IORDY=\n238 0x00012583 0x0001a583 26   27   .rodata ascii   , tPIO={min:%u,w/IORDY:%u}\n239 0x0001259e 0x0001a59e 5    6    .rodata ascii   pio3\n240 0x000125a4 0x0001a5a4 5    6    .rodata ascii   pio4\n241 0x000125aa 0x0001a5aa 5    6    .rodata ascii   pio?\n242 0x000125b0 0x0001a5b0 6    7    .rodata ascii   udma0\n243 0x000125b7 0x0001a5b7 6    7    .rodata ascii   udma1\n244 0x000125be 0x0001a5be 6    7    .rodata ascii   udma2\n245 0x000125c5 0x0001a5c5 6    7    .rodata ascii   udma3\n246 0x000125cc 0x0001a5cc 6    7    .rodata ascii   udma4\n247 0x000125d3 0x0001a5d3 6    7    .rodata ascii   udma5\n248 0x000125da 0x0001a5da 6    7    .rodata ascii   udma6\n249 0x000125e1 0x0001a5e1 22   23   .rodata ascii   , tDMA={min:%u,rec:%u}\n250 0x000125f8 0x0001a5f8 16   17   .rodata ascii   \\n PIO modes:  %s\n251 0x00012609 0x0001a609 16   17   .rodata ascii   \\n DMA modes:  %s\n252 0x0001261a 0x0001a61a 16   17   .rodata ascii   \\n UDMA modes: %s\n253 0x0001262b 0x0001a62b 15   16   .rodata ascii   \\n AdvancedPM=%s\n254 0x0001263b 0x0001a63b 16   17   .rodata ascii   : disabled (255)\n255 0x0001264c 0x0001a64c 17   18   .rodata ascii   : unknown setting\n256 0x0001265e 0x0001a65e 18   19   .rodata ascii   : mode=0x%02X (%u)\n257 0x00012671 0x0001a671 14   15   .rodata ascii    WriteCache=%s\n258 0x00012680 0x0001a680 21   22   .rodata ascii   \\n Drive conforms to:\n259 0x00012696 0x0001a696 4    5    .rodata ascii   %s:\n260 0x0001269b 0x0001a69b 9    10   .rodata ascii   unknown:\n261 0x000126a5 0x0001a6a5 37   38   .rodata ascii   \\n * signifies the current active mode\n262 0x000126cb 0x0001a6cb 33   34   .rodata ascii    no identification info available\n263 0x000126ed 0x0001a6ed 25   26   .rodata ascii    HDIO_GET_IDENTITY failed\n264 0x00012707 0x0001a707 20   21   .rodata ascii    look-ahead    = %2d\n265 0x0001271c 0x0001a71c 30   31   .rodata ascii    look-ahead    = not supported\n266 0x0001273b 0x0001a73b 20   21   .rodata ascii    write-caching = %2d\n267 0x00012750 0x0001a750 30   31   .rodata ascii    write-caching = not supported\n268 0x0001276f 0x0001a76f 13   14   .rodata ascii    APM_level\\t=\n269 0x0001277d 0x0001a77d 46   47   .rodata ascii    acoustic      = %2u (128=quiet ... 254=fast)\\n\n270 0x000127ac 0x0001a7ac 30   31   .rodata ascii    acoustic      = not supported\n271 0x000127cb 0x0001a7cb 25   26   .rodata ascii    write-read-verify = %2u\\n\n272 0x000127e5 0x0001a7e5 34   35   .rodata ascii    write-read-verify = not supported\n273 0x00012808 0x0001a808 25   26   .rodata ascii    HDIO_GET_BUSSTATE failed\n274 0x00012822 0x0001a822 27   28   .rodata ascii    busstate      = %2ld (%s)\\n\n275 0x0001283e 0x0001a83e 26   27   .rodata ascii    max sectors   = %llu/%llu\n276 0x00012859 0x0001a859 16   17   .rodata ascii   , HPA is enabled\n277 0x0001286a 0x0001a86a 17   18   .rodata ascii   , HPA is disabled\n278 0x0001287c 0x0001a87c 7    8    .rodata ascii   (%llu?)\n279 0x00012884 0x0001a884 27   28   .rodata ascii   , HPA setting seems invalid\n280 0x000128a0 0x0001a8a0 30   31   .rodata ascii    (buggy kernel device driver?)\n281 0x000128bf 0x0001a8bf 26   27   .rodata ascii    Timing %scached reads:\n282 0x000128da 0x0001a8da 39   40   .rodata ascii   %3u MB in %5.2f seconds = %6.2f MB/sec\\n\n283 0x00012902 0x0001a902 39   40   .rodata ascii   %3u MB in %5.2f seconds = %6.2f kB/sec\\n\n284 0x0001292a 0x0001a92a 21   22   .rodata ascii    Timing %s disk reads\n285 0x00012940 0x0001a940 17   18   .rodata ascii    (offset %llu GB)\n286 0x00012952 0x0001a952 27   28   .rodata ascii    re-reading partition table\n287 0x0001296e 0x0001a96e 17   18   .rodata ascii    BLKRRPART failed\n288 0x00012980 0x0001a980 31   32   .rodata ascii    issuing idle_immediate command\n289 0x000129a0 0x0001a9a0 38   39   .rodata ascii    HDIO_DRIVE_CMD(idle_immediate) failed\n290 0x000129c7 0x0001a9c7 24   25   .rodata ascii    issuing standby command\n291 0x000129e0 0x0001a9e0 31   32   .rodata ascii    HDIO_DRIVE_CMD(standby) failed\n292 0x00012a00 0x0001aa00 38   39   .rodata ascii    issuing idle_immediate_unload command\n293 0x00012a27 0x0001aa27 38   39   .rodata ascii   TASKFILE(idle_immediate_unload) failed\n294 0x00012a4e 0x0001aa4e 22   23   .rodata ascii    issuing sleep command\n295 0x00012a65 0x0001aa65 29   30   .rodata ascii    HDIO_DRIVE_CMD(sleep) failed\n296 0x00012a83 0x0001aa83 16   17   .rodata ascii    resetting drive\n297 0x00012a94 0x0001aa94 24   25   .rodata ascii    HDIO_DRIVE_RESET failed\n298 0x00012aad 0x0001aaad 21   22   .rodata ascii   filesystem-read-ahead\n299 0x00012ac3 0x0001aac3 10   11   .rodata ascii   look-ahead\n300 0x00012ace 0x0001aace 9    10   .rodata ascii   bus-state\n301 0x00012ad8 0x0001aad8 21   22   .rodata ascii   power-management-mode\n302 0x00012aee 0x0001aaee 9    10   .rodata ascii   32-bit-IO\n303 0x00012af8 0x0001aaf8 10   11   .rodata ascii   dma-enable\n304 0x00012b03 0x0001ab03 18   19   .rodata ascii   defects-management\n305 0x00012b16 0x0001ab16 15   16   .rodata ascii   CDROM/DVD-speed\n306 0x00012b26 0x0001ab26 17   18   .rodata ascii   WDC-idle3-timeout\n307 0x00012b38 0x0001ab38 20   21   .rodata ascii   kernel-keep-settings\n308 0x00012b4d 0x0001ab4d 19   20   .rodata ascii   drive-keep-settings\n309 0x00012b61 0x0001ab61 9    10   .rodata ascii   door-lock\n310 0x00012b6b 0x0001ab6b 14   15   .rodata ascii   multmode-count\n311 0x00012b7a 0x0001ab7a 19   20   .rodata ascii   acoustic-management\n312 0x00012b8e 0x0001ab8e 19   20   .rodata ascii   ignore-write-errors\n313 0x00012ba5 0x0001aba5 24   25   .rodata ascii   bad/missing sector value\n314 0x00012bbe 0x0001abbe 8    9    .rodata ascii   prefetch\n315 0x00012bc7 0x0001abc7 11   12   .rodata ascii   queue-depth\n316 0x00012bd3 0x0001abd3 18   19   .rodata ascii   powerup-in-standby\n317 0x00012be6 0x0001abe6 16   17   .rodata ascii   standby-interval\n318 0x00012bf7 0x0001abf7 9    10   .rodata ascii   read-only\n319 0x00012c01 0x0001ac01 17   18   .rodata ascii   write-read-verify\n320 0x00012c13 0x0001ac13 10   11   .rodata ascii   unmask-irq\n321 0x00012c1e 0x0001ac1e 5    6    .rodata ascii   v9.43\n322 0x00012c24 0x0001ac24 11   12   .rodata ascii   write-cache\n323 0x00012c30 0x0001ac30 7    8    .rodata ascii   verbose\n324 0x00012c38 0x0001ac38 12   13   .rodata ascii   prefer-ata12\n325 0x00012c45 0x0001ac45 21   22   .rodata ascii   GB offset for -t flag\n326 0x00012c5b 0x0001ac5b 26   27   .rodata ascii   yes-i-know-what-i-am-doing\n327 0x00012c76 0x0001ac76 23   24   .rodata ascii   please-destroy-my-drive\n328 0x00012c8e 0x0001ac8e 6    7    .rodata ascii   direct\n329 0x00012c95 0x0001ac95 13   14   .rodata ascii   drq-hsm-error\n330 0x00012ca3 0x0001aca3 10   11   .rodata ascii   dco-freeze\n331 0x00012cae 0x0001acae 12   13   .rodata ascii   dco-identify\n332 0x00012cbb 0x0001acbb 9    10   .rodata ascii   fallocate\n333 0x00012cc5 0x0001acc5 23   24   .rodata ascii   bad/missing block-count\n334 0x00012cdd 0x0001acdd 6    7    .rodata ascii   fibmap\n335 0x00012ce4 0x0001ace4 16   17   .rodata ascii   fwdownload-mode3\n336 0x00012cf5 0x0001acf5 20   21   .rodata ascii   fwdownload-mode3-max\n337 0x00012d0a 0x0001ad0a 16   17   .rodata ascii   fwdownload-mode7\n338 0x00012d1b 0x0001ad1b 14   15   .rodata ascii   idle-immediate\n339 0x00012d2a 0x0001ad2a 11   12   .rodata ascii   idle-unload\n340 0x00012d36 0x0001ad36 6    7    .rodata ascii   %s[%u]\n341 0x00012d3d 0x0001ad3d 24   25   .rodata ascii   bad/missing sector count\n342 0x00012d56 0x0001ad56 13   14   .rodata ascii   repair-sector\n343 0x00012d64 0x0001ad64 11   12   .rodata ascii   read-sector\n344 0x00012d70 0x0001ad70 7    8    .rodata ascii   Istdout\n345 0x00012d78 0x0001ad78 13   14   .rodata ascii   security-mode\n346 0x00012d86 0x0001ad86 11   12   .rodata ascii   user-master\n347 0x00012d92 0x0001ad92 15   16   .rodata ascii   security-freeze\n348 0x00012da2 0x0001ada2 53   54   .rodata ascii   handle_standalone_longarg: num_flags_processed == %d\\n\n349 0x00012dd8 0x0001add8 6    7    .rodata ascii   Istdin\n350 0x00012ddf 0x0001addf 40   41   .rodata ascii   handle_standalone_longarg: argc(%d) > 0\\n\n351 0x00012e08 0x0001ae08 13   14   .rodata ascii   security-help\n352 0x00012e16 0x0001ae16 15   16   .rodata ascii   security-unlock\n353 0x00012e26 0x0001ae26 17   18   .rodata ascii   security-set-pass\n354 0x00012e38 0x0001ae38 16   17   .rodata ascii   security-disable\n355 0x00012e49 0x0001ae49 14   15   .rodata ascii   security-erase\n356 0x00012e58 0x0001ae58 23   24   .rodata ascii   security-erase-enhanced\n357 0x00012e70 0x0001ae70 18   19   .rodata ascii   -X: missing value\\n\n358 0x00012e83 0x0001ae83 9    10   .rodata ascii    HardSect\n359 0x00012e8d 0x0001ae8d 9    10   .rodata ascii    SoftSect\n360 0x00012e97 0x0001ae97 7    8    .rodata ascii    NotMFM\n361 0x00012e9f 0x0001ae9f 12   13   .rodata ascii    HdSw>15uSec\n362 0x00012eac 0x0001aeac 11   12   .rodata ascii    SpinMotCtl\n363 0x00012eb8 0x0001aeb8 6    7    .rodata ascii    Fixed\n364 0x00012ebf 0x0001aebf 11   12   .rodata ascii    Removeable\n365 0x00012ecb 0x0001aecb 10   11   .rodata ascii    DTR<=5Mbs\n366 0x00012ed6 0x0001aed6 9    10   .rodata ascii    DTR>5Mbs\n367 0x00012ee0 0x0001aee0 10   11   .rodata ascii    DTR>10Mbs\n368 0x00012eeb 0x0001aeeb 14   15   .rodata ascii    RotSpdTol>.5%\n369 0x00012efa 0x0001aefa 8    9    .rodata ascii    dStbOff\n370 0x00012f03 0x0001af03 7    8    .rodata ascii    TrkOff\n371 0x00012f0b 0x0001af0b 10   11   .rodata ascii    FmtGapReq\n372 0x00012f16 0x0001af16 12   13   .rodata ascii    nonMagnetic\n373 0x00012f23 0x0001af23 4    5    .rodata ascii   slow\n374 0x00012f28 0x0001af28 6    7    .rodata ascii   medium\n375 0x00012f2f 0x0001af2f 4    5    .rodata ascii   fast\n376 0x00012f34 0x0001af34 4    5    .rodata ascii   eide\n377 0x00012f39 0x0001af39 5    6    .rodata ascii   1Sect\n378 0x00012f3f 0x0001af3f 8    9    .rodata ascii   DualPort\n379 0x00012f48 0x0001af48 13   14   .rodata ascii   DualPortCache\n380 0x00012f56 0x0001af56 4    5    .rodata ascii   pio0\n381 0x00012f5b 0x0001af5b 4    5    .rodata ascii   pio1\n382 0x00012f60 0x0001af60 4    5    .rodata ascii   pio2\n383 0x00012f65 0x0001af65 4    5    .rodata ascii   pio3\n384 0x00012f6a 0x0001af6a 4    5    .rodata ascii   pio4\n385 0x00012f6f 0x0001af6f 4    5    .rodata ascii   pio5\n386 0x00012f74 0x0001af74 4    5    .rodata ascii   pio6\n387 0x00012f79 0x0001af79 4    5    .rodata ascii   pio7\n388 0x00012f7e 0x0001af7e 5    6    .rodata ascii   sdma0\n389 0x00012f84 0x0001af84 5    6    .rodata ascii   sdma1\n390 0x00012f8a 0x0001af8a 5    6    .rodata ascii   sdma2\n391 0x00012f90 0x0001af90 5    6    .rodata ascii   sdma3\n392 0x00012f96 0x0001af96 5    6    .rodata ascii   sdma4\n393 0x00012f9c 0x0001af9c 5    6    .rodata ascii   sdma5\n394 0x00012fa2 0x0001afa2 5    6    .rodata ascii   sdma6\n395 0x00012fa8 0x0001afa8 5    6    .rodata ascii   sdma7\n396 0x00012fae 0x0001afae 5    6    .rodata ascii   mdma3\n397 0x00012fb4 0x0001afb4 5    6    .rodata ascii   mdma4\n398 0x00012fba 0x0001afba 5    6    .rodata ascii   mdma5\n399 0x00012fc0 0x0001afc0 5    6    .rodata ascii   mdma6\n400 0x00012fc6 0x0001afc6 5    6    .rodata ascii   mdma7\n401 0x00012fcc 0x0001afcc 5    6    .rodata ascii   udma7\n402 0x00012fd2 0x0001afd2 8    9    .rodata ascii   tristate\n403 0x00013005 0x0001b005 13   14   .rodata ascii   xdP\\t   %c\\t%s\\n\n404 0x00013013 0x0001b013 9    10   .rodata ascii   *%cdma%u\n405 0x0001301d 0x0001b01d 21   22   .rodata ascii   ATA-8-ACS revision 2d\n406 0x00013033 0x0001b033 21   22   .rodata ascii   ATA-8-ACS revision 3b\n407 0x00013049 0x0001b049 21   22   .rodata ascii   ATA-8-ACS revision 3f\n408 0x0001305f 0x0001b05f 21   22   .rodata ascii   ATA-8-ACS revision 3e\n409 0x00013075 0x0001b075 21   22   .rodata ascii   ATA-8-ACS revision 3c\n410 0x0001308b 0x0001b08b 23   24   .rodata ascii   CompactFlash ATA device\n411 0x000130a3 0x0001b0a3 17   18   .rodata ascii   ATA device, with\n412 0x000130b5 0x0001b0b5 15   16   .rodata ascii   ATAPI %s, with\n413 0x000130c5 0x0001b0c5 79   80   .rodata ascii   Unknown device type:\\n\\tbits 15&14 of general configuration word 0 both set to 1.\n414 0x00013115 0x0001b115 4    5    .rodata ascii   non-\n415 0x0001311a 0x0001b11a 15   16   .rodata ascii   removable media\n416 0x0001312a 0x0001b12a 51   52   .rodata ascii   powers-up in standby; SET FEATURES subcmd spins-up.\n417 0x0001315e 0x0001b15e 78   79   .rodata ascii   \\n\\tWARNING: ID response incomplete.\\n\\tWARNING: Following data may be incorrect.\\n\n418 0x000131ad 0x0001b1ad 6    7    .rodata ascii   \\t%-20s\n419 0x000131b4 0x0001b1b4 13   14   .rodata ascii   Model Number:\n420 0x000131c2 0x0001b1c2 14   15   .rodata ascii   Serial Number:\n421 0x000131d1 0x0001b1d1 18   19   .rodata ascii   Firmware Revision:\n422 0x000131e4 0x0001b1e4 17   18   .rodata ascii   Media Serial Num:\n423 0x000131f6 0x0001b1f6 19   20   .rodata ascii   Media Manufacturer:\n424 0x0001320a 0x0001b20a 10   11   .rodata ascii   Transport:\n425 0x00013215 0x0001b215 8    9    .rodata ascii   Parallel\n426 0x0001321e 0x0001b21e 10   11   .rodata ascii   , ATA8-APT\n427 0x00013229 0x0001b229 6    7    .rodata ascii   Serial\n428 0x00013230 0x0001b230 10   11   .rodata ascii   , ATA8-AST\n429 0x0001323b 0x0001b23b 11   12   .rodata ascii   , SATA 1.0a\n430 0x00013247 0x0001b247 20   21   .rodata ascii   , SATA II Extensions\n431 0x0001325c 0x0001b25c 14   15   .rodata ascii   , SATA Rev 2.5\n432 0x0001326b 0x0001b26b 14   15   .rodata ascii   , SATA Rev 2.6\n433 0x0001327a 0x0001b27a 14   15   .rodata ascii   , SATA Rev 3.0\n434 0x00013289 0x0001b289 12   13   .rodata ascii   ; Revision:\n435 0x00013296 0x0001b296 38   39   .rodata ascii   ATA8-AST T13 Project D1697 Revision 0b\n436 0x000132bd 0x0001b2bd 10   11   .rodata ascii   Standards:\n437 0x000132c8 0x0001b2c8 11   12   .rodata ascii   \\n\\tUsed: %s\n438 0x000132d4 0x0001b2d4 45   46   .rodata ascii   \\n\\tUsed: unknown (minor revision code 0x%04x)\n439 0x00013302 0x0001b302 13   14   .rodata ascii   \\n\\tSupported:\n440 0x00013310 0x0001b310 18   19   .rodata ascii   \\n\\tLikely used: %u\\n\n441 0x00013323 0x0001b323 13   14   .rodata ascii   & some of %u\\n\n442 0x00013331 0x0001b331 42   43   .rodata ascii   \\n\\tUsed: ATAPI for CD-ROMs, SFF-8020i, r2.5\n443 0x0001335c 0x0001b35c 25   26   .rodata ascii   \\n\\tSupported: CD-ROM ATAPI\n444 0x00013376 0x0001b376 4    5    .rodata ascii   -%u\n445 0x0001337b 0x0001b37b 28   29   .rodata ascii   \\n\\tLikely used CD-ROM ATAPI-1\n446 0x00013398 0x0001b398 14   15   .rodata ascii   Configuration:\n447 0x000133a7 0x0001b3a7 15   16   .rodata ascii   \\tDRQ response:\n448 0x000133b7 0x0001b3b7 4    5    .rodata ascii   3ms.\n449 0x000133bc 0x0001b3bc 17   18   .rodata ascii   <=10ms with INTRQ\n450 0x000133ce 0x0001b3ce 5    6    .rodata ascii   50us.\n451 0x000133d4 0x0001b3d4 8    9    .rodata ascii   unknown.\n452 0x000133dd 0x0001b3dd 14   15   .rodata ascii   \\tPacket size:\n453 0x000133ec 0x0001b3ec 8    9    .rodata ascii   12 bytes\n454 0x000133f5 0x0001b3f5 8    9    .rodata ascii   16 bytes\n455 0x000133fe 0x0001b3fe 7    8    .rodata ascii   Unknown\n456 0x00013406 0x0001b406 29   30   .rodata ascii   \\tCHS addressing not supported\n457 0x00013424 0x0001b424 21   22   .rodata ascii   \\tLogical\\t\\tmax\\tcurrent\n458 0x0001343a 0x0001b43a 17   18   .rodata ascii   \\tcylinders\\t%u\\t%u\\n\n459 0x0001344c 0x0001b44c 14   15   .rodata ascii   \\theads\\t\\t%u\\t%u\\n\n460 0x0001345b 0x0001b45b 21   22   .rodata ascii   \\tsectors/track\\t%u\\t%u\\n\n461 0x00013475 0x0001b475 16   17   .rodata ascii   \\tbytes/track: %u\n462 0x00013486 0x0001b486 18   19   .rodata ascii   \\tbytes/sector: %u\\n\n463 0x00013499 0x0001b499 38   39   .rodata ascii   \\tCHS current addressable sectors:%11u\\n\n464 0x000134c0 0x0001b4c0 38   39   .rodata ascii   \\tLBA    user addressable sectors:%11u\\n\n465 0x000134e7 0x0001b4e7 40   41   .rodata ascii   \\tLBA48  user addressable sectors:%11llu\\n\n466 0x00013510 0x0001b510 18   19   .rodata ascii   \\t%-31s %11u bytes\\n\n467 0x00013523 0x0001b523 29   30   .rodata ascii   Logical/Physical Sector size:\n468 0x00013541 0x0001b541 21   22   .rodata ascii   Logical  Sector size:\n469 0x00013557 0x0001b557 24   25   .rodata ascii   Logical Sector-0 offset:\n470 0x00013570 0x0001b570 47   48   .rodata ascii   \\tdevice size with M = 1024*1024: %11llu MBytes\\n\n471 0x000135a0 0x0001b5a0 47   48   .rodata ascii   \\tdevice size with M = 1000*1000: %11llu MBytes\n472 0x000135d0 0x0001b5d0 10   11   .rodata ascii   (%llu GB)\\n\n473 0x000135db 0x0001b5db 22   23   .rodata ascii   \\tcache/buffer size  =\n474 0x000135f2 0x0001b5f2 9    10   .rodata ascii   %u KBytes\n475 0x000135fc 0x0001b5fc 10   11   .rodata ascii    (type=%s)\n476 0x00013607 0x0001b607 14   15   .rodata ascii   \\tForm Factor:\n477 0x00013616 0x0001b616 9    10   .rodata ascii   5.25 inch\n478 0x00013620 0x0001b620 8    9    .rodata ascii   3.5 inch\n479 0x00013629 0x0001b629 8    9    .rodata ascii   2.5 inch\n480 0x00013632 0x0001b632 18   19   .rodata ascii   less than 1.8 inch\n481 0x00013645 0x0001b645 16   17   .rodata ascii   unknown (0x%04x]\n482 0x00013656 0x0001b656 48   49   .rodata ascii   \\tNominal Media Rotation Rate: Solid State Device\n483 0x00013687 0x0001b687 33   34   .rodata ascii   \\tNominal Media Rotation Rate: %u\\n\n484 0x000136a9 0x0001b6a9 13   14   .rodata ascii   Capabilities:\n485 0x000136b7 0x0001b6b7 13   14   .rodata ascii   Cmd queuing,\n486 0x000136c5 0x0001b6c5 13   14   .rodata ascii   Cmd overlap,\n487 0x000136d3 0x0001b6d3 5    6    .rodata ascii   LBA,\n488 0x000136d9 0x0001b6d9 8    9    .rodata ascii   (may be)\n489 0x000136e2 0x0001b6e2 4    5    .rodata ascii   (can\n490 0x000136e7 0x0001b6e7 7    8    .rodata ascii   (cannot\n491 0x000136ef 0x0001b6ef 13   14   .rodata ascii    be disabled)\n492 0x000136fd 0x0001b6fd 16   17   .rodata ascii   IORDY not likely\n493 0x0001370e 0x0001b70e 20   21   .rodata ascii   \\tBuffer type: %04x:\n494 0x00013723 0x0001b723 26   27   .rodata ascii   single port, single-sector\n495 0x0001373e 0x0001b73e 23   24   .rodata ascii   dual port, multi-sector\n496 0x00013756 0x0001b756 26   27   .rodata ascii    with read caching ability\n497 0x00013771 0x0001b771 20   21   .rodata ascii   \\tBuffer size: %.1fkB\n498 0x00013786 0x0001b786 28   29   .rodata ascii   \\tbytes avail on r/w long: %u\n499 0x000137a3 0x0001b7a3 16   17   .rodata ascii   \\tQueue depth: %u\n500 0x000137b4 0x0001b7b4 4    5    .rodata ascii   \\tCan\n501 0x000137b9 0x0001b7b9 23   24   .rodata ascii    perform double-word IO\n502 0x000137d1 0x0001b7d1 33   34   .rodata ascii   \\tStandby timer values: spec'd by\n503 0x000137f3 0x0001b7f3 8    9    .rodata ascii   Standard\n504 0x000137fc 0x0001b7fc 6    7    .rodata ascii   Vendor\n505 0x00013803 0x0001b803 5    6    .rodata ascii   , no\n506 0x00013809 0x0001b809 23   24   .rodata ascii   device specific minimum\n507 0x00013821 0x0001b821 31   32   .rodata ascii   \\tR/W multiple sector transfer:\n508 0x00013841 0x0001b841 9    10   .rodata ascii   Max = %u\\t\n509 0x0001384b 0x0001b84b 10   11   .rodata ascii   Current =\n510 0x00013856 0x0001b856 34   35   .rodata ascii   \\tAdvanced power management level:\n511 0x00013879 0x0001b879 62   63   .rodata ascii   \\tRecommended acoustic management value: %u, current value: %u\\n\n512 0x000138b8 0x0001b8b8 22   23   .rodata ascii   \\tATA sw reset required\n513 0x000138cf 0x0001b8cf 17   18   .rodata ascii   \\tOverlap support:\n514 0x000138e1 0x0001b8e1 21   22   .rodata ascii    %uus to release bus.\n515 0x000138f7 0x0001b8f7 37   38   .rodata ascii    %uus to clear BSY after SERVICE cmd.\n516 0x0001391d 0x0001b91d 39   40   .rodata ascii   \\tDMADIR bit required in PACKET commands\n517 0x00013945 0x0001b945 6    7    .rodata ascii   \\tDMA:\n518 0x0001394c 0x0001b94c 6    7    .rodata ascii   sdma%u\n519 0x00013957 0x0001b957 29   30   .rodata ascii   \\t     Interleaved DMA support\n520 0x00013975 0x0001b975 17   18   .rodata ascii   \\t     Cycle time:\n521 0x00013987 0x0001b987 9    10   .rodata ascii    min=%uns\n522 0x00013991 0x0001b991 17   18   .rodata ascii    recommended=%uns\n523 0x000139a3 0x0001b9a3 6    7    .rodata ascii   \\tPIO:\n524 0x000139aa 0x0001b9aa 6    7    .rodata ascii   pio%d\n525 0x000139b1 0x0001b9b1 21   22   .rodata ascii    no flow control=%uns\n526 0x000139c7 0x0001b9c7 25   26   .rodata ascii     IORDY flow control=%uns\n527 0x000139e1 0x0001b9e1 38   39   .rodata ascii   Commands/features:\\n\\tEnabled\\tSupported:\n528 0x00013a08 0x0001ba08 51   52   .rodata ascii                   (%u msec for TLC completion timer)\\n\n529 0x00013a3c 0x0001ba3c 40   41   .rodata ascii   \\t   *\\tData Set Management TRIM supported\n530 0x00013a65 0x0001ba65 20   21   .rodata ascii    (limit %u block%s)\\n\n531 0x00013a7a 0x0001ba7a 16   17   .rodata ascii    (limit unknown)\n532 0x00013a8b 0x0001ba8b 6    7    .rodata ascii   pio%u\n533 0x00013a92 0x0001ba92 7    8    .rodata ascii   mdma%u\n534 0x00013a9a 0x0001ba9a 44   45   .rodata ascii   \\t\\tCFA max advanced io_udma cycle time: %uns\\n\n535 0x00013ac7 0x0001bac7 45   46   .rodata ascii   \\t\\tCFA max advanced mem_udma cycle time: %uns\\n\n536 0x00013af5 0x0001baf5 10   11   .rodata ascii   io_udma%u\n537 0x00013b00 0x0001bb00 11   12   .rodata ascii   mem_udma%u\n538 0x00013b0c 0x0001bb0c 29   30   .rodata ascii   \\t   *\\tCFA advanced modes: %s\\n\n539 0x00013b2a 0x0001bb2a 4    5    .rodata ascii      *\n540 0x00013b2f 0x0001bb2f 19   20   .rodata ascii   \\tCFA Power Level 1\n541 0x00013b43 0x0001bb43 11   12   .rodata ascii    (max %umA)\n542 0x00013b4f 0x0001bb4f 35   36   .rodata ascii   \\t\\tKey Management (CPRM) feature set\n543 0x00013b73 0x0001bb73 59   60   .rodata ascii   \\t\\tRemovable Media Status Notification feature set supported\n544 0x00013baf 0x0001bbaf 10   11   .rodata ascii   Security:\n545 0x00013bba 0x0001bbba 36   37   .rodata ascii   \\tMaster password revision code = %u\\n\n546 0x00013bdf 0x0001bbdf 5    6    .rodata ascii   \\tnot\\t\n547 0x00013be5 0x0001bbe5 16   17   .rodata ascii   \\tSecurity level\n548 0x00013bf6 0x0001bbf6 7    8    .rodata ascii   maximum\n549 0x00013bfe 0x0001bbfe 13   14   .rodata ascii   more than 508\n550 0x00013c0c 0x0001bc0c 29   30   .rodata ascii   min for SECURITY ERASE UNIT.\n551 0x00013c2a 0x0001bc2a 38   39   .rodata ascii   min for ENHANCED SECURITY ERASE UNIT.\n552 0x00013c51 0x0001bc51 53   54   .rodata ascii   Logical Unit WWN Device Identifier: %04x%04x%04x%04x\\n\n553 0x00013c87 0x0001bc87 11   12   .rodata ascii   \\tNAA\\t\\t: %x\\n\n554 0x00013c93 0x0001bc93 17   18   .rodata ascii   \\tIEEE OUI\\t: %06x\\n\n555 0x00013ca5 0x0001bca5 20   21   .rodata ascii   \\tUnique ID\\t: %x%08x\\n\n556 0x00013cba 0x0001bcba 17   18   .rodata ascii   HW reset results:\n557 0x00013ccc 0x0001bccc 17   18   .rodata ascii   \\tCBLID- above Vih\n558 0x00013cde 0x0001bcde 17   18   .rodata ascii   \\tCBLID- below Vih\n559 0x00013cf0 0x0001bcf0 15   16   .rodata ascii   \\tDevice num = 0\n560 0x00013d00 0x0001bd00 15   16   .rodata ascii   \\tDevice num = 1\n561 0x00013d10 0x0001bd10 25   26   .rodata ascii    determined by the jumper\n562 0x00013d2a 0x0001bd2a 19   20   .rodata ascii    determined by CSEL\n563 0x00013d3e 0x0001bd3e 19   20   .rodata ascii   Checksum: %scorrect\n564 0x00013d52 0x0001bd52 27   28   .rodata ascii    (0x%02x), expected 0x%02x\\n\n565 0x00013d6e 0x0001bd6e 59   60   .rodata ascii   Integrity word not set (found 0x%04x, expected 0x%02x%02x)\\n\n566 0x00013daa 0x0001bdaa 20   21   .rodata ascii   DCO Revision: 0x%04x\n567 0x00013dbf 0x0001bdbf 29   30   .rodata ascii    -- unknown, treating as 0002\n568 0x00013ddd 0x0001bddd 60   61   .rodata ascii   \\nThe following features can be selectively disabled via DCO:\n569 0x00013e1a 0x0001be1a 19   20   .rodata ascii   \\tTransfer modes:\\n\\t\\t\n570 0x00013e2e 0x0001be2e 18   19   .rodata ascii    mdma0 mdma1 mdma2\n571 0x00013e41 0x0001be41 12   13   .rodata ascii    mdma0 mdma1\n572 0x00013e4e 0x0001be4e 6    7    .rodata ascii    mdma0\n573 0x00013e55 0x0001be55 42   43   .rodata ascii    udma0 udma1 udma2 udma3 udma4 udma5 udma6\n574 0x00013e80 0x0001be80 36   37   .rodata ascii    udma0 udma1 udma2 udma3 udma4 udma5\n575 0x00013ea5 0x0001bea5 30   31   .rodata ascii    udma0 udma1 udma2 udma3 udma4\n576 0x00013ec4 0x0001bec4 24   25   .rodata ascii    udma0 udma1 udma2 udma3\n577 0x00013edd 0x0001bedd 18   19   .rodata ascii    udma0 udma1 udma2\n578 0x00013ef0 0x0001bef0 12   13   .rodata ascii    udma0 udma1\n579 0x00013efd 0x0001befd 6    7    .rodata ascii    udma0\n580 0x00013f04 0x0001bf04 24   25   .rodata ascii   \\tReal max sectors: %llu\\n\n581 0x00013f1d 0x0001bf1d 26   27   .rodata ascii   \\tATA command/feature sets:\n582 0x00013f38 0x0001bf38 6    7    .rodata ascii    SMART\n583 0x00013f3f 0x0001bf3f 10   11   .rodata ascii    self_test\n584 0x00013f4a 0x0001bf4a 10   11   .rodata ascii    error_log\n585 0x00013f55 0x0001bf55 9    10   .rodata ascii    security\n586 0x00013f5f 0x0001bf5f 5    6    .rodata ascii    PUIS\n587 0x00013f65 0x0001bf65 4    5    .rodata ascii    TCQ\n588 0x00013f6a 0x0001bf6a 4    5    .rodata ascii    AAM\n589 0x00013f6f 0x0001bf6f 4    5    .rodata ascii    HPA\n590 0x00013f74 0x0001bf74 7    8    .rodata ascii    48_bit\n591 0x00013f7c 0x0001bf7c 5    6    .rodata ascii    (?):\n592 0x00013f82 0x0001bf82 10   11   .rodata ascii    streaming\n593 0x00013f8d 0x0001bf8d 19   20   .rodata ascii    TLC_Reserved_7[10]\n594 0x00013fa1 0x0001bfa1 4    5    .rodata ascii    FUA\n595 0x00013fa6 0x0001bfa6 15   16   .rodata ascii    selective_test\n596 0x00013fb6 0x0001bfb6 16   17   .rodata ascii    conveyance_test\n597 0x00013fc7 0x0001bfc7 18   19   .rodata ascii    write_read_verify\n598 0x00013fda 0x0001bfda 15   16   .rodata ascii    reserved_7[15]\n599 0x00013fea 0x0001bfea 10   11   .rodata ascii    free_fall\n600 0x00013ff5 0x0001bff5 18   19   .rodata ascii    trusted_computing\n601 0x00014008 0x0001c008 14   15   .rodata ascii    WRITE_UNC_EXT\n602 0x00014017 0x0001c017 26   27   .rodata ascii    NV_cache_power_management\n603 0x00014032 0x0001c032 9    10   .rodata ascii    NV_cache\n604 0x0001403c 0x0001c03c 30   31   .rodata ascii   \\tSATA command/feature sets:\\n\\t\\t\n605 0x0001405b 0x0001c05b 4    5    .rodata ascii    NCQ\n606 0x00014060 0x0001c060 18   19   .rodata ascii    NZ_buffer_offsets\n607 0x00014073 0x0001c073 27   28   .rodata ascii    interface_power_management\n608 0x0001408f 0x0001c08f 19   20   .rodata ascii    async_notification\n609 0x000140a3 0x0001c0a3 4    5    .rodata ascii    SSP\n610 0x000140a8 0x0001c0a8 20   21   .rodata ascii   Direct-access device\n611 0x000140bd 0x0001c0bd 24   25   .rodata ascii   Sequential-access device\n612 0x000140d6 0x0001c0d6 7    8    .rodata ascii   Printer\n613 0x000140de 0x0001c0de 9    10   .rodata ascii   Processor\n614 0x000140e8 0x0001c0e8 17   18   .rodata ascii   Write-once device\n615 0x000140fa 0x0001c0fa 6    7    .rodata ascii   CD-ROM\n616 0x00014101 0x0001c101 7    8    .rodata ascii   Scanner\n617 0x00014109 0x0001c109 14   15   .rodata ascii   Optical memory\n618 0x00014118 0x0001c118 14   15   .rodata ascii   Medium changer\n619 0x00014127 0x0001c127 21   22   .rodata ascii   Communications device\n620 0x0001413d 0x0001c13d 14   15   .rodata ascii   ACS-IT8 device\n621 0x0001414c 0x0001c14c 16   17   .rodata ascii   Array controller\n622 0x0001415d 0x0001c15d 18   19   .rodata ascii   Enclosure services\n623 0x00014170 0x0001c170 28   29   .rodata ascii   Reduced block command device\n624 0x0001418d 0x0001c18d 26   27   .rodata ascii   Optical card reader/writer\n625 0x000141a8 0x0001c1a8 13   14   .rodata ascii   hard sectored\n626 0x000141b6 0x0001c1b6 13   14   .rodata ascii   soft sectored\n627 0x000141c4 0x0001c1c4 16   17   .rodata ascii   not MFM encoded\n628 0x000141d5 0x0001c1d5 23   24   .rodata ascii   head switch time > 15us\n629 0x000141ed 0x0001c1ed 28   29   .rodata ascii   spindle motor control option\n630 0x0001420a 0x0001c20a 11   12   .rodata ascii   fixed drive\n631 0x00014216 0x0001c216 15   16   .rodata ascii   removable drive\n632 0x00014226 0x0001c226 22   23   .rodata ascii   disk xfer rate <= 5Mbs\n633 0x0001423d 0x0001c23d 31   32   .rodata ascii   disk xfer rate > 5Mbs, <= 10Mbs\n634 0x0001425d 0x0001c25d 21   22   .rodata ascii   disk xfer rate > 5Mbs\n635 0x00014273 0x0001c273 21   22   .rodata ascii   rotational speed tol.\n636 0x00014289 0x0001c289 25   26   .rodata ascii   data strobe offset option\n637 0x000142a3 0x0001c2a3 19   20   .rodata ascii   track offset option\n638 0x000142b7 0x0001c2b7 31   32   .rodata ascii   format speed tolerance gap reqd\n639 0x000142d7 0x0001c2d7 11   12   .rodata ascii   Unspecified\n640 0x000142e3 0x0001c2e3 37   38   .rodata ascii   ATA-1 X3T9.2 781D prior to revision 4\n641 0x00014309 0x0001c309 33   34   .rodata ascii   ATA-1 published, ANSI X3.221-1994\n642 0x0001432b 0x0001c32b 28   29   .rodata ascii   ATA-1 X3T9.2 781D revision 4\n643 0x00014348 0x0001c348 33   34   .rodata ascii   ATA-2 published, ANSI X3.279-1996\n644 0x0001436a 0x0001c36a 37   38   .rodata ascii   ATA-2 X3T10 948D prior to revision 2k\n645 0x00014390 0x0001c390 28   29   .rodata ascii   ATA-3 X3T10 2008D revision 1\n646 0x000143ad 0x0001c3ad 28   29   .rodata ascii   ATA-2 X3T10 948D revision 2k\n647 0x000143ca 0x0001c3ca 28   29   .rodata ascii   ATA-3 X3T10 2008D revision 0\n648 0x000143e7 0x0001c3e7 27   28   .rodata ascii   ATA-2 X3T10 948D revision 3\n649 0x00014403 0x0001c403 33   34   .rodata ascii   ATA-3 published, ANSI X3.298-199x\n650 0x00014425 0x0001c425 28   29   .rodata ascii   ATA-3 X3T10 2008D revision 6\n651 0x00014442 0x0001c442 35   36   .rodata ascii   ATA-3 X3T13 2008D revision 7 and 7a\n652 0x00014466 0x0001c466 34   35   .rodata ascii   ATA/ATAPI-4 X3T13 1153D revision 6\n653 0x00014489 0x0001c489 33   34   .rodata ascii   ATA/ATAPI-4 T13 1153D revision 13\n654 0x000144ab 0x0001c4ab 34   35   .rodata ascii   ATA/ATAPI-4 X3T13 1153D revision 7\n655 0x000144ce 0x0001c4ce 33   34   .rodata ascii   ATA/ATAPI-4 T13 1153D revision 18\n656 0x000144f0 0x0001c4f0 33   34   .rodata ascii   ATA/ATAPI-4 T13 1153D revision 15\n657 0x00014512 0x0001c512 43   44   .rodata ascii   ATA/ATAPI-4 published, ANSI INCITS 317-1998\n658 0x0001453e 0x0001c53e 32   33   .rodata ascii   ATA/ATAPI-5 T13 1321D revision 3\n659 0x0001455f 0x0001c55f 33   34   .rodata ascii   ATA/ATAPI-4 T13 1153D revision 14\n660 0x00014581 0x0001c581 32   33   .rodata ascii   ATA/ATAPI-5 T13 1321D revision 1\n661 0x000145a2 0x0001c5a2 43   44   .rodata ascii   ATA/ATAPI-5 published, ANSI INCITS 340-2000\n662 0x000145ce 0x0001c5ce 33   34   .rodata ascii   ATA/ATAPI-4 T13 1153D revision 17\n663 0x000145f0 0x0001c5f0 32   33   .rodata ascii   ATA/ATAPI-6 T13 1410D revision 0\n664 0x00014611 0x0001c611 33   34   .rodata ascii   ATA/ATAPI-6 T13 1410D revision 3a\n665 0x00014633 0x0001c633 32   33   .rodata ascii   ATA/ATAPI-7 T13 1532D revision 1\n666 0x00014654 0x0001c654 32   33   .rodata ascii   ATA/ATAPI-6 T13 1410D revision 2\n667 0x00014675 0x0001c675 32   33   .rodata ascii   ATA/ATAPI-6 T13 1410D revision 1\n668 0x00014696 0x0001c696 43   44   .rodata ascii   ATA/ATAPI-7 published, ANSI INCITS 397-2005\n669 0x000146c2 0x0001c6c2 32   33   .rodata ascii   ATA/ATAPI-7 T13 1532D revision 0\n670 0x000146e3 0x0001c6e3 8    9    .rodata ascii   Reserved\n671 0x000146ec 0x0001c6ec 33   34   .rodata ascii   ATA/ATAPI-7 T13 1532D revision 4a\n672 0x0001470e 0x0001c70e 43   44   .rodata ascii   ATA/ATAPI-6 published, ANSI INCITS 361-2002\n673 0x0001473a 0x0001c73a 6    7    .rodata ascii   locked\n674 0x00014741 0x0001c741 6    7    .rodata ascii   frozen\n675 0x00014748 0x0001c748 23   24   .rodata ascii   expired: security count\n676 0x00014760 0x0001c760 25   26   .rodata ascii   supported: enhanced erase\n677 0x0001477a 0x0001c77a 15   16   .rodata ascii   obsolete 82[15]\n678 0x0001478a 0x0001c78a 7    8    .rodata ascii   NOP cmd\n679 0x00014792 0x0001c792 19   20   .rodata ascii   READ_BUFFER command\n680 0x000147a6 0x0001c7a6 20   21   .rodata ascii   WRITE_BUFFER command\n681 0x000147bb 0x0001c7bb 20   21   .rodata ascii   WRITE_VERIFY command\n682 0x000147d0 0x0001c7d0 31   32   .rodata ascii   Host Protected Area feature set\n683 0x000147f0 0x0001c7f0 20   21   .rodata ascii   DEVICE_RESET command\n684 0x00014805 0x0001c805 17   18   .rodata ascii   SERVICE interrupt\n685 0x00014817 0x0001c817 17   18   .rodata ascii   Release interrupt\n686 0x00014829 0x0001c829 10   11   .rodata ascii   Look-ahead\n687 0x00014834 0x0001c834 11   12   .rodata ascii   Write cache\n688 0x00014840 0x0001c840 26   27   .rodata ascii   PACKET command feature set\n689 0x0001485b 0x0001c85b 27   28   .rodata ascii   Removable Media feature set\n690 0x00014877 0x0001c877 25   26   .rodata ascii   Security Mode feature set\n691 0x00014891 0x0001c891 17   18   .rodata ascii   SMART feature set\n692 0x000148a3 0x0001c8a3 15   16   .rodata ascii   FLUSH_CACHE_EXT\n693 0x000148b3 0x0001c8b3 21   22   .rodata ascii   Mandatory FLUSH_CACHE\n694 0x000148c9 0x0001c8c9 40   41   .rodata ascii   Device Configuration Overlay feature set\n695 0x000148f2 0x0001c8f2 26   27   .rodata ascii   48-bit Address feature set\n696 0x0001490d 0x0001c90d 41   42   .rodata ascii   Automatic Acoustic Management feature set\n697 0x00014937 0x0001c937 26   27   .rodata ascii   SET_MAX security extension\n698 0x00014952 0x0001c952 33   34   .rodata ascii   Address Offset Reserved Area Boot\n699 0x00014974 0x0001c974 46   47   .rodata ascii   SET_FEATURES required to spinup after power up\n700 0x000149a3 0x0001c9a3 31   32   .rodata ascii   Power-Up In Standby feature set\n701 0x000149c3 0x0001c9c3 47   48   .rodata ascii   Removable Media Status Notification feature set\n702 0x000149f3 0x0001c9f3 37   38   .rodata ascii   Advanced Power Management feature set\n703 0x00014a19 0x0001ca19 15   16   .rodata ascii   CFA feature set\n704 0x00014a29 0x0001ca29 21   22   .rodata ascii   READ/WRITE_DMA_QUEUED\n705 0x00014a3f 0x0001ca3f 26   27   .rodata ascii   IDLE_IMMEDIATE with UNLOAD\n706 0x00014a5a 0x0001ca5a 36   37   .rodata ascii   Command Completion Time Limit (CCTL)\n707 0x00014a7f 0x0001ca7f 39   40   .rodata ascii   Time Limited Commands (TLC) feature set\n708 0x00014aa7 0x0001caa7 30   31   .rodata ascii   URG for WRITE_STREAM[_DMA]_EXT\n709 0x00014ac6 0x0001cac6 29   30   .rodata ascii   URG for READ_STREAM[_DMA]_EXT\n710 0x00014ae4 0x0001cae4 22   23   .rodata ascii   64-bit World wide name\n711 0x00014afb 0x0001cafb 24   25   .rodata ascii   WRITE_DMA_QUEUED_FUA_EXT\n712 0x00014b14 0x0001cb14 28   29   .rodata ascii   WRITE_{DMA|MULTIPLE}_FUA_EXT\n713 0x00014b31 0x0001cb31 35   36   .rodata ascii   General Purpose Logging feature set\n714 0x00014b55 0x0001cb55 23   24   .rodata ascii   Media Card Pass-Through\n715 0x00014b6d 0x0001cb6d 43   44   .rodata ascii   Media Card Pass Through Command feature set\n716 0x00014b99 0x0001cb99 19   20   .rodata ascii   Media serial number\n717 0x00014bad 0x0001cbad 15   16   .rodata ascii   SMART self-test\n718 0x00014bbd 0x0001cbbd 19   20   .rodata ascii   SMART error logging\n719 0x00014bd1 0x0001cbd1 15   16   .rodata ascii   unknown 119[13]\n720 0x00014be1 0x0001cbe1 15   16   .rodata ascii   unknown 119[12]\n721 0x00014bf1 0x0001cbf1 15   16   .rodata ascii   unknown 119[11]\n722 0x00014c01 0x0001cc01 15   16   .rodata ascii   unknown 119[10]\n723 0x00014c11 0x0001cc11 14   15   .rodata ascii   unknown 119[9]\n724 0x00014c20 0x0001cc20 14   15   .rodata ascii   unknown 119[8]\n725 0x00014c2f 0x0001cc2f 14   15   .rodata ascii   unknown 119[7]\n726 0x00014c3e 0x0001cc3e 14   15   .rodata ascii   unknown 119[6]\n727 0x00014c4d 0x0001cc4d 29   30   .rodata ascii   Free-fall Control feature set\n728 0x00014c6b 0x0001cc6b 28   29   .rodata ascii   Segmented DOWNLOAD_MICROCODE\n729 0x00014c88 0x0001cc88 33   34   .rodata ascii   {READ,WRITE}_DMA_EXT_GPL commands\n730 0x00014caa 0x0001ccaa 31   32   .rodata ascii   WRITE_UNCORRECTABLE_EXT command\n731 0x00014cca 0x0001ccca 29   30   .rodata ascii   Write-Read-Verify feature set\n732 0x00014ce8 0x0001cce8 43   44   .rodata ascii   Disable Data Transfer After Error Detection\n733 0x00014d14 0x0001cd14 14   15   .rodata ascii   unknown 76[15]\n734 0x00014d23 0x0001cd23 14   15   .rodata ascii   unknown 76[14]\n735 0x00014d32 0x0001cd32 14   15   .rodata ascii   unknown 76[13]\n736 0x00014d41 0x0001cd41 24   25   .rodata ascii   NCQ priority information\n737 0x00014d5a 0x0001cd5a 30   31   .rodata ascii   Idle-Unload when NCQ is active\n738 0x00014d79 0x0001cd79 18   19   .rodata ascii   Phy event counters\n739 0x00014d8c 0x0001cd8c 41   42   .rodata ascii   Host-initiated interface power management\n740 0x00014db6 0x0001cdb6 29   30   .rodata ascii   Native Command Queueing (NCQ)\n741 0x00014dd4 0x0001cdd4 13   14   .rodata ascii   unknown 76[7]\n742 0x00014de2 0x0001cde2 13   14   .rodata ascii   unknown 76[6]\n743 0x00014df0 0x0001cdf0 13   14   .rodata ascii   unknown 76[5]\n744 0x00014dfe 0x0001cdfe 13   14   .rodata ascii   unknown 76[4]\n745 0x00014e0c 0x0001ce0c 30   31   .rodata ascii   Gen3 signaling speed (6.0Gb/s)\n746 0x00014e2b 0x0001ce2b 30   31   .rodata ascii   Gen2 signaling speed (3.0Gb/s)\n747 0x00014e4a 0x0001ce4a 30   31   .rodata ascii   Gen1 signaling speed (1.5Gb/s)\n748 0x00014e69 0x0001ce69 13   14   .rodata ascii   unknown 76[0]\n749 0x00014e77 0x0001ce77 14   15   .rodata ascii   unknown 78[15]\n750 0x00014e86 0x0001ce86 14   15   .rodata ascii   unknown 78[14]\n751 0x00014e95 0x0001ce95 14   15   .rodata ascii   unknown 78[13]\n752 0x00014ea4 0x0001cea4 14   15   .rodata ascii   unknown 78[12]\n753 0x00014eb3 0x0001ceb3 14   15   .rodata ascii   unknown 78[11]\n754 0x00014ec2 0x0001cec2 14   15   .rodata ascii   unknown 78[10]\n755 0x00014ed1 0x0001ced1 13   14   .rodata ascii   unknown 78[9]\n756 0x00014edf 0x0001cedf 13   14   .rodata ascii   unknown 78[8]\n757 0x00014eed 0x0001ceed 13   14   .rodata ascii   unknown 78[7]\n758 0x00014efb 0x0001cefb 30   31   .rodata ascii   Software settings preservation\n759 0x00014f1a 0x0001cf1a 44   45   .rodata ascii   Asynchronous notification (eg. media change)\n760 0x00014f47 0x0001cf47 22   23   .rodata ascii   In-order data delivery\n761 0x00014f5e 0x0001cf5e 43   44   .rodata ascii   Device-initiated interface power management\n762 0x00014f8a 0x0001cf8a 36   37   .rodata ascii   DMA Setup Auto-Activate optimization\n763 0x00014faf 0x0001cfaf 40   41   .rodata ascii   Non-Zero buffer offsets in DMA Setup FIS\n764 0x00014fd8 0x0001cfd8 13   14   .rodata ascii   unknown 78[0]\n765 0x00014fe6 0x0001cfe6 33   34   .rodata ascii   unknown 206[15] (vendor specific)\n766 0x00015008 0x0001d008 33   34   .rodata ascii   unknown 206[14] (vendor specific)\n767 0x0001502a 0x0001d02a 33   34   .rodata ascii   unknown 206[13] (vendor specific)\n768 0x0001504c 0x0001d04c 33   34   .rodata ascii   unknown 206[12] (vendor specific)\n769 0x0001506e 0x0001d06e 15   16   .rodata ascii   unknown 206[11]\n770 0x0001507e 0x0001d07e 15   16   .rodata ascii   unknown 206[10]\n771 0x0001508e 0x0001d08e 14   15   .rodata ascii   unknown 206[9]\n772 0x0001509d 0x0001d09d 14   15   .rodata ascii   unknown 206[8]\n773 0x000150ac 0x0001d0ac 14   15   .rodata ascii   unknown 206[7]\n774 0x000150bb 0x0001d0bb 14   15   .rodata ascii   unknown 206[6]\n775 0x000150ca 0x0001d0ca 21   22   .rodata ascii   SCT Data Tables (AC5)\n776 0x000150e0 0x0001d0e0 26   27   .rodata ascii   SCT Features Control (AC4)\n777 0x000150fb 0x0001d0fb 32   33   .rodata ascii   SCT Error Recovery Control (AC3)\n778 0x0001511c 0x0001d11c 20   21   .rodata ascii   SCT Write Same (AC2)\n779 0x00015131 0x0001d131 35   36   .rodata ascii   SCT Read/Write Long (AC1), obsolete\n780 0x00015155 0x0001d155 41   42   .rodata ascii   SMART Command Transport (SCT) feature set\n781 0x0001517f 0x0001d17f 27   28   .rodata ascii   CFast specification support\n782 0x0001519b 0x0001d19b 34   35   .rodata ascii   Deterministic read data after TRIM\n783 0x000151be 0x0001d1be 32   33   .rodata ascii   Long physical sector diagnostics\n784 0x000151df 0x0001d1df 46   47   .rodata ascii   DEVICE CONFIGURATION SET/IDENTIFY DMA commands\n785 0x0001520e 0x0001d20e 23   24   .rodata ascii   READ BUFFER DMA command\n786 0x00015226 0x0001d226 24   25   .rodata ascii   WRITE BUFFER DMA command\n787 0x0001523f 0x0001d23f 39   40   .rodata ascii   SET MAX SETPASSWORD/UNLOCK DMA commands\n788 0x00015267 0x0001d267 30   31   .rodata ascii   DOWNLOAD MICROCODE DMA command\n789 0x00015286 0x0001d286 14   15   .rodata ascii   reserved 69[7]\n790 0x00015295 0x0001d295 14   15   .rodata ascii   reserved 69[6]\n791 0x000152a4 0x0001d2a4 35   36   .rodata ascii   Deterministic read ZEROs after TRIM\n792 0x000152c8 0x0001d2c8 14   15   .rodata ascii   reserved 69[4]\n793 0x000152d7 0x0001d2d7 14   15   .rodata ascii   reserved 69[3]\n794 0x000152e6 0x0001d2e6 14   15   .rodata ascii   reserved 69[2]\n795 0x000152f5 0x0001d2f5 14   15   .rodata ascii   reserved 69[1]\n796 0x00015304 0x0001d304 14   15   .rodata ascii   reserved 69[0]\n797 0x00015313 0x0001d313 5    6    .rodata ascii    %02x\n798 0x00015319 0x0001d319 12   13   .rodata ascii   outgoing cdb\n799 0x00015326 0x0001d326 13   14   .rodata ascii   outgoing_data\n800 0x00015334 0x0001d334 15   16   .rodata ascii   ioctl(fd,SG_IO)\n801 0x00015344 0x0001d344 64   65   .rodata ascii   SG_IO: ATA_%u status=0x%x, host_status=0x%x, driver_status=0x%x\\n\n802 0x00015385 0x0001d385 24   25   .rodata ascii   SG_IO: bad status: 0x%x\\n\n803 0x0001539e 0x0001d39e 29   30   .rodata ascii   SG_IO: bad host status: 0x%x\\n\n804 0x000153bc 0x0001d3bc 11   12   .rodata ascii   SG_IO: sb[]\n805 0x000153c8 0x0001d3c8 13   14   .rodata ascii   incoming_data\n806 0x000153d6 0x0001d3d6 31   32   .rodata ascii   SG_IO: bad driver status: 0x%x\\n\n807 0x000153f6 0x0001d3f6 57   58   .rodata ascii   SG_IO: questionable sense data, results may be incorrect\\n\n808 0x00015430 0x0001d430 35   36   .rodata ascii   SG_IO: bad/missing sense data, sb[]\n809 0x00015454 0x0001d454 13   14   .rodata ascii   SG_IO: desc[]\n810 0x00015462 0x0001d462 82   83   .rodata ascii         ATA_%u stat=%02x err=%02x nsect=%02x lbal=%02x lbam=%02x lbah=%02x dev=%02x\\n\n811 0x000154b5 0x0001d4b5 60   61   .rodata ascii   I/O error, ata_op=0x%02x ata_status=0x%02x ata_error=0x%02x\\n\n812 0x000154f2 0x0001d4f2 29   30   .rodata ascii   Trying legacy HDIO_DRIVE_CMD\\n\n813 0x00015510 0x0001d510 30   31   .rodata ascii   oflags.lob_all=0x%02x, flags={\n814 0x0001552f 0x0001d52f 5    6    .rodata ascii    feat\n815 0x00015535 0x0001d535 6    7    .rodata ascii    nsect\n816 0x0001553c 0x0001d53c 5    6    .rodata ascii    lbal\n817 0x00015542 0x0001d542 5    6    .rodata ascii    lbam\n818 0x00015548 0x0001d548 5    6    .rodata ascii    lbah\n819 0x0001554e 0x0001d54e 4    5    .rodata ascii    dev\n820 0x00015553 0x0001d553 30   31   .rodata ascii   oflags.hob_all=0x%02x, flags={\n821 0x00015572 0x0001d572 21   22   .rodata ascii   using LBA48 taskfile\\n\n822 0x00015588 0x0001d588 34   35   .rodata ascii   trying legacy HDIO_DRIVE_TASKFILE\\n\n823 0x000155ab 0x0001d5ab 41   42   .rodata ascii   rc=%d, errno=%d, returned ATA registers:\n824 0x000155d5 0x0001d5d5 8    9    .rodata ascii    er=%02x\n825 0x000155de 0x0001d5de 8    9    .rodata ascii    ns=%02x\n826 0x000155e7 0x0001d5e7 8    9    .rodata ascii    ll=%02x\n827 0x000155f0 0x0001d5f0 8    9    .rodata ascii    lm=%02x\n828 0x000155f9 0x0001d5f9 8    9    .rodata ascii    lh=%02x\n829 0x00015602 0x0001d602 8    9    .rodata ascii    dh=%02x\n830 0x0001560b 0x0001d60b 8    9    .rodata ascii    st=%02x\n831 0x00015614 0x0001d614 9    10   .rodata ascii    err=%02x\n832 0x0001561e 0x0001d61e 72   73   .rodata ascii   The running kernel lacks CONFIG_IDE_TASK_IOCTL support for this device.\\n\n833 0x00015668 0x0001d668 14   15   .rodata ascii   sysfs_find_dev\n834 0x00015678 0x0001d678 5    6    .rodata ascii   %u:%u\n835 0x0001567e 0x0001d67e 15   16   .rodata ascii    fstat() failed\n836 0x0001568e 0x0001d68e 10   11   .rodata ascii   /sys/block\n837 0x00015699 0x0001d699 14   15   .rodata ascii   %s(%u:%u): %s\\n\n838 0x000156a8 0x0001d6a8 13   14   .rodata ascii   /proc/devices\n839 0x000156b8 0x0001d6b8 7    8    .rodata ascii   fstat()\n840 0x000156c0 0x0001d6c0 4    5    .rodata ascii   size\n841 0x000156c5 0x0001d6c5 18   19   .rodata ascii    BLKGETSIZE failed\n842 0x000156d8 0x0001d6d8 8    9    .rodata ascii   md/level\n843 0x000156e1 0x0001d6e1 13   14   .rodata ascii   md/raid_disks\n844 0x000156ef 0x0001d6ef 5    6    .rodata ascii   raid1\n845 0x000156f5 0x0001d6f5 14   15   .rodata ascii   md/rd%u/offset\n846 0x00015704 0x0001d704 17   18   .rodata ascii   md/rd%u/block/dev\n847 0x00015716 0x0001d716 19   20   .rodata ascii   md/rd%u/block/start\n848 0x0001572a 0x0001d72a 19   20   .rodata ascii    HDIO_GETGEO failed\n849 0x0001573e 0x0001d73e 5    6    .rodata ascii   %s/%s\n850 0x00015744 0x0001d744 30   31   .rodata ascii   %d,%d: device not found in %s\\n\n851 0x00015763 0x0001d763 13   14   .rodata ascii   %10llu %10llu\n852 0x00015771 0x0001d771 13   14   .rodata ascii   %12llu %s %s\\n\n853 0x0001577f 0x0001d77f 21   22   .rodata ascii         -          -\n854 0x00015795 0x0001d795 23   24   .rodata ascii   %s: not a regular file\\n\n855 0x000157ad 0x0001d7ad 59   60   .rodata ascii   Unable to determine start offset LBA for device, aborting.\\n\n856 0x000157e9 0x0001d7e9 42   43   .rodata ascii   Unable to determine block size, aborting.\\n\n857 0x00015814 0x0001d814 77   78   .rodata ascii   \\n%s:\\n filesystem blocksize %u, begins at LBA %llu; assuming %u byte sectors.\\n\n858 0x00015862 0x0001d862 20   21   .rodata ascii   %12s %10s %10s %10s\\n\n859 0x00015877 0x0001d877 11   12   .rodata ascii   byte_offset\n860 0x00015883 0x0001d883 9    10   .rodata ascii   begin_LBA\n861 0x0001588d 0x0001d88d 7    8    .rodata ascii   end_LBA\n862 0x00015895 0x0001d895 7    8    .rodata ascii   sectors\n863 0x0001589d 0x0001d89d 13   14   .rodata ascii   ioctl(FIBMAP)\n864 0x000158ac 0x0001d8ac 10   11   .rodata ascii   fwdownload\n865 0x000158b8 0x0001d8b8 38   39   .rodata ascii   %s: file size too large, max=%u bytes\\n\n866 0x000158df 0x0001d8df 43   44   .rodata ascii   %s: file size (%llu) not a multiple of 512\\n\n867 0x0001590b 0x0001d90b 15   16   .rodata ascii   %s: %llu bytes\\n\n868 0x0001591b 0x0001d91b 44   45   .rodata ascii   DOWNLOAD_MICROCODE: not supported by device\\n\n869 0x00015948 0x0001d948 54   55   .rodata ascii   Error: file size (%llu) too large for mode7 transfers\\n\n870 0x0001597f 0x0001d97f 39   40   .rodata ascii   %s: xfer_mode=%d min=%u max=%u size=%u\\n\n871 0x000159a7 0x0001d9a7 51   52   .rodata ascii   Error: drive completed transfer at %llu/%llu bytes\\n\n872 0x000159db 0x0001d9db 46   47   .rodata ascii   Error: drive expects more data than provided,\\n\n873 0x00015a0a 0x0001da0a 45   46   .rodata ascii   but the transfer may have worked regardless.\\n\n874 0x00015a38 0x0001da38 6    7    .rodata ascii    Done.\n875 0x00015a40 0x0001da40 20   21   .rodata ascii   wdidle3_vsc_send_key\n876 0x00015a58 0x0001da58 15   16   .rodata ascii   wdidle3_data_in\n877 0x00015a68 0x0001da68 26   27   .rodata ascii   wdidle3_vsc_enable_disable\n878 0x00015a84 0x0001da84 20   21   .rodata ascii   wdidle3_vsc_data_out\n879 0x00015a9c 0x0001da9c 13   14   .rodata ascii   [raw=0x%02x]\n880 0x00015aaa 0x0001daaa 5    6    .rodata ascii   %u ??\n881 0x00015ab0 0x0001dab0 10   11   .rodata ascii   %u.%u secs\n882 0x00015abb 0x0001dabb 33   34   .rodata ascii    (or %u.%u secs for older drives)", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to analyze the main function and how hdparm processes input. From the strings, I see potential input points like command-line arguments and stdin. I'll decompile the main function and other key functions to trace data flow and identify vulnerabilities. I'll start by finding the main function and then analyze functions that handle dangerous operations.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"s main\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"s main\"}\n结果：\n [s main 命令无输出]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to find the main function to understand how hdparm processes input. Since 's main' didn't return anything, the binary is likely stripped, so I'll look for the entry point and decompile it. From the 'afl' output, entry0 at 0x000091ac is a good starting point. I'll use 'pdg' to decompile it and trace the code flow to identify input handling and potential vulnerabilities.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ 0x000091ac\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ 0x000091ac\"}\n结果：\n void entry0(uint param_1)\n\n{\n    uint uVar1;\n    uint in_stack_00000000;\n    \n    //[11] -r-x section size 58284 named .text\n    uVar1 = in_stack_00000000;\n    *&stack0x00000000 = &stack0x00000004;\n    //WARNING: Could not recover jumptable at 0x0000904c. Too many branches\n    //WARNING: Treating indirect jump as call\n    (**reloc.__uClibc_main)(*0x91e0,uVar1,&stack0x00000004,*0x91e4,*0x91dc,param_1);\n    return;\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to identify the main function and analyze how hdparm processes input. Since the binary is stripped, I'll start by decompiling the entry point and then look for the main logic. From the 'afl' output, I see a large function at 0x0000a60c (fcn.0000a60c) that might be the main function. I'll decompile it to understand the input handling and data flow. Additionally, I'll check for dangerous string operations like strcpy, strcat, and sprintf to identify potential buffer overflows.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ 0x0000a60c\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ 0x0000a60c\"}\n结果：\n void fcn.0000a60c(uint param_1)\n\n{\n    ushort uVar1;\n    ushort uVar2;\n    ushort uVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint uVar7;\n    uint16_t uVar8;\n    int32_t iVar9;\n    int32_t extraout_r1;\n    int32_t extraout_r1_00;\n    uint32_t uVar10;\n    int32_t extraout_r1_01;\n    int32_t extraout_r1_02;\n    int32_t extraout_r1_03;\n    int32_t extraout_r1_04;\n    uint extraout_r1_05;\n    int32_t extraout_r1_06;\n    int32_t extraout_r1_07;\n    int32_t extraout_r1_08;\n    int32_t extraout_r1_09;\n    int32_t extraout_r1_10;\n    int32_t extraout_r1_11;\n    int32_t extraout_r1_12;\n    int32_t extraout_r1_13;\n    int32_t extraout_r1_14;\n    int32_t extraout_r1_15;\n    int32_t extraout_r1_16;\n    int32_t extraout_r1_17;\n    int32_t extraout_r1_18;\n    int32_t extraout_r1_19;\n    int32_t extraout_r1_20;\n    int32_t extraout_r1_21;\n    int32_t extraout_r1_22;\n    int32_t extraout_r1_23;\n    int32_t extraout_r1_24;\n    int32_t extraout_r1_25;\n    int32_t extraout_r1_26;\n    int32_t extraout_r1_27;\n    int32_t extraout_r1_28;\n    int32_t extraout_r1_29;\n    int32_t extraout_r1_30;\n    int32_t extraout_r1_31;\n    int32_t extraout_r1_32;\n    int32_t extraout_r1_33;\n    int32_t extraout_r1_34;\n    int32_t extraout_r1_35;\n    int32_t extraout_r1_36;\n    int32_t extraout_r1_37;\n    int32_t extraout_r1_38;\n    int32_t extraout_r1_39;\n    int32_t extraout_r1_40;\n    int32_t extraout_r1_41;\n    int32_t extraout_r1_42;\n    int32_t extraout_r1_43;\n    int32_t extraout_r1_44;\n    int32_t extraout_r1_45;\n    int32_t extraout_r1_46;\n    int32_t extraout_r1_47;\n    int32_t extraout_r1_48;\n    int32_t extraout_r1_49;\n    int32_t extraout_r1_50;\n    int32_t extraout_r1_51;\n    int32_t extraout_r1_52;\n    int32_t extraout_r1_53;\n    int32_t extraout_r1_54;\n    int32_t extraout_r1_55;\n    int32_t extraout_r1_56;\n    int32_t extraout_r1_57;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    int32_t extraout_r1_58;\n    int32_t extraout_r1_59;\n    uint uVar13;\n    int32_t extraout_r1_60;\n    uint extraout_r1_61;\n    uint extraout_r1_62;\n    uint extraout_r1_63;\n    uint extraout_r1_64;\n    uint extraout_r1_65;\n    uint extraout_r1_66;\n    uint extraout_r1_67;\n    uint extraout_r1_68;\n    uint uVar14;\n    uchar uVar15;\n    uint8_t uVar16;\n    int32_t iVar17;\n    uint uVar18;\n    uint unaff_r4;\n    int32_t iVar19;\n    uint unaff_r5;\n    int32_t iVar20;\n    uint unaff_r6;\n    uint32_t uVar21;\n    uint unaff_r7;\n    uint unaff_r8;\n    uint32_t uVar22;\n    uint unaff_r9;\n    uint unaff_r10;\n    int32_t iVar23;\n    uint unaff_r11;\n    uint in_lr;\n    bool bVar24;\n    bool bVar25;\n    bool bVar26;\n    uint *puVar27;\n    ulong uVar29;\n    int64_t iVar30;\n    ulong uVar31;\n    ulong uStack_3f0;\n    uint32_t auStack_3e8 [2];\n    ulong uStack_3e0;\n    uint auStack_3d4 [7];\n    uchar auStack_3b8 [20];\n    uchar auStack_3a4 [26];\n    uchar auStack_38a [8];\n    uchar auStack_382 [106];\n    int16_t aiStack_318 [176];\n    uint uStack_1b8;\n    int32_t aiStack_1b0 [30];\n    char acStack_138 [16];\n    uint8_t auStack_128 [112];\n    uchar auStack_b8 [16];\n    uint8_t auStack_a8 [48];\n    uint auStack_78 [4];\n    uint uStack_68;\n    int32_t aiStack_60 [6];\n    uint32_t auStack_48 [5];\n    uint uStack_34;\n    uint uStack_30;\n    uint uStack_2c;\n    uint16_t auStack_28 [2];\n    uint uStack_24;\n    ushort uStack_1e;\n    uint auStack_1c [7];\n    int32_t iVar28;\n    \n    *(*0x54 + -4) = in_lr;\n    puVar27 = *0x54 + -4 + -4;\n    *puVar27 = unaff_r11;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r10;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r9;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r8;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r7;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r6;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r5;\n    puVar27 = puVar27 + -4;\n    *puVar27 = unaff_r4;\n    iVar28 = puVar27 + -4;\n    iVar20 = *0xb5cc;\n    *(iVar28 + -0x3ac) = param_1;\n    *(iVar20 + 0x38) = 0;\n    iVar5 = sym.imp.open(param_1,*(*0xb5d0 + 4));\n    iVar19 = iVar5 + 0;\n    if (iVar19 < 0) {\n        piVar6 = sym.imp.__errno_location();\n        iVar5 = *piVar6;\n        uVar7 = *(iVar28 + -0x3ac);\ncode_r0x0000a80c:\n        sym.imp.perror(uVar7);\n        goto code_r0x0000a6b8;\n    }\n    if (*(iVar20 + 0x450) == 0) {\n        iVar5 = sym.imp.printf(*0xb5d4,*(iVar28 + -0x3ac));\n    }\n    if (*(*0xb5cc + 0x454) != 0) {\n        iVar5 = *(*0xb5cc + 0x458);\n        if ((iVar5 == 1 || iVar5 + -1 < 0 != SBORROW4(iVar5,1)) && (*(*0xb5cc + 0xc) == 0)) {\n    //WARNING: Subroutine does not return\n            fcn.000093e8(*0xb5d8,*0xb5dc);\n        }\n    //WARNING: Subroutine does not return\n        fcn.0000a164(0x16);\n    }\n    iVar20 = *(*0xb5cc + 0x45c);\n    if (iVar20 != 0) {\n        fcn.00015b50(*(*0xb5cc + 0x460));\n    //WARNING: Subroutine does not return\n        fcn.000093e8(*0xb600,*0xb5fc);\n    }\n    if (*(*0xb5cc + 0x468) != 0) {\n        if (*(*0xb5cc + 0x46c) != 0) {\n            sym.imp.printf(*0xb608,*(*0xb5cc + 0x470));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x1262,*(*0xb5cc + 0x470));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            iVar5 = sym.imp.perror(*0xb60c);\n        }\n    }\n    if (*(*0xb5cc + 0x474) != 0) {\n        if (*(*0xb5cc + 0x478) != 0) {\n            iVar9 = *(*0xb5cc + 0x47c);\n            if (iVar9 != 0xff) {\n                bVar25 = iVar9 + -99 < 0;\n                if (iVar9 == 99 || bVar25 != SBORROW4(iVar9,99)) {\n                    iVar5 = *0xb614;\n                }\n                if (iVar9 != 99 && bVar25 == SBORROW4(iVar9,99)) {\n                    bVar26 = SBORROW4(iVar9,199);\n                    bVar25 = iVar9 + -199 < 0;\n                    bVar24 = iVar9 != 199;\n                    if (!bVar24 || bVar25 != bVar26) {\n                        iVar5 = *0xb618;\n                    }\n                    if (!bVar24 || bVar25 != bVar26) {\n                        iVar9 = iVar9 + -100;\n                    }\n                    if (bVar24 && bVar25 == bVar26) {\n                        iVar5 = *0xb61c;\n                    }\n                    if (bVar24 && bVar25 == bVar26) {\n                        iVar9 = iVar9 + -200;\n                    }\n                }\n                sym.imp.printf(iVar5,iVar9);\n            }\n            else {\n                sym.imp.puts(*0xb610);\n            }\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x327,*(*0xb5cc + 0x47c));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb620);\n        }\n    }\n    if (*(*0xb5cc + 0x480) != 0) {\n        if (*(*0xb5cc + 0x484) != 0) {\n            sym.imp.printf(*0xb624,*(*0xb5cc + 0x488));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x324,*(*0xb5cc + 0x488));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb628);\n        }\n    }\n    if (*(*0xb5cc + 0x48c) != 0) {\n        if (*(*0xb5cc + 0x490) != 0) {\n            sym.imp.printf(*0xb62c,*(*0xb5cc + 0x494));\n        }\n        iVar9 = *0xb5cc;\n        iVar5 = sym.imp.ioctl(iVar19,0x321,*(iVar9 + 0x494));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            if (*piVar6 == 0x19) {\n                uVar15 = *(iVar9 + 0x494);\n                *(iVar28 + -0x40) = 0xc6;\n                *(iVar28 + -0x3f) = uVar15;\n                *(iVar28 + -0x3e) = 0;\n                *(iVar28 + -0x3d) = 0;\n    //WARNING: Subroutine does not return\n                fcn.000093a8(*0xb634,*0xb638);\n            }\n            sym.imp.perror(*0xb630);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x498) != 0) {\n        if (*(iVar5 + 0x49c) != 0) {\n            sym.imp.printf(*0xb640,*(iVar5 + 0x4a0));\n            fcn.000099a8(*(iVar5 + 0x4a0));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x125d,*0xb644);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb648);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4a4) != 0) {\n        if (*(iVar5 + 0x4a8) != 0) {\n            sym.imp.printf(*0xb64c,*(iVar5 + 0x4ac));\n            fcn.000099a8(*(iVar5 + 0x4ac));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x322,*(*0xb5cc + 0x4ac));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb650);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4b0) != 0) {\n        if (*(iVar5 + 0x4b4) != 0) {\n            sym.imp.printf(*0xb654,*(iVar5 + 0x4b8));\n            fcn.000099a8(*(iVar5 + 0x4b8));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x326,*(*0xb5cc + 0x4b8));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb658);\n        }\n    }\n    if (*(*0xb5cc + 0x4bc) != 0) {\n        if (*(*0xb5cc + 0x4c0) != 0) {\n            sym.imp.printf(*0xb65c,*(*0xb5cc + 0x4c4));\n        }\n        *(iVar28 + -0x3c8) = 1;\n        iVar20 = fcn.00013d18(iVar19,*0xb660,*0xb5ec,*0xb664);\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4c8) != 0) {\n        if (*(iVar5 + 0x4cc) != 0) {\n            sym.imp.printf(*0xb668,*(iVar5 + 0x4d0));\n            fcn.000099a8(*(iVar5 + 0x4d0));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x325,*(*0xb5cc + 0x4d0));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb66c);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4d4) != 0) {\n        if (*(iVar5 + 0x4d8) != 0) {\n            sym.imp.printf(*0xb670,*(iVar5 + 0x4dc));\n            fcn.000099a8(*(iVar5 + 0x4dc));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x323,*(*0xb5cc + 0x4dc));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb674);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4e0) != 0) {\n        iVar9 = *(iVar5 + 0x4e4);\n        uVar15 = 0;\n        *(iVar28 + -0x40) = 0;\n        bVar25 = iVar9 == 0;\n        if (bVar25) {\n            uVar15 = 0xdf;\n        }\n        if (!bVar25) {\n            uVar15 = 0xde;\n        }\n        *(iVar28 + -0x40) = uVar15;\n        if (*(iVar5 + 0x4e8) != 0) {\n            sym.imp.printf(*0xb678);\n            fcn.000099a8(*(iVar5 + 0x4e4));\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0xf);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb67c);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x4ec) != 0) {\n        *(iVar28 + -0x40) = 0xef;\n        uVar15 = 0;\n        *(iVar28 + -0x3f) = uVar15;\n        *(iVar28 + -0x3e) = uVar15;\n        *(iVar28 + -0x3d) = uVar15;\n        if (*(iVar5 + 0x4f0) != 0) {\n            sym.imp.printf(*0xb680,*(iVar5 + 0x4f4));\n            fcn.000099a8(*(iVar5 + 0x4f4));\n        }\n        if (*(*0xb5cc + 0x4f4) == 0) {\n            uVar15 = 0xcc;\n        }\n        else {\n            uVar15 = 0x66;\n        }\n        *(iVar28 + -0x3e) = uVar15;\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb684);\n        }\n    }\n    if (*(*0xb5cc + 0x4f8) != 0) {\n        iVar5 = *(*0xb5cc + 0x4fc);\n        iVar9 = *(*0xb5cc + 0x500);\n        *(iVar28 + -0x40) = 0xef;\n        *(iVar28 + -0x3f) = 0;\n        *(iVar28 + -0x3d) = 0;\n        if (iVar5 == 0) {\n            uVar15 = 0x84;\n        }\n        else {\n            uVar15 = 4;\n        }\n        *(iVar28 + -0x3e) = uVar15;\n        if (iVar9 != 0) {\n            sym.imp.printf(*0xb688);\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb68c);\n        }\n    }\n    if (*(*0xb5cc + 0x504) != 0) {\n        uVar7 = *(*0xb5cc + 0x508);\n        iVar5 = *(*0xb5cc + 0x50c);\n        *(iVar28 + -0x40) = *(*0xb82c + 0x108);\n        *(iVar28 + -0x3f) = uVar7;\n        if (iVar5 != 0) {\n            sym.imp.printf(*0xb690);\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb694);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x510) != 0) {\n        uVar7 = *(iVar5 + 0x514);\n        *(iVar28 + -0x40) = *(*0xb82c + 0x10c);\n        iVar9 = *(iVar5 + 0x518);\n        *(iVar28 + -0x3f) = uVar7;\n        if (iVar9 != 0) {\n            sym.imp.printf(*0xb698);\n            uVar21 = *(iVar5 + 0x514);\n            sym.imp.printf(*0xb69c);\n            if (uVar21 < 0x18) {\n                if (0xf < uVar21) {\n                    uVar7 = *0xb6ac;\n                    uVar21 = uVar21 + -0x10;\n                    goto code_r0x0000b09c;\n                }\n                if (uVar21 == 1) {\n                    uVar7 = *0xb6a4;\n                }\n                else {\n                    if (uVar21 != 0) {\n                        if (uVar21 < 8) goto code_r0x0000b0a4;\n                        uVar7 = *0xb6a8;\n                        uVar21 = uVar21 + -8;\n                        goto code_r0x0000b09c;\n                    }\n                    uVar7 = *0xb6a0;\n                }\ncode_r0x0000b0a8:\n                sym.imp.printf(uVar7);\n            }\n            else {\n                if (uVar21 < 0x20) {\ncode_r0x0000b0a4:\n                    uVar7 = *0xb6b8;\n                    goto code_r0x0000b0a8;\n                }\n                if (uVar21 < 0x28) {\n                    uVar7 = *0xb6b0;\n                    uVar21 = uVar21 + -0x20;\n                }\n                else {\n                    uVar21 = uVar21 + -0x40;\n                    if (7 < uVar21) goto code_r0x0000b0a4;\n                    uVar7 = *0xb6b4;\n                }\ncode_r0x0000b09c:\n                sym.imp.printf(uVar7,uVar21);\n            }\n            sym.imp.puts(*0xb738);\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6bc);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x51c) != 0) {\n        iVar9 = *(iVar5 + 0x520);\n        *(iVar28 + -0x40) = 0xef;\n        iVar17 = 0;\n        *(iVar28 + -0x3f) = 0;\n        bVar25 = iVar9 == iVar17;\n        *(iVar28 + -0x3d) = 0;\n        if (bVar25) {\n            iVar17 = 0x55;\n        }\n        uVar15 = iVar17;\n        if (!bVar25) {\n            uVar15 = 0xaa;\n        }\n        *(iVar28 + -0x3e) = uVar15;\n        if (*(iVar5 + 0x524) != 0) {\n            sym.imp.printf(*0xb6c0);\n            fcn.000099a8(*(iVar5 + 0x520));\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6c4);\n        }\n    }\n    if (*(*0xb5cc + 0x528) != 0) {\n        iVar5 = *(*0xb5cc + 0x52c);\n        *(iVar28 + -0x40) = 0xef;\n        uVar15 = 0;\n        *(iVar28 + -0x3f) = uVar15;\n        *(iVar28 + -0x3e) = uVar15;\n        *(iVar28 + -0x3d) = uVar15;\n        if (iVar5 != 0) {\n    //WARNING: Subroutine does not return\n            fcn.000093a8(*0xb6cc,*0xb6d0);\n        }\n        *(iVar28 + -400) = *(*0xb82c + 0x110);\n        sym.imp.printf(*0xb6c8);\n        sym.imp.fflush(**0xb810);\n        fcn.00012ed0(iVar19,iVar28 + -400,iVar5);\n        iVar5 = *0xb5cc;\n        if (*(iVar5 + 0x530) != 0) {\n            sym.imp.printf(*0xb6d4,*(iVar5 + 0x52c));\n            sym.imp.fflush(**0xb810);\n            fcn.000099a8(*(iVar5 + 0x52c));\n        }\n        *(iVar28 + -0x40) = 0xef;\n        if (*(*0xb5cc + 0x52c) == 0) {\n            uVar15 = 0x86;\n        }\n        else {\n            uVar15 = 6;\n        }\n        *(iVar28 + -0x3e) = uVar15;\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6d8);\n        }\n    }\n    if (*(*0xb5cc + 0x534) != 0) {\n        *(iVar28 + -400) = 0xef;\n        uVar15 = 0;\n        *(iVar28 + -399) = uVar15;\n        *(iVar28 + -0x18e) = uVar15;\n        *(iVar28 + -0x18d) = uVar15;\n        if (*(*0xb5cc + 0x538) != 0) {\n            sym.imp.printf(*0xb6dc);\n        }\n        iVar5 = *(*0xb5cc + 0x53c);\n        if (iVar5 != 0xff) {\n            iVar9 = *(*0xb5cc + 0x538);\n            *(iVar28 + -0x18e) = 5;\n            *(iVar28 + -399) = iVar5;\n            if (iVar9 != 0) {\n                sym.imp.printf(*0xb6e4,iVar5,iVar5);\n            }\n        }\n        else {\n            iVar5 = *(*0xb5cc + 0x538);\n            *(iVar28 + -0x18e) = 0x85;\n            if (iVar5 != 0) {\n                sym.imp.puts(*0xb6e0);\n            }\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6e8);\n        }\n    }\n    if (*(*0xb5cc + 0x540) != 0) {\n        if (*(*0xb5cc + 0x544) != 0) {\n            sym.imp.printf(*0xb6ec,*(*0xb5cc + 0x548));\n        }\n        iVar9 = *0xb5cc;\n        iVar5 = fcn.000156b8(iVar19,*(iVar9 + 0x548));\n        iVar9 = sym.imp.ioctl(iVar19,0x5322,*(iVar9 + 0x548));\n        bVar25 = iVar9 == 0;\n        if (!bVar25) {\n            bVar25 = iVar5 == 0;\n        }\n        if (!bVar25) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6f0);\n        }\n    }\n    if (*(*0xb5cc + 0x54c) != 0) {\n        if (*(*0xb5cc + 0x550) != 0) {\n            sym.imp.printf(*0xb6f4,*(*0xb5cc + 0x554));\n        }\n        *(iVar28 + -400) = 0xef;\n        *(iVar28 + -0x18d) = 0;\n        iVar5 = *(*0xb5cc + 0x554);\n        *(iVar28 + -399) = iVar5;\n        if (iVar5 == 0) {\n            uVar15 = 0xc2;\n        }\n        else {\n            uVar15 = 0x42;\n        }\n        *(iVar28 + -0x18e) = uVar15;\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb6f8);\n        }\n    }\n    if (*(*0xb5cc + 0x558) != 0) {\n        if (*(*0xb5cc + 0x55c) != 0) {\n            sym.imp.printf(*0xb6fc,*(*0xb5cc + 0x560));\n        }\n        *(iVar28 + -400) = 0xef;\n        *(iVar28 + -0x18d) = 0;\n        iVar5 = *(*0xb5cc + 0x560);\n        *(iVar28 + -399) = iVar5;\n        if (iVar5 == 0) {\n            uVar15 = 0x8b;\n        }\n        else {\n            uVar15 = 0xb;\n        }\n        *(iVar28 + -0x18e) = uVar15;\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb700);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x564) != 0) {\n        if (*(iVar5 + 0x568) != 0) {\n            sym.imp.printf(*0xb704,*(iVar5 + 0x56c));\n            fcn.000099a8(*(iVar5 + 0x56c));\n        }\n        if (*(*0xb5cc + 0x56c) == 0) {\n            iVar20 = fcn.00009b54(iVar19);\n        }\n        iVar9 = *0xb5cc;\n        iVar5 = sym.imp.ioctl(iVar19,0x32b,*(iVar9 + 0x56c));\n        if (iVar5 != 0) {\n            *(iVar28 + -400) = 0xef;\n            iVar5 = *(iVar9 + 0x56c);\n            *(iVar28 + -399) = 0;\n            *(iVar28 + -0x18d) = 0;\n            if (iVar5 == 0) {\n                uVar15 = 0x82;\n            }\n            else {\n                uVar15 = 2;\n            }\n            *(iVar28 + -0x18e) = uVar15;\n            iVar5 = fcn.00012ed0(iVar19,iVar28 + -400);\n            if (iVar5 != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xb708);\n            }\n        }\n        if (*(*0xb5cc + 0x56c) == 0) {\n            iVar20 = fcn.00009b54(iVar19);\n        }\n    }\n    iVar5 = *0xb5cc;\n    if (*(iVar5 + 0x570) != 0) {\n        uVar7 = *(iVar5 + 0x574);\n        *(iVar28 + -400) = 0xe3;\n        *(iVar28 + -0x18e) = -0x1d + '\\x1d';\n        *(iVar28 + -0x18d) = -0x1d + '\\x1d';\n        iVar9 = *(iVar5 + 0x578);\n        *(iVar28 + -399) = uVar7;\n        if (iVar9 != 0) {\n            sym.imp.printf(*0xb70c);\n            sym.imp.printf(*0xb69c);\n            iVar5 = *(iVar5 + 0x574);\n            if (iVar5 == 0xfd) {\n                uVar7 = *0xb718;\ncode_r0x0000b94c:\n                sym.imp.printf(uVar7);\n            }\n            else {\n                if (iVar5 != 0xfd && iVar5 + -0xfd < 0 == SBORROW4(iVar5,0xfd)) {\n                    if (iVar5 == 0xfe) {\n                        uVar7 = *0xb71c;\n                    }\n                    else {\n                        if (iVar5 != 0xff) goto code_r0x0000b854;\n                        uVar7 = *0xb720;\n                    }\n                    goto code_r0x0000b94c;\n                }\n                if (iVar5 == 0) {\n                    uVar7 = *0xb710;\n                    goto code_r0x0000b94c;\n                }\n                if (iVar5 == 0xfc) {\n                    uVar7 = *0xb714;\n                    goto code_r0x0000b94c;\n                }\ncode_r0x0000b854:\n                if (iVar5 != 0xf0 && iVar5 + -0xf0 < 0 == SBORROW4(iVar5,0xf0)) {\n                    if (iVar5 != 0xfb && iVar5 + -0xfb < 0 == SBORROW4(iVar5,0xfb)) {\n                        uVar7 = *0xb734;\n                        goto code_r0x0000b94c;\n                    }\n                    iVar5 = iVar5 * 0x1e + -0x1c00 + -0x20;\n                    iVar9 = fcn.00015c8c(iVar5,0x3c);\n                    fcn.00015d34(iVar5,0x3c);\n                    iVar5 = extraout_r1_00;\n                    if (iVar9 != 0) {\n                        sym.imp.printf(*0xb728,iVar9);\n                    }\n                    iVar17 = extraout_r1_00 + 0;\n                    if (iVar17 != 0) {\n                        iVar17 = 1;\n                    }\n                    bVar25 = iVar9 == 0;\n                    if (!bVar25) {\n                        bVar25 = extraout_r1_00 == 0;\n                    }\n                    if (bVar25) {\n                        if (iVar17 == 0) goto code_r0x0000b950;\n                    }\n                    else {\n                        sym.imp.printf(*0xb72c);\n                    }\n                    uVar7 = *0xb730;\ncode_r0x0000b93c:\n                    sym.imp.printf(uVar7,iVar5);\n                }\n                else {\n                    iVar9 = fcn.00015c8c(iVar5 * 5,0x3c);\n                    fcn.00015d34(iVar5 * 5,0x3c);\n                    if (iVar9 != 0) {\n                        sym.imp.printf(*0xb730,iVar9);\n                    }\n                    iVar5 = extraout_r1 + 0;\n                    if (iVar5 != 0) {\n                        iVar5 = 1;\n                    }\n                    bVar25 = iVar9 == 0;\n                    if (!bVar25) {\n                        bVar25 = extraout_r1 == 0;\n                    }\n                    if (!bVar25) {\n                        sym.imp.printf(*0xb72c);\ncode_r0x0000b8bc:\n                        uVar7 = *0xb724;\n                        iVar5 = extraout_r1;\n                        goto code_r0x0000b93c;\n                    }\n                    if (iVar5 != 0) goto code_r0x0000b8bc;\n                }\n            }\ncode_r0x0000b950:\n            sym.imp.puts(*0xb738);\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb73c);\n        }\n    }\n    iVar5 = *0xb850;\n    if (*(iVar5 + 0x57c) != 0) {\n        iVar9 = sym.imp.malloc(0x228);\n        iVar17 = iVar9 + 0;\n        if (iVar17 == 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            uVar7 = *0xb808;\n            goto code_r0x0000a80c;\n        }\n        sym.imp.memset(iVar9,0,0x228);\n        *(iVar17 + 0x1c) = 3;\n        *(iVar17 + 0x18) = 4;\n        *(iVar17 + 0x20) = 4 + 0x1fc;\n        iVar23 = *(*0xb804 + 8);\n        *(iVar17 + 7) = iVar23;\n        *(iVar17 + 0x10) = *(iVar17 + 0x10) | 8;\n        *(iVar17 + 2) = 1;\n        iVar9 = *(iVar5 + 0x580);\n        *(iVar17 + 0x28) = iVar9 & 1;\n        sym.imp.memcpy(iVar17 + 0x2a,iVar5 + 0x14,0x20);\n        *(iVar17 + 0x10) = *(iVar17 + 0x10) | 0x82;\n    //switch table (6 cases) at 0xba30\n        switch(iVar23 + -0xf1) {\n        case 0:\n            *(iVar17 + 0x29) = *(iVar5 + 0x588) & 1;\n            if (iVar9 == 0) {\ncode_r0x0000baec:\n                uVar7 = *0xb770;\n                break;\n            }\n            fcn.00009a24(iVar19);\n            if (*(*0xb850 + 0x38) != 0) {\n                uVar21 = *(*(*0xb850 + 0x38) + 0xb8);\n                if (uVar21 == 0xfffe) {\n                    uVar21 = 0;\n                }\n                uVar21 = uVar21 + 1 & 0xffff;\n                *(iVar17 + 0x4a) = uVar21;\n                *(iVar17 + 0x4b) = uVar21 >> 8;\n                goto code_r0x0000baec;\n            }\n            goto code_r0x0000a6b4;\n        case 1:\n            uVar7 = *0xb76c;\n            break;\n        default:\n            sym.imp.fprintf(**0xb824,*0xb740,iVar23);\n            iVar5 = 0x16;\n            goto code_r0x0000a6b8;\n        case 3:\n            iVar5 = *(iVar5 + 0x584);\n            uVar7 = *0xb764;\n            bVar25 = iVar5 != 0;\n            if (bVar25) {\n                iVar5 = 2;\n            }\n            uVar16 = iVar5;\n            if (!bVar25) {\n                uVar16 = 0;\n            }\n            *(iVar17 + 0x28) = uVar16 | *(iVar17 + 0x28);\n            break;\n        case 5:\n            uVar7 = *0xb768;\n        }\n        uVar14 = *0xb74c;\n        if ((*(iVar17 + 0x28) & 1) == 0) {\n            uVar14 = *0xb744;\n        }\n        sym.imp.printf(*0xb748,uVar7,*0xb750,uVar14);\n        if (*(*0xb804 + 8) == 0xf1) {\n            uVar7 = *0xb754;\n            if (*(iVar17 + 0x29) == '\\0') {\n                uVar7 = *0xb758;\n            }\n            sym.imp.printf(*0xb75c,uVar7);\n        }\n        iVar9 = *0xb804;\n        sym.imp.putchar(10);\n        iVar5 = *(iVar9 + 8);\n        if (iVar5 != 0xf4) {\n            if (iVar5 == 0xf6) {\n                *(iVar17 + 7) = 0xf2;\n                iVar5 = fcn.0001303c(iVar19,iVar17,0xf);\n                if (iVar5 != 0) {\ncode_r0x0000bcac:\n                    piVar6 = sym.imp.__errno_location();\n                    iVar5 = *piVar6;\n                    uVar7 = *0xb76c;\n                }\n                else {\n                    *(iVar17 + 7) = *(iVar9 + 8);\n                    iVar5 = fcn.0001303c(iVar19,iVar17,0xf);\n                    iVar5 = iVar5 + 0;\n                    if (iVar5 == 0) goto code_r0x0000bd04;\n                    piVar6 = sym.imp.__errno_location();\n                    iVar5 = *piVar6;\n                    uVar7 = *0xb768;\n                }\n                goto code_r0x0000bce8;\n            }\n            if (iVar5 != 0xf2) {\n                if (iVar5 != 0xf1) {\n                    iVar5 = 0x16;\n                    sym.imp.fprintf(**0xb824,*0xb774);\n                }\n                else {\n                    iVar5 = fcn.0001303c(iVar19,iVar17,0xf);\n                    iVar5 = iVar5 + 0;\n                    if (iVar5 != 0) {\n                        piVar6 = sym.imp.__errno_location();\n                        iVar5 = *piVar6;\n                        uVar7 = *0xb770;\n                        goto code_r0x0000bce8;\n                    }\n                }\n            }\n            else {\n                iVar5 = fcn.0001303c(iVar19,iVar17,0xf);\n                iVar5 = iVar5 + 0;\n                if (iVar5 != 0) goto code_r0x0000bcac;\n            }\n        }\n        else {\n            iVar5 = *0xb850;\n            iVar9 = *(iVar5 + 0x584);\n            fcn.00009a24(iVar19);\n            iVar5 = *(iVar5 + 0x38);\n            if (iVar5 == 0) {\n                uVar21 = 0x78;\n            }\n            else {\n                uVar21 = *(iVar5 + iVar9 * 2 + 0xb2);\n                if (uVar21 + -1 < 0xff) {\n                    if (uVar21 != 0xff) {\n                        uVar21 = (uVar21 + 0xf) * 2;\n                    }\n                    else {\n                        uVar29 = fcn.00009280();\n                        uVar29 = fcn.00016c34(uVar29,uVar29 >> 0x20,0x384000,0);\n                        uVar21 = uVar29;\n                        if ((uVar29 >> 0x20 != 0) || (0x238 < uVar21)) goto code_r0x0000bbc4;\n                        uVar21 = 0x238;\n                    }\n                }\n                else {\ncode_r0x0000bbc4:\n                    if (uVar21 == 0) {\n                        uVar21 = 0x78;\n                    }\n                }\n            }\n            *(iVar28 + -400) = 0xf3;\n            *(iVar28 + -399) = 0;\n            *(iVar28 + -0x18e) = 0;\n            *(iVar28 + -0x18d) = 0;\n            iVar5 = fcn.00012ed0(iVar19,iVar28 + -400);\n            if (iVar5 == 0) {\n                iVar5 = fcn.0001303c(iVar19,iVar17,uVar21 * 0x3c);\n                iVar5 = iVar5 + 0;\n                if (iVar5 == 0) goto code_r0x0000bd04;\n                piVar6 = sym.imp.__errno_location();\n                iVar5 = *piVar6;\n                uVar7 = *0xb764;\n            }\n            else {\n                piVar6 = sym.imp.__errno_location();\n                iVar5 = *piVar6;\n                uVar7 = *0xb760;\n            }\ncode_r0x0000bce8:\n            sym.imp.perror(uVar7);\n        }\ncode_r0x0000bd04:\n        sym.imp.free(iVar17);\n        if (iVar5 != 0) goto code_r0x0000a6b8;\n    }\n    if ((*(*0xb850 + 0x58c) != 0) && (iVar5 = fcn.00009ad8(iVar19,0), iVar5 != 0)) {\n        fcn.000120d8();\n    }\n    if (*(*0xb850 + 0x590) != 0) {\n        *(iVar28 + -400) = *(*0xb82c + 0x114);\n    //WARNING: Subroutine does not return\n        fcn.000093a8(*0xb77c,*0xb778);\n    }\n    if (*(*0xb850 + 0x594) != 0) {\n        *(iVar28 + -400) = *(*0xb82c + 0x118);\n        sym.imp.puts(*0xb788);\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb78c);\n        }\n    }\n    if (*(*0xb850 + 0x598) != 0) {\n        *(iVar28 + -400) = 0xf5;\n        *(iVar28 + -399) = 0;\n        *(iVar28 + -0x18e) = 0;\n        *(iVar28 + -0x18d) = 0;\n        sym.imp.puts(*0xb790);\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb794);\n        }\n    }\n    if (*(*0xb850 + 0x59c) != 0) {\n        *(iVar28 + -400) = 0xfb;\n        uVar15 = 0;\n        *(iVar28 + -399) = uVar15;\n        *(iVar28 + -0x18e) = uVar15;\n        *(iVar28 + -0x18d) = uVar15;\n        if (*(*0xb850 + 0x5a0) != 0) {\n            sym.imp.puts(*0xb798);\n        }\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb79c);\n        }\n    }\n    if (*(*0xb850 + 0x5a4) != 0) {\n        if (*(*0xb850 + 0x5a8) != 0) {\n            uVar10 = *(*0xb850 + 0x5ac);\n            uVar21 = uVar10;\n            if (2 < uVar10) {\n                uVar21 = 3;\n            }\n            sym.imp.printf(*0xb7a0,uVar10,*(*0xb82c + uVar21 * 4 + 0x11c));\n        }\n        iVar5 = sym.imp.ioctl(iVar19,0x32d,*(*0xb850 + 0x5ac));\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb7a4);\n        }\n    }\n    iVar5 = *0xb850;\n    if (*(iVar5 + 0x5b0) != 0) {\n        if (*(iVar5 + 0x5b4) != 0) {\n            uVar14 = *(iVar5 + 0x5b8);\n            uVar18 = *(iVar5 + 0x5bc);\n            uVar7 = *0xb7ac;\n            if (*(iVar5 + 0x5c0) != 0) {\n                uVar7 = *0xb7a8;\n            }\n            *(iVar28 + -0x3c8) = uVar7;\n            sym.imp.printf(*0xb7b0,uVar7,uVar14,uVar18);\n        }\n        iVar9 = *0xb850;\n        fcn.00009a24(iVar19);\n        iVar5 = extraout_r1_01;\n        if (*(iVar9 + 0x38) != 0) {\n            uVar29 = fcn.00009280();\n            uVar21 = uVar29 >> 0x20;\n            if ((*(*0xb7b4 + 4) < uVar21) || ((*(*0xb7b4 + 4) == uVar21 && (*(iVar9 + 0x5b8) < uVar29)))) {\n    //WARNING: Subroutine does not return\n                fcn.000093a8(*0xb7b8,*0xb7bc);\n            }\n            iVar5 = *0xb850;\n            iVar20 = *(iVar5 + 0x5b8);\n            iVar9 = *(iVar5 + 0x5bc);\n            iVar17 = *(iVar5 + 0x5c0);\n            fcn.00009a24(iVar19);\n            iVar5 = *(iVar5 + 0x38);\n            if (iVar5 == 0) {\ncode_r0x0000a6b4:\n                iVar5 = 5;\n                goto code_r0x0000a6b8;\n            }\n            uVar21 = iVar20 - 1;\n            iVar20 = iVar9 + -1 + (iVar20 != 0);\n            iVar17 = iVar17 + 0;\n            if (iVar17 != 0) {\n                iVar17 = 1;\n            }\n            if (((iVar20 != 0) || (0xffffffe < uVar21)) ||\n               (((*(iVar5 + 0xa6) & 0xc400) == 0x4400 && ((*(iVar5 + 0xac) & 0x400) != 0)))) {\n                *(iVar28 + -0x3c8) = uVar21;\n                *(iVar28 + -0x3c4) = iVar20;\n                *(iVar28 + -0x3c0) = iVar17;\n                *(iVar28 + -0x3bc) = 0;\n                fcn.00013780(iVar28 + -0x90,0x37,0,1);\n            }\n            else {\n                *(iVar28 + -0x3c8) = uVar21;\n                *(iVar28 + -0x3c4) = iVar20;\n                *(iVar28 + -0x3c0) = iVar17;\n                *(iVar28 + -0x3bc) = 0;\n                fcn.00013780(iVar28 + -0x90,0xf9,0,0);\n                *(iVar28 + -0x80) = *(iVar28 + -0x80) | 2;\n            }\n            iVar30 = fcn.00009bd4(iVar19);\n            if (iVar30 != 0) {\n                uVar29 = fcn.0001303c(iVar19,iVar28 + -0x90,0);\n                iVar5 = uVar29 >> 0x20;\n                iVar20 = uVar29 + 0;\n                if (iVar20 != 0) {\n                    piVar6 = sym.imp.__errno_location();\n                    iVar20 = *piVar6;\n                    sym.imp.perror(*0xb7c0);\n                    iVar5 = extraout_r1_02;\n                }\n            }\n            else {\n                uVar29 = sym.imp.__errno_location();\n                iVar5 = uVar29 >> 0x20;\n                iVar20 = *uVar29;\n            }\n            *(*0xb850 + 0x38) = 0;\n        }\n    }\n    iVar9 = *0xb850;\n    if ((*(iVar9 + 0x5c4) != 0) && (fcn.00009a24(iVar19), iVar5 = extraout_r1_03, *(iVar9 + 0x38) != 0)) {\n    //WARNING: Subroutine does not return\n        fcn.000093a8(*0xb7c4,*0xb7c8);\n    }\n    if (*(*0xb850 + 0x5cc) != 0) {\n        iVar5 = *(*0xb850 + 0x458);\n        if ((iVar5 == 1 || iVar5 + -1 < 0 != SBORROW4(iVar5,1)) && (*(*0xb850 + 0xc) == 0)) {\n    //WARNING: Subroutine does not return\n            fcn.000093e8(*0xb7e4,*0xb7e0);\n        }\n    //WARNING: Subroutine does not return\n        fcn.0000a164(0x16);\n    }\n    if (*(*0xb850 + 0x5d4) != 0) {\n        iVar5 = *(*0xb850 + 0x458);\n        if ((iVar5 == 1 || iVar5 + -1 < 0 != SBORROW4(iVar5,1)) && (*(*0xb850 + 0xc) == 0)) {\n    //WARNING: Subroutine does not return\n            fcn.000093a8(*0xb7ec,*0xb7e8);\n        }\n    //WARNING: Subroutine does not return\n        fcn.0000a164(0x16);\n    }\n    if (*(*0xb850 + 0x5d8) != 0) {\n        iVar20 = *(*0xb850 + 0x458);\n        if ((iVar20 == 1 || iVar20 + -1 < 0 != SBORROW4(iVar20,1)) && (*(*0xb850 + 0xc) == 0)) {\n            *(iVar28 + -0x3c4) = *0xb7f4;\n            *(iVar28 + -0x3c8) = *(iVar28 + -0x3ac);\n            fcn.00009db8(iVar19,iVar5,0,0);\n    //WARNING: Subroutine does not return\n            fcn.000093a8(*0xb800,*0xb7f8);\n        }\n    //WARNING: Subroutine does not return\n        fcn.0000a164(0x16);\n    }\n    if (*(*0xb850 + 0x5e4) != 0) {\n        uVar21 = *(*0xb804 + 0x20);\n        iVar20 = *(*0xb804 + 0x24);\n        *(iVar28 + -0x3c4) = 0;\n        *(iVar28 + -0x3c8) = *(iVar28 + -0x3ac);\n        fcn.00009db8(iVar19,iVar5,uVar21,iVar20);\n        iVar5 = sym.imp.malloc(0x228);\n        iVar5 = iVar5 + 0;\n        if (iVar5 != 0) {\n            if ((iVar20 != 0) || (0xffffffe < uVar21)) {\n                uVar7 = 0x24;\n            }\n            else {\n                uVar7 = 0x20;\n            }\n            *(iVar28 + -0x3c0) = 1;\n            *(iVar28 + -0x3bc) = 0x200;\n            *(iVar28 + -0x3c4) = iVar20;\n            *(iVar28 + -0x3c8) = uVar21;\n            fcn.00013780(iVar5,uVar7,0,0);\n            sym.imp.printf(*0xb80c,extraout_r1_05,uVar21,iVar20);\n            sym.imp.fflush(**0xb810);\n            iVar20 = fcn.0001303c(iVar19,iVar5,0x3c);\n            if (iVar20 + 0 == 0) {\n                sym.imp.puts(*0xb818);\n                fcn.0000a3c8(iVar5 + 0x28);\n                iVar20 = 0;\n            }\n            else {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xb814);\n            }\n            sym.imp.free(iVar5);\n            iVar5 = extraout_r1_06;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb808);\n            iVar5 = extraout_r1_04;\n        }\n    }\n    iVar9 = *0xb850;\n    if ((*(iVar9 + 0x5e8) != 0) && (fcn.00009a24(iVar19), iVar5 = extraout_r1_07, *(iVar9 + 0x38) != 0)) {\n        *(iVar28 + -400) = 0;\n        *(iVar28 + -400) = *(iVar9 + 0x240);\n        sym.imp.puts(*0xb81c);\n        fcn.0000a024(iVar19);\n        sym.imp.sleep(1);\n        fcn.00012ed0(iVar19,iVar28 + -400,0x3c);\n        piVar6 = sym.imp.__errno_location();\n        iVar20 = *piVar6;\n        sym.imp.perror(*0xb820);\n        sym.imp.fprintf(**0xb824,*0xb828,*(iVar28 + -400),*(iVar28 + -399));\n        iVar5 = extraout_r1_08;\n    }\n    iVar9 = *0xb850;\n    *(iVar9 + 0x38) = 0;\n    if (*(iVar9 + 0x5ec) != 0) {\n        *(iVar28 + -400) = *(*0xb82c + 300);\n        iVar5 = fcn.00012ed0(iVar19);\n        if (iVar5 == 0) {\n            sym.imp.printf(*0xb834);\n            uVar16 = *(iVar28 + -0x18e);\n            if (uVar16 == 0) {\n                uVar7 = *0xb838;\ncode_r0x0000c7a0:\n                sym.imp.printf(uVar7);\n            }\n            else {\n                if (uVar16 == 0xff) {\n                    uVar7 = *0xb83c;\n                    goto code_r0x0000c7a0;\n                }\n                sym.imp.printf(*0xb840,(uVar16 >> 1) + -0x14);\n            }\n            uVar7 = *0xb844;\n            if ((*(iVar28 + -399) & 0x10) != 0) {\n                uVar7 = *0xb84c;\n            }\n            sym.imp.printf(*0xb848,uVar7);\n            iVar5 = extraout_r1_10;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xb830);\n            iVar5 = extraout_r1_09;\n        }\n    }\n    if (((*(*0xb850 + 0x5f0) != 0) || (*(*0xb850 + 0x490) != 0)) || (*(*0xb850 + 0x5f4) != 0)) {\n        iVar9 = *0xb850;\n        uVar7 = *0xd7c4;\n        *(iVar9 + 0x5f8) = 0xffffffff;\n        uVar29 = sym.imp.ioctl(iVar19,0x304,uVar7);\n        iVar5 = uVar29 >> 0x20;\n        if (uVar29 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            fcn.00009a24(iVar19);\n            iVar5 = extraout_r1_11;\n            if (*(iVar9 + 0x38) == 0) {\n                if (iVar20 != 0) {\n                    if (*(iVar9 + 0x490) != 0) {\n                        *piVar6 = iVar20;\n                        sym.imp.perror(*0xd7c8);\n                        iVar5 = extraout_r1_12;\n                    }\n                    goto code_r0x0000c8b8;\n                }\n            }\n            else {\n                uVar21 = *(*(iVar9 + 0x38) + 0x76);\n                if ((uVar21 & 0xff00) == 0x100) {\n                    uVar21 = uVar21 & 0xff;\n                }\n                else {\n                    uVar21 = 0;\n                }\n                *(iVar9 + 0x5f8) = uVar21;\n            }\n        }\n        if ((*(*0xd7cc + 0x5f0) != 0) || (iVar20 = *(*0xd7cc + 0x490), iVar20 != 0)) {\n            iVar5 = *0xd7cc;\n            sym.imp.printf(*0xd7d0,*(iVar5 + 0x5f8));\n            iVar20 = 0;\n            fcn.000099a8(*(iVar5 + 0x5f8));\n            iVar5 = extraout_r1_13;\n        }\n    }\ncode_r0x0000c8b8:\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x484) != 0)) {\n        uVar29 = sym.imp.ioctl(iVar19,0x309,*0xd7d4);\n        iVar5 = uVar29 >> 0x20;\n        iVar9 = *0xd7cc;\n        if (uVar29 != 0) {\n            if (*(iVar9 + 0x484) != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xd7f4);\n                iVar5 = extraout_r1_15;\n            }\n        }\n        else {\n            sym.imp.printf(*0xd7d8,*(iVar9 + 0x5fc));\n    //switch table (9 cases) at 0xc90c\n            switch(*(iVar9 + 0x5fc)) {\n            case 0:\n                uVar7 = *0xd7dc;\n                break;\n            case 1:\n                uVar7 = *0xd7e4;\n                break;\n            case 2:\n                uVar7 = *0xd7e0;\n                break;\n            case 3:\n                uVar7 = *0xd7e8;\n                break;\n            default:\n                uVar7 = *0xd7f0;\n                break;\n            case 8:\n                uVar7 = *0xd7ec;\n            }\n            sym.imp.puts(uVar7);\n            iVar5 = extraout_r1_14;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x4a8) != 0)) {\n        uVar29 = sym.imp.ioctl(iVar19,0x302,*0xd7d4);\n        iVar5 = uVar29 >> 0x20;\n        iVar9 = *0xd7cc;\n        if (uVar29 != 0) {\n            if (*(iVar9 + 0x4a8) != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xd7fc);\n                iVar5 = extraout_r1_17;\n            }\n        }\n        else {\n            sym.imp.printf(*0xd7f8,*(iVar9 + 0x5fc));\n            fcn.000099a8(*(iVar9 + 0x5fc));\n            iVar5 = extraout_r1_16;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x4b4) != 0)) {\n        uVar29 = sym.imp.ioctl(iVar19,0x30b,*0xd7d4);\n        iVar5 = uVar29 >> 0x20;\n        iVar9 = *0xd7cc;\n        if (uVar29 != 0) {\n            if (*(iVar9 + 0x4b4) != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xd808);\n                iVar5 = extraout_r1_20;\n            }\n        }\n        else {\n            sym.imp.printf(*0xd800,*(iVar9 + 0x5fc));\n            if (*(iVar9 + 0x5fc) != 8) {\n                fcn.000099a8();\n                iVar5 = extraout_r1_19;\n            }\n            else {\n                sym.imp.puts(*0xd804);\n                iVar5 = extraout_r1_18;\n            }\n        }\n    }\n    iVar9 = *0xd7cc;\n    if (*(iVar9 + 0x4c0) != 0) {\n        *(iVar28 + -0x3c8) = 0;\n        *(iVar28 + -0x3c4) = 1;\n        uVar29 = fcn.00013cc8(iVar19,*0xd80c,*0xd810,*0xd814);\n        iVar5 = uVar29 >> 0x20;\n        iVar20 = uVar29 + 0;\n        if (iVar20 == 0) {\n            sym.imp.printf(*0xd818,*(iVar9 + 0x4c4));\n            iVar5 = extraout_r1_21;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x4d8) != 0)) {\n        uVar29 = sym.imp.ioctl(iVar19,0x308,*0xd7d4);\n        iVar5 = uVar29 >> 0x20;\n        iVar9 = *0xd7cc;\n        if (uVar29 != 0) {\n            if (*(iVar9 + 0x4d8) != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar20 = *piVar6;\n                sym.imp.perror(*0xd820);\n                iVar5 = extraout_r1_23;\n            }\n        }\n        else {\n            sym.imp.printf(*0xd81c,*(iVar9 + 0x5fc));\n            fcn.000099a8(*(iVar9 + 0x5fc));\n            iVar5 = extraout_r1_22;\n        }\n    }\n    iVar9 = *0xd7cc;\n    if (*(iVar9 + 0x4cc) != 0) {\n        iVar5 = sym.imp.ioctl(iVar19,0x30a,*0xd7d4);\n        if (iVar5 == 0) {\n            sym.imp.printf(*0xd828,*(iVar9 + 0x5fc));\n            fcn.000099a8(*(iVar9 + 0x5fc));\n            iVar5 = extraout_r1_25;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xd824);\n            iVar5 = extraout_r1_24;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x49c) != 0)) {\n        iVar5 = sym.imp.ioctl(iVar19,0x125e,*0xd7d4);\n        iVar9 = *0xd7cc;\n        if (iVar5 == 0) {\n            sym.imp.printf(*0xd830,*(iVar9 + 0x5fc));\n            fcn.000099a8(*(iVar9 + 0x5fc));\n            iVar5 = extraout_r1_27;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xd82c);\n            iVar5 = extraout_r1_26;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x46c) != 0)) {\n        iVar5 = sym.imp.ioctl(iVar19,0x1263,*0xd7d4);\n        iVar9 = *0xd7cc;\n        if (iVar5 == 0) {\n            sym.imp.printf(*0xd838,*(iVar9 + 0x5fc));\n            fcn.000099a8(*(iVar9 + 0x5fc));\n            iVar5 = extraout_r1_29;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\n            sym.imp.perror(*0xd834);\n            iVar5 = extraout_r1_28;\n        }\n    }\n    if ((*(*0xd7cc + 0x5f0) != 0) || (*(*0xd7cc + 0x600) != 0)) {\n        *(iVar28 + -4) = 0;\n        *(iVar28 + -8) = 0;\n        *(iVar28 + -0xc) = 0;\n        *(iVar28 + -0x20) = 0;\n        *(iVar28 + -0x1c) = 0;\n        *(iVar28 + -0x18) = 0;\n        *(iVar28 + -0x14) = 0;\n        *(iVar28 + -0x3c8) = iVar28 + -0x20;\n        *(iVar28 + -0x3c4) = iVar28 + -0x18;\n        uVar29 = fcn.0001402c(iVar19,iVar28 + -4,iVar28 + -8,iVar28 + -0xc);\n        iVar5 = uVar29 >> 0x20;\n        iVar20 = uVar29 + 0;\n        if (iVar20 == 0) {\n            *(iVar28 + -0x3c8) = *(iVar28 + -0x18);\n            *(iVar28 + -0x3c4) = *(iVar28 + -0x14);\n            sym.imp.printf(*0xd83c,*(iVar28 + -4),*(iVar28 + -8),*(iVar28 + -0xc));\n            if ((*(iVar28 + -0x20) != -1) || (*(iVar28 + -0x1c) != -1)) {\n                sym.imp.printf(*0xd844);\n                iVar5 = extraout_r1_31;\n            }\n            else {\n                sym.imp.puts(*0xd840);\n                iVar5 = extraout_r1_30;\n            }\n        }\n    }\n    if (*(*0xd7cc + 0x464) != 0) {\n        *(iVar28 + -4) = 0;\n        uVar29 = fcn.00015af4(iVar19);\n        iVar5 = uVar29 >> 0x20;\n        iVar20 = uVar29 + 0;\n        if (iVar20 == 0) {\n            sym.imp.printf(*0xd848);\n            fcn.00015b9c(*(iVar28 + -4));\n            sym.imp.fputc(10,**0xda50);\n            iVar5 = extraout_r1_32;\n        }\n    }\n    if (*(*0xd7cc + 0x604) != 0) {\n        *(iVar28 + -400) = 0xe5;\n        *(iVar28 + -399) = 0;\n        *(iVar28 + -0x18e) = 0;\n        *(iVar28 + -0x18d) = 0;\n        iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        if (iVar5 == 0) {\ncode_r0x0000cda0:\n            uVar16 = *(iVar28 + -0x18e);\n            if (uVar16 == 0x41) {\n                uVar7 = *0xd84c;\n            }\n            else if (uVar16 < 0x42) {\n                if (uVar16 == 0) {\n                    uVar7 = *0xd850;\n                }\n                else {\n                    if (uVar16 != 0x40) goto code_r0x0000cde4;\n                    uVar7 = *0xd85c;\n                }\n            }\n            else if (uVar16 == 0x80) {\n                uVar7 = *0xd854;\n            }\n            else {\n                if (uVar16 != 0xff) goto code_r0x0000cde4;\n                uVar7 = *0xd858;\n            }\n        }\n        else {\n            *(iVar28 + -400) = 0x98;\n            iVar5 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n            if (iVar5 == 0) goto code_r0x0000cda0;\n            piVar6 = sym.imp.__errno_location();\n            iVar20 = *piVar6;\ncode_r0x0000cde4:\n            uVar7 = *0xd840;\n        }\n        sym.imp.printf(*0xd860,uVar7);\n        iVar5 = extraout_r1_33;\n    }\n    iVar17 = *0xd7cc;\n    iVar9 = iVar20;\n    if (*(iVar17 + 0x5f4) != 0) {\n        iVar5 = sym.imp.ioctl(iVar19,0x30d);\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar9 = *piVar6;\n            if (iVar9 != -0x2a) {\n                sym.imp.perror(*0xd9cc);\n                iVar5 = extraout_r1_36;\n            }\n            else {\n                sym.imp.puts(*0xd9c8);\n                iVar5 = extraout_r1_35;\n                iVar9 = iVar20;\n            }\n        }\n        else {\n            iVar5 = *(iVar17 + 0x5f8);\n            iVar20 = *0xd864;\n            if (iVar5 == -1) {\n                *(iVar28 + *0xd868) = *(iVar28 + *0xd868) & 0xfeff;\n            }\n            else {\n                *(iVar28 + *0xd868) = iVar5 | 0x100;\n            }\n            sym.imp.memset(iVar28 + -0x90,0,0x40);\n            sym.imp.memset(iVar28 + -0x110,0,0x80);\n            sym.imp.memset(iVar28 + -400,0,0x80);\n            sym.imp.strndup(iVar28 + -0x35a,0x28);\n            uVar7 = fcn.000096ac();\n            sym.imp.strndup(iVar28 + -0x362,8);\n            uVar14 = fcn.000096ac();\n            sym.imp.strndup(iVar28 + -0x37c,0x14);\n            uVar18 = fcn.000096ac();\n            iVar5 = *0xd86c;\n            uVar21 = 0;\n            sym.imp.printf(*0xd870,uVar7,uVar14,uVar18);\n            sym.imp.printf(*0xd874);\n            do {\n                if ((*(iVar28 + iVar20) >> (uVar21 & 0xff) & 1U) != 0) {\n                    sym.imp.printf(*0xd878,*(iVar5 + uVar21 * 4));\n                }\n                uVar21 = uVar21 + 1;\n            } while (uVar21 != 0x10);\n            sym.imp.puts(*0xd87c);\n            uVar1 = *(iVar28 + *0xd884);\n            uVar2 = *(iVar28 + *0xd884 + 4);\n            uVar3 = *(iVar28 + *0xd884 + 10);\n            *(iVar28 + -0x3c8) = *(iVar28 + *0xd880);\n            *(iVar28 + -0x3c4) = *(iVar28 + *0xd888);\n            *(iVar28 + -0x3c0) = *(iVar28 + *0xd88c);\n            sym.imp.printf(*0xd890,uVar1,uVar2,uVar3);\n            uVar21 = *(iVar28 + *0xd894);\n            uVar7 = *0xd89c;\n            if (uVar21 < 4) {\n                uVar21 = *(*0xda38 + uVar21 * 4 + 0x68);\n                uVar7 = *0xd8a0;\n            }\n            sym.imp.printf(uVar7,*0xd898,uVar21);\n            if (*(iVar28 + *0xd8a4) + -1 < 0xfffe) {\n                sym.imp.printf(*0xd8a8,*(iVar28 + *0xd8a4) >> 1);\n            }\n            else {\n                sym.imp.printf(*0xd8ac);\n            }\n            iVar5 = *0xd8b0;\n            sym.imp.printf(*0xd8b4,*(iVar28 + iVar5));\n            if (*(iVar28 + iVar5) != '\\0') {\n                sym.imp.printf(*0xd8b8);\n                if ((*(iVar28 + *0xd868) & 0x100) == 0) {\n                    uVar7 = *0xd8bc;\n                }\n                else {\n                    if ((*(iVar28 + *0xd868) & 0xff) == 0) {\n                        sym.imp.printf(*0xd9e8);\n                        goto code_r0x0000d028;\n                    }\n                    uVar7 = *0xd810;\n                }\n                sym.imp.printf(uVar7);\n            }\ncode_r0x0000d028:\n            sym.imp.fputc(10,**0xda50);\n            uVar8 = *(iVar28 + *0xd8c0) >> 8;\n            if (uVar8 < 6) {\n                iVar5 = iVar28 + -0x90;\n                sym.imp.strcat(iVar5,*0xd8c4);\n                if ((uVar8 != 0) && (sym.imp.strcat(iVar5,*0xd8c8), uVar8 != 1)) {\n                    sym.imp.strcat(iVar5,*0xd8cc);\n                }\n            }\n            if ((*(iVar28 + *0xd8d0) & 1) == 0) {\n                sym.imp.printf(*0xd8d4);\n            }\n            iVar5 = *0xd8dc;\n            uVar1 = *(iVar28 + *0xd8d8);\n            uVar2 = *(iVar28 + *0xd8d8 + 2);\n            uVar3 = *(iVar28 + *0xd8d8 + 4);\n            *(iVar28 + -0x3c8) = CONCAT22(*(iVar28 + *0xd8e0),*(iVar28 + *0xd8e0 + -2));\n            sym.imp.printf(*0xd8e4,uVar1,uVar2,uVar3);\n            uVar7 = *0xd8e8;\n            if ((*(iVar28 + iVar5) & 0x200) == 0) {\n                uVar7 = *0xd8f0;\n            }\n            sym.imp.printf(*0xd8ec,uVar7);\n            if ((*(iVar28 + iVar5) & 0x200) != 0) {\n                uVar29 = fcn.00009280(iVar28 + -0x390);\n                uVar7 = uVar29 >> 0x20;\n                sym.imp.printf(*0xd8f4,uVar7,uVar29,uVar7);\n            }\n            if ((*(iVar28 + *0xd8dc) & 0x100) != 0) {\n                uVar8 = *(iVar28 + *0xd8f8);\n                uVar4 = *(iVar28 + *0xd8f8 + 2);\n                if ((uVar4 | uVar8) != 0) {\n                    if ((uVar8 & 0x100) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar8 & 1) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd900);\n                    }\n                    if ((uVar8 & 0x200) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar8 & 2) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd904);\n                    }\n                    if ((uVar8 & 0x400) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar8 & 4) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd908);\n                    }\n                    if ((uVar8 & 0xf800) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar8 & 0xf8) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd90c);\n                    }\n                    if ((uVar4 & 0x100) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar4 & 1) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd910);\n                    }\n                    if ((uVar4 & 0x200) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar4 & 2) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd914);\n                    }\n                    if ((uVar4 & 0x400) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar4 & 4) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd918);\n                    }\n                    if ((uVar4 & 0xf800) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd8fc);\n                    }\n                    if ((uVar4 & 0xf8) != 0) {\n                        sym.imp.strcat(iVar28 + -0x110,*0xd91c);\n                    }\n                }\n            }\n            sym.imp.printf(*0xd920);\n            if ((*(iVar28 + *0xd8dc) & 0x800) == 0) {\n                uVar7 = *0xd8f0;\n            }\n            else {\n                uVar7 = *0xd8e8;\n                if ((*(iVar28 + *0xd8dc) & 0x400) != 0) {\n                    uVar7 = *0xd924;\n                }\n            }\n            sym.imp.printf(uVar7);\n            if (((*(iVar28 + *0xd8dc) & 0x800) != 0) || ((*(iVar28 + *0xd8d0) & 2) != 0)) {\n                if ((*(iVar28 + *0xd8d0) & 2) != 0) {\n                    sym.imp.printf(*0xd92c,*(iVar28 + *0xd928),*(iVar28 + *0xd928 + 2));\n                    uVar8 = *(iVar28 + *0xd930);\n                    if ((uVar8 & 1) != 0) {\n                        sym.imp.strcat(iVar28 + -0x90,*0xd934);\n                    }\n                    if ((uVar8 & 2) != 0) {\n                        sym.imp.strcat(iVar28 + -0x90,*0xd938);\n                    }\n                    if ((uVar8 & 0xfffc) != 0) {\n                        sym.imp.strcat(iVar28 + -0x90,*0xd93c);\n                    }\n                }\n                if ((*(iVar28 + *0xd8d0) & 4) != 0) {\n                    uVar8 = *(iVar28 + *0xd940);\n                    if ((uVar8 & 0x100) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 1) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd944);\n                    }\n                    if ((uVar8 & 0x200) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 2) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd948);\n                    }\n                    if ((uVar8 & 0x400) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 4) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd94c);\n                    }\n                    if ((uVar8 & 0x800) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 8) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd950);\n                    }\n                    if ((uVar8 & 0x1000) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 0x10) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd954);\n                    }\n                    if ((uVar8 & 0x2000) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 0x20) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd958);\n                    }\n                    if ((uVar8 & 0x4000) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd8fc);\n                    }\n                    if ((uVar8 & 0x40) != 0) {\n                        sym.imp.strcat(iVar28 + -400,*0xd95c);\n                    }\n                }\n            }\n            if (((*(iVar28 + *0xd8dc) & 0x100) != 0) && ((*(iVar28 + *0xd8d0) & 2) != 0)) {\n                sym.imp.printf(*0xd964,*(iVar28 + *0xd960),*(iVar28 + *0xd960 + 2));\n            }\n            sym.imp.printf(*0xd968,iVar28 + -0x90);\n            if (*(iVar28 + -0x110) != '\\0') {\n                sym.imp.printf(*0xd96c,iVar28 + -0x110);\n            }\n            if (*(iVar28 + -400) != '\\0') {\n                sym.imp.printf(*0xd970,iVar28 + -400);\n            }\n            iVar5 = *0xd974;\n            uVar7 = *0xd8e8;\n            if ((*(iVar28 + iVar5) & 8) == 0) {\n                uVar7 = *0xd8f0;\n            }\n            sym.imp.printf(*0xd978,uVar7);\n            if ((*(iVar28 + iVar5) & 8) != 0) {\n                if ((*(iVar28 + *0xd97c) & 8) == 0) {\n                    uVar7 = *0xd980;\n                }\n                else {\n                    if ((*(iVar28 + *0xd984) & 0xff00) == 0x4000) {\n                        uVar8 = *(iVar28 + *0xd984) & 0xff;\n                        sym.imp.printf(*0xd98c,uVar8,uVar8);\n                        goto code_r0x0000d594;\n                    }\n                    uVar7 = *0xd988;\n                }\n                sym.imp.printf(uVar7);\n            }\ncode_r0x0000d594:\n            if ((*(iVar28 + *0xd990) & 0x20) != 0) {\n                uVar7 = *0xd998;\n                if ((*(iVar28 + *0xd994) & 0x20) != 0) {\n                    uVar7 = *0xd9a0;\n                }\n                sym.imp.printf(*0xd99c,uVar7);\n            }\n            uVar21 = *(iVar28 + *0xd9a4);\n            if ((uVar21 != 0) || (*(iVar28 + uVar21 + -0x2f0) != 0)) {\n                sym.imp.printf(*0xd9a8);\n                if (*(iVar28 + *0xd9a4) < 0x20) {\n                    sym.imp.printf(*0xd9b0,*(*0xd9ac + *(iVar28 + *0xd9a4) * 4));\n                }\n                else {\n                    sym.imp.printf(*0xd9b4);\n                }\n                iVar5 = *0xd9b8;\n                if (*(iVar28 + iVar5) + -1 < 0xfffe) {\n                    uVar7 = *0xd9bc;\n                    iVar20 = 0;\n                    uVar14 = *0xd9c0;\n                    uVar21 = 0;\n                    do {\n                        if ((*(iVar28 + iVar5) >> (uVar21 & 0xff) & 1U) != 0) {\n                            bVar25 = iVar20 != 0;\n                            iVar20 = iVar20 + 1;\n                            uVar18 = uVar7;\n                            if (bVar25) {\n                                uVar18 = uVar14;\n                            }\n                            sym.imp.printf(*0xd89c,uVar18,uVar21);\n                        }\n                        uVar21 = uVar21 + 1;\n                    } while (uVar21 != 8);\n                }\n            }\n            sym.imp.putchar(10);\n            sym.imp.puts(*0xd9c4);\n            sym.imp.putchar(10);\n            iVar5 = extraout_r1_34;\n        }\n    }\n    iVar20 = *0xd7cc;\n    if ((*(iVar20 + 0x608) != 0) && (fcn.00009a24(iVar19), iVar5 = extraout_r1_37, *(iVar20 + 0x38) != 0)) {\n        if (*(iVar20 + 0x608) != 2) {\n            fcn.0000fc28();\n            iVar5 = extraout_r1_39;\n        }\n        else {\n            fcn.0000a3c8();\n            iVar5 = extraout_r1_38;\n        }\n    }\n    iVar20 = *0xd7cc;\n    if (*(iVar20 + 0x524) != 0) {\n        fcn.00009a24(iVar19);\n        iVar17 = *(iVar20 + 0x38);\n        iVar5 = extraout_r1_40;\n        if (iVar17 != 0) {\n            if ((*(iVar17 + 0xa4) & 0x40) == 0) {\n                sym.imp.puts(*0xd9d4);\n                iVar5 = extraout_r1_42;\n            }\n            else {\n                uVar7 = *0xd9d0;\n                *(iVar20 + 0x520) = (*(iVar17 + 0xaa) << -6 + 0x1f) >> 0 + 0x1f;\n                sym.imp.printf(uVar7);\n                fcn.000099a8(*(iVar20 + 0x520));\n                iVar5 = extraout_r1_41;\n            }\n        }\n    }\n    iVar20 = *0xd7cc;\n    if (*(iVar20 + 0x568) != 0) {\n        fcn.00009a24(iVar19);\n        iVar17 = *(iVar20 + 0x38);\n        iVar5 = extraout_r1_43;\n        if (iVar17 != 0) {\n            if ((*(iVar17 + 0xa4) & 0x20) == 0) {\n                sym.imp.puts(*0xd9dc);\n                iVar5 = extraout_r1_45;\n            }\n            else {\n                uVar7 = *0xd9d8;\n                *(iVar20 + 0x56c) = (*(iVar17 + 0xaa) << -5 + 0x1f) >> 0 + 0x1f;\n                sym.imp.printf(uVar7);\n                fcn.000099a8(*(iVar20 + 0x56c));\n                iVar5 = extraout_r1_44;\n            }\n        }\n    }\n    iVar20 = *0xdaa0;\n    if ((*(iVar20 + 0x538) != 0) && (fcn.00009a24(iVar19), iVar5 = extraout_r1_46, *(iVar20 + 0x38) != 0)) {\n        sym.imp.printf(*0xd9e0);\n        iVar5 = *(iVar20 + 0x38);\n        if ((*(iVar5 + 0xa6) & 0xc008) != 0x4008) {\n            uVar7 = *0xd9e4;\n        }\n        else {\n            if ((*(iVar5 + 0xac) & 8) != 0) {\n                sym.imp.printf(*0xd9ec,*(iVar5 + 0xb6));\n                iVar5 = extraout_r1_47;\n                goto code_r0x0000db24;\n            }\n            uVar7 = *0xd9e8;\n        }\n        sym.imp.puts(uVar7);\n        iVar5 = extraout_r1_48;\n    }\ncode_r0x0000db24:\n    iVar20 = *0xdaa0;\n    if (*(iVar20 + 0x550) != 0) {\n        fcn.00009a24(iVar19);\n        iVar20 = *(iVar20 + 0x38);\n        iVar5 = extraout_r1_49;\n        if (iVar20 != 0) {\n            if ((*(iVar20 + 0xa6) & 0x200) == 0) {\n                sym.imp.puts(*0xd9f4);\n                iVar5 = extraout_r1_51;\n            }\n            else {\n                sym.imp.printf(*0xd9f0,*(iVar20 + 0xbc));\n                iVar5 = extraout_r1_50;\n            }\n        }\n    }\n    iVar20 = *0xdaa0;\n    if (*(iVar20 + 0x55c) != 0) {\n        fcn.00009a24(iVar19);\n        iVar20 = *(iVar20 + 0x38);\n        iVar5 = extraout_r1_52;\n        if (iVar20 != 0) {\n            if ((*(iVar20 + 0xee) & 2) == 0) {\n                sym.imp.puts(*0xd9fc);\n                iVar5 = extraout_r1_54;\n            }\n            else {\n                sym.imp.printf(*0xd9f8,*(iVar20 + 0xf0) & 2);\n                iVar5 = extraout_r1_53;\n            }\n        }\n    }\n    iVar20 = *0xdaa0;\n    if (*(iVar20 + 0x5a8) != 0) {\n        iVar5 = sym.imp.ioctl(iVar19,0x31a);\n        if (iVar5 == 0) {\n            uVar10 = *(iVar20 + 0x5fc);\n            uVar21 = uVar10;\n            if (2 < uVar10) {\n                uVar21 = 3;\n            }\n            sym.imp.printf(*0xda0c,uVar10,*(*0xda08 + uVar21 * 4 + 0x11c));\n            iVar5 = extraout_r1_56;\n        }\n        else {\n            piVar6 = sym.imp.__errno_location();\n            iVar9 = *piVar6;\n            sym.imp.perror(*0xda04);\n            iVar5 = extraout_r1_55;\n        }\n    }\n    iVar20 = *0xdaa0;\n    if ((*(iVar20 + 0x5b4) != 0) && (fcn.00009a24(iVar19), iVar5 = extraout_r1_57, *(iVar20 + 0x38) != 0)) {\n        uVar29 = fcn.00009280();\n        uVar22 = uVar29 >> 0x20;\n        uVar21 = uVar29;\n        uVar29 = fcn.00009bd4(iVar19);\n        uVar11 = uVar29 >> 0x20;\n        uVar10 = uVar29;\n        uVar12 = uVar10 | uVar11;\n        if (uVar12 != 0) {\n            *(iVar28 + -0x3c8) = uVar10;\n            *(iVar28 + -0x3c4) = uVar11;\n            sym.imp.printf(*0xda10,uVar12,uVar21,uVar22);\n            if ((uVar22 <= uVar11 && uVar11 != uVar22) || ((uVar11 == uVar22 && (uVar21 <= uVar10 && uVar10 != uVar21)))\n               ) {\n                uVar7 = *0xda14;\n            }\n            else {\n                if ((uVar21 != uVar10) || (uVar22 != uVar11)) {\n                    uVar29 = fcn.00009ad8(iVar19,1);\n                    iVar5 = uVar29;\n                    if (iVar5 != 0) {\n                        uVar21 = *(iVar5 + 8) << 0x10;\n                        uVar22 = *(iVar5 + 6) | uVar21;\n                        sym.imp.printf(*0xda1c,uVar29 >> 0x20,uVar22 + 1,\n                                       (*(iVar5 + 10) | uVar21 >> 0x1f) + (0xfffffffe < uVar22));\n                    }\n                    sym.imp.printf(*0xda20);\n                    if ((uVar10 & 0xff000000 | uVar11 & 0xffff) == 0) {\n                        sym.imp.printf(*0xda24);\n                    }\n                    sym.imp.fputc(10,**0xda50);\n                    iVar5 = extraout_r1_59;\n                    goto code_r0x0000dd3c;\n                }\n                uVar7 = *0xda18;\n            }\n            sym.imp.puts(uVar7);\n            iVar5 = extraout_r1_58;\n        }\n        else {\n            uVar29 = sym.imp.__errno_location();\n            iVar5 = uVar29 >> 0x20;\n            iVar9 = *uVar29;\n        }\n    }\ncode_r0x0000dd3c:\n    if (*(*0xdaa0 + 0x60c) != 0) {\n        uVar29 = fcn.0000a31c();\n        iVar5 = uVar29 >> 0x20;\n        iVar20 = uVar29 + 0;\n        if (iVar20 != 0) {\n            uVar7 = (*0xda28)[1];\n            uVar14 = (*0xda28)[2];\n            uVar18 = (*0xda28)[3];\n            *(iVar28 + -0x30) = **0xda28;\n            *(iVar28 + -0x2c) = uVar7;\n            *(iVar28 + -0x28) = uVar14;\n            *(iVar28 + -0x24) = uVar18;\n            sym.imp.setitimer(0,iVar28 + -0x30,0);\n            uVar29 = fcn.00009ff8(iVar19);\n            iVar5 = uVar29 >> 0x20;\n            if (uVar29 == 0) {\n                uVar29 = fcn.00009f5c(iVar19,iVar20);\n                iVar5 = uVar29 >> 0x20;\n                iVar17 = uVar29 + 0;\n                if (iVar17 == 0) {\n                    uVar7 = *0xda2c;\n                    if ((*(*0xda38 + 4) & 0x10000) != 0) {\n                        uVar7 = *0xda34;\n                    }\n                    sym.imp.printf(*0xda30,uVar7);\n                    sym.imp.fflush(**0xda50);\n                    fcn.0000a024(iVar19);\n                    sym.imp.sleep(1);\n                    sym.imp.getitimer(iVar17,iVar28 + -400);\n                    do {\n                        iVar5 = fcn.00009ff8(iVar19);\n                        if (iVar5 != 0) goto code_r0x0000df90;\n                        iVar5 = fcn.00009f5c(iVar19,iVar20);\n                        if (iVar5 + 0 != 0) goto code_r0x0000df90;\n                        iVar17 = iVar17 + 1;\n                        sym.imp.getitimer(iVar5,iVar28 + -0x40);\n                        uVar29 = fcn.00016030(*(iVar28 + -0x188) - *(iVar28 + -0x38));\n                        *(iVar28 + -0x3b8) = uVar29;\n                        uVar29 = fcn.00016030(*(iVar28 + -0x184) - *(iVar28 + -0x34));\n                        uVar29 = fcn.00016378(uVar29,uVar29 >> 0x20,0,*0xda5c);\n                        uVar29 = fcn.00015d60(*(iVar28 + -0x3b8),*(iVar28 + -0x3b4),uVar29,uVar29 >> 0x20);\n                        *(iVar28 + -0x3b8) = uVar29;\n                        iVar23 = fcn.00016658(uVar29,uVar29 >> 0x20,0,0x40000000);\n                    } while (iVar23 != 0);\n                    sym.imp.getitimer(iVar5 + 0,iVar28 + -400);\n                    iVar5 = iVar17;\n                    do {\n                        iVar23 = fcn.00009ff8(iVar19);\n                        if (iVar23 != 0) goto code_r0x0000df90;\n                        sym.imp.getitimer(iVar23,iVar28 + -0x40);\n                        uVar29 = fcn.00016030(*(iVar28 + -0x188) - *(iVar28 + -0x38));\n                        uVar31 = fcn.00016030(*(iVar28 + -0x184) - *(iVar28 + -0x34));\n                        uVar31 = fcn.00016378(uVar31,uVar31 >> 0x20,0,*0xda5c);\n                        uVar29 = fcn.00015d60(uVar29,uVar29 >> 0x20,uVar31,uVar31 >> 0x20);\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                    uVar29 = fcn.00015d5c(*(iVar28 + -0x3b8),*(iVar28 + -0x3b4),uVar29,uVar29 >> 0x20);\n                    uVar18 = uVar29 >> 0x20;\n                    uVar7 = uVar29;\n                    uVar29 = fcn.0001600c(iVar17 * 2);\n                    uVar13 = uVar29 >> 0x20;\n                    uVar14 = uVar29;\n                    iVar5 = fcn.00016680(uVar14,uVar13,uVar7,uVar18);\n                    if (iVar5 == 0) {\n                        uVar29 = fcn.00016378(uVar14,uVar13,uVar7,uVar18);\n                        uVar29 = fcn.0001610c(uVar29,uVar29 >> 0x20,0,*0xda6c);\n                        *(iVar28 + -0x3c8) = uVar29;\n                        uVar14 = *0xda70;\n                    }\n                    else {\n                        uVar29 = fcn.00016378(uVar14,uVar13,uVar7,uVar18);\n                        *(iVar28 + -0x3c8) = uVar29;\n                        uVar14 = *0xda68;\n                    }\n                    sym.imp.printf(uVar14,iVar17 * 2,uVar7,uVar18);\n                    fcn.0000a024(iVar19);\n                    sym.imp.sleep(1);\ncode_r0x0000df90:\n                    sym.imp.munlockall();\n                    sym.imp.munmap(iVar20,0x200000);\n                    iVar5 = extraout_r1_60;\n                }\n            }\n        }\n    }\n    uVar29 = CONCAT44(iVar5,iVar9);\n    if (*(*0xdaa0 + 0x610) != 0) {\n        uVar29 = fcn.00009b54(iVar19);\n    }\n    if (*(*0xdaa0 + 0x614) != 0) {\n        *(*0xdaa0 + 0x618) = 1;\n        *(iVar28 + -0x3c4) = iVar28 + -0x20;\n        *(iVar28 + -0x3c8) = 0;\n        iVar5 = fcn.0001402c(iVar19,0,0);\n        iVar5 = iVar5 + 0;\n        if (iVar5 == 0) {\n            uVar21 = *(iVar28 + -0x20) >> 0xc | *(iVar28 + -0x1c) << 0x14;\n        }\n        else {\n            uVar21 = 0x400;\n        }\n        iVar20 = fcn.0000a31c();\n        iVar20 = iVar20 + 0;\n        if (iVar20 == 0) {\n            iVar5 = 0xc;\n        }\n        else if (iVar5 == 0) {\n            uVar7 = *0xda3c;\n            if ((*(*0xda38 + 4) & 0x10000) != 0) {\n                uVar7 = *0xda44;\n            }\n            sym.imp.printf(*0xda40,uVar7);\n            if (*(*0xdaa0 + 0x61c) != 0) {\n                sym.imp.printf(*0xda48,extraout_r1_61,*(*0xdaa0 + 0x620) >> 0x1e | *(*0xdaa0 + 0x624) << 2,\n                               *(*0xdaa0 + 0x624) >> 0x1e);\n            }\n            sym.imp.printf(*0xda4c);\n            sym.imp.fflush(**0xda50);\n            if (*(*0xdaa0 + 0x61c) != 0) {\n                uVar7 = *(*0xdaa0 + 0x620);\n                uVar14 = *(*0xdaa0 + 0x624);\n                *(iVar28 + -0x3c8) = 0;\n                uVar29 = sym.imp.lseek64(iVar19,0,uVar7,uVar14);\n                if ((uVar29 == -1) && (uVar29 >> 0x20 == -1)) {\n                    piVar6 = sym.imp.__errno_location();\n                    iVar5 = *piVar6;\n                    sym.imp.perror(*0xda54);\n                    goto code_r0x0000e210;\n                }\n            }\n            uVar10 = 0;\n            uVar7 = (*0xda58)[1];\n            uVar14 = (*0xda58)[2];\n            uVar18 = (*0xda58)[3];\n            *(iVar28 + -0x50) = **0xda58;\n            *(iVar28 + -0x4c) = uVar7;\n            *(iVar28 + -0x48) = uVar14;\n            *(iVar28 + -0x44) = uVar18;\n            sym.imp.setitimer(0,iVar28 + -0x50,0);\n            sym.imp.getitimer(0,iVar28 + -0x40);\n            do {\n                iVar9 = fcn.00009f5c(iVar19,iVar20);\n                if (iVar9 + 0 != 0) {\n                    goto code_r0x0000e210;\n                }\n                uVar10 = uVar10 + 1;\n                sym.imp.getitimer(iVar9,iVar28 + -400);\n                uVar29 = fcn.00016030(*(iVar28 + -0x38) - *(iVar28 + -0x188));\n                *(iVar28 + -0x3b8) = uVar29;\n                uVar29 = fcn.00016030(*(iVar28 + -0x34) - *(iVar28 + -0x184));\n                uVar29 = fcn.00016378(uVar29,uVar29 >> 0x20,0,*0xda5c);\n                uVar29 = fcn.00015d60(*(iVar28 + -0x3b8),*(iVar28 + -0x3b4),uVar29,uVar29 >> 0x20);\n                *(iVar28 + -0x3b8) = uVar29;\n                iVar17 = fcn.00016658(uVar29,uVar29 >> 0x20,0,*0xda60);\n                uVar22 = 1;\n                if (iVar17 == 0) {\n                    uVar22 = iVar9 + 0;\n                }\n            } while ((!(uVar21 <= uVar10) & uVar22) != 0);\n            uVar29 = fcn.0001600c(uVar10 * 2);\n            uVar29 = fcn.00016378(uVar29,uVar29 >> 0x20,*(iVar28 + -0x3b8),*(iVar28 + -0x3b4));\n            uVar14 = uVar29 >> 0x20;\n            uVar7 = uVar29;\n            iVar9 = fcn.00016694(uVar7,uVar14,0,*0xda64);\n            if (iVar9 != 0) {\n                *(iVar28 + -0x3c8) = uVar7;\n                *(iVar28 + -0x3c4) = uVar14;\n                uVar7 = *0xda68;\n            }\n            else {\n                uVar29 = fcn.0001610c(uVar7,uVar14,0,*0xda6c);\n                *(iVar28 + -0x3c8) = uVar29;\n                uVar7 = *0xda70;\n            }\n            sym.imp.printf(uVar7,uVar10 * 2,*(iVar28 + -0x3b8),*(iVar28 + -0x3b4));\n        }\ncode_r0x0000e210:\n        sym.imp.munlockall();\n        uVar29 = CONCAT44(extraout_r1_62,iVar5);\n        if (iVar20 != 0) {\n            sym.imp.munmap(iVar20,0x200000);\n            uVar29 = CONCAT44(extraout_r1_63,iVar5);\n        }\n    }\n    uVar7 = uVar29 >> 0x20;\n    iVar5 = uVar29;\n    if (*(*0xdaa0 + 0x618) != 0) {\n        fcn.0000a024(iVar19);\n        uVar7 = extraout_r1_64;\n    }\n    if (*(*0xdaa0 + 0x628) != 0) {\n        if (*(*0xdaa0 + 0x62c) != 0) {\n            sym.imp.puts(*0xda74);\n        }\n        uVar29 = sym.imp.ioctl(iVar19,0x125f,0);\n        uVar7 = uVar29 >> 0x20;\n        if (uVar29 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            sym.imp.perror(*0xda78);\n            uVar7 = extraout_r1_65;\n        }\n    }\n    if (*(*0xdaa0 + 0x630) != 0) {\n        *(iVar28 + -400) = 0xe1;\n        uVar15 = 0;\n        *(iVar28 + -399) = uVar15;\n        *(iVar28 + -0x18e) = uVar15;\n        *(iVar28 + -0x18d) = uVar15;\n        if (*(*0xdaa0 + 0x634) != 0) {\n            sym.imp.puts(*0xda7c);\n        }\n        uVar29 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        uVar7 = uVar29 >> 0x20;\n        if (uVar29 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            sym.imp.perror(*0xda80);\n            uVar7 = extraout_r1_66;\n        }\n    }\n    if (*(*0xdaa0 + 0x638) != 0) {\n        *(iVar28 + -400) = 0xe0;\n        uVar15 = 0;\n        *(iVar28 + -399) = uVar15;\n        *(iVar28 + -0x18e) = uVar15;\n        *(iVar28 + -0x18d) = uVar15;\n        *(iVar28 + -0x3f) = uVar15;\n        *(iVar28 + -0x3e) = uVar15;\n        *(iVar28 + -0x3d) = uVar15;\n        iVar20 = *(*0xdaa0 + 0x63c);\n        *(iVar28 + -0x40) = 0x94;\n        if (iVar20 != 0) {\n            sym.imp.puts(*0xda84);\n        }\n        uVar29 = fcn.00012ed0(iVar19,iVar28 + -400,0);\n        uVar7 = uVar29 >> 0x20;\n        if (uVar29 != 0) {\n            uVar29 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n            uVar7 = uVar29 >> 0x20;\n            if (uVar29 != 0) {\n                piVar6 = sym.imp.__errno_location();\n                iVar5 = *piVar6;\n                sym.imp.perror(*0xda88);\n                uVar7 = extraout_r1_67;\n            }\n        }\n    }\n    if (*(*0xdaa0 + 0x640) != 0) {\n        if (*(*0xdaa0 + 0x644) != 0) {\n            sym.imp.puts(*0xda8c);\n            uVar7 = extraout_r1_68;\n        }\n        *(iVar28 + -0x3c4) = 0;\n        *(iVar28 + -0x3c8) = *(iVar28 + -0x3ac);\n        fcn.00009db8(iVar19,uVar7,0,0);\n        *(iVar28 + -0x3c0) = 0;\n        *(iVar28 + -0x3c8) = *0xda90;\n        *(iVar28 + -0x3c4) = 0;\n        *(iVar28 + -0x3bc) = 0;\n        fcn.00013780(iVar28 + -0x110,0xe1,0,0);\n        *(iVar28 + -0x100) = *(iVar28 + -0x100) | 2;\n        *(iVar28 + -0x10f) = 0x44;\n        iVar5 = fcn.0001303c(iVar19,iVar28 + -0x110,0);\n        iVar5 = iVar5 + 0;\n        if (iVar5 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            sym.imp.perror(*0xda94);\n        }\n    }\n    if (*(*0xdaa0 + 0x648) != 0) {\n        *(iVar28 + -0x40) = 0xe6;\n        uVar15 = 0;\n        *(iVar28 + -0x3f) = uVar15;\n        *(iVar28 + -0x3e) = uVar15;\n        *(iVar28 + -0x3d) = uVar15;\n        *(iVar28 + -399) = uVar15;\n        *(iVar28 + -0x18e) = uVar15;\n        *(iVar28 + -0x18d) = uVar15;\n        iVar20 = *(*0xdaa0 + 0x64c);\n        *(iVar28 + -400) = 0x99;\n        if (iVar20 != 0) {\n            sym.imp.puts(*0xda98);\n        }\n        iVar20 = fcn.00012ed0(iVar19,iVar28 + -0x40,0);\n        if ((iVar20 != 0) && (iVar28 = fcn.00012ed0(iVar19,iVar28 + -400,0), iVar28 != 0)) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            sym.imp.perror(*0xda9c);\n        }\n    }\n    if (*(*0xdaa0 + 0x650) != 0) {\n        if (*(*0xdaa0 + 0x654) != 0) {\n            sym.imp.puts(*0xdaa4);\n        }\n        iVar28 = sym.imp.ioctl(iVar19,0x31c,0);\n        if (iVar28 != 0) {\n            piVar6 = sym.imp.__errno_location();\n            iVar5 = *piVar6;\n            sym.imp.perror(*0xdaa8);\n        }\n    }\n    sym.imp.close(iVar19);\n    if (iVar5 == 0) {\n        return;\n    }\ncode_r0x0000a6b8:\n    //WARNING: Subroutine does not return\n    sym.imp.exit(iVar5);\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to find references to the 'PASSWD too long' string to identify where password length checks are performed. This could lead to a buffer overflow if the check is inadequate or bypassed. I'll use the 'axt' command in Radare2 to find cross-references to this string address.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"axt 0x17cdd\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"axt 0x17cdd\"}\n结果：\n fcn.000098ac 0x9910 [DATA:r--] ldr r1, str.PASSWD_too_long__must_be__d_chars_max__n", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I found a cross-reference to the 'PASSWD too long' string in function fcn.000098ac. This function likely handles password length validation. I need to decompile it to understand the logic and identify any potential vulnerabilities, such as buffer overflows if the length check is insufficient or can be bypassed. I'll use 'pdg' to decompile this function.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ fcn.000098ac\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ fcn.000098ac\"}\n结果：\n void fcn.000098ac(int32_t param_1)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    uint unaff_r4;\n    int32_t iVar5;\n    uint unaff_r5;\n    uint unaff_r6;\n    int32_t iVar6;\n    uint in_lr;\n    uint *puVar7;\n    uint auStack_10 [4];\n    \n    *(*0x54 + -4) = in_lr;\n    puVar7 = *0x54 + -4 + -4;\n    *puVar7 = unaff_r6;\n    puVar7 = puVar7 + -4;\n    *puVar7 = unaff_r5;\n    *(puVar7 + -4) = unaff_r4;\n    iVar6 = *0x998c;\n    iVar3 = *(iVar6 + 0xc);\n    if (iVar3 != 1 && iVar3 + -1 < 0 == SBORROW4(iVar3,1)) {\n        iVar5 = **(iVar6 + 0x10);\n        *(iVar6 + 0xc) = iVar3 + -1;\n        *(iVar6 + 8) = iVar5;\n        *(iVar6 + 0x10) = *(iVar6 + 0x10) + 1;\n        if (iVar5 != 0) {\n            uVar2 = sym.imp.strlen(iVar5);\n            if (uVar2 < 0x21) {\n                sym.imp.memset(iVar6 + 0x14,0,0x21);\n                if ((param_1 == 0) || (iVar3 = sym.imp.strcmp(iVar5,*0x999c), iVar3 != 0)) {\n                    sym.imp.strcpy(*0x99a0,iVar5);\n                }\n                iVar3 = *0x998c;\n                sym.imp.printf(*0x99a4,iVar3 + 0x14);\n                pcVar1 = *(iVar3 + 8);\n                do {\n                    pcVar4 = pcVar1;\n                    pcVar1 = pcVar4 + 1;\n                } while (*pcVar4 != '\\0');\n                *(*0x998c + 8) = pcVar4;\n                return;\n            }\n            sym.imp.fprintf(**0x9990,*0x9998,0x20);\n            goto code_r0x0000991c;\n        }\n    }\n    sym.imp.fputs(*0x9994,**0x9990);\ncode_r0x0000991c:\n    //WARNING: Subroutine does not return\n    sym.imp.exit(0x16);\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the function fcn.000098ac, which handles password input for hdparm. The function checks if the password length is less than 0x21 (33 characters) using strlen, and if so, it copies the password using strcpy to a destination pointed to by *0x99a0. However, the destination buffer size is not directly verified in this function. The memset operation clears a buffer at iVar6 + 0x14 with size 0x21, but strcpy uses *0x99a0, which may not be the same buffer. This could lead to a buffer overflow if *0x99a0 points to a buffer smaller than 33 bytes. I need to investigate further to determine if there is an actual exploitable vulnerability. I will check cross-references to address 0x99a0 to see how it is initialized and used.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"axt 0x99a0\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"axt 0x99a0\"}\n结果：\n fcn.000098ac 0x9950 [DATA:r--] ldr r0, [0x000099a0]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to examine the memory at address 0x99a0 to understand what buffer it points to. This will help determine if there's a buffer overflow vulnerability. I'll use the 'px' command in Radare2 to print the memory at that address.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"px 4 @ 0x99a0\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"px 4 @ 0x99a0\"}\n结果：\n - offset -  A0A1 A2A3 A4A5 A6A7 A8A9 AAAB ACAD AEAF  0123456789ABCDEF\n0x000099a0  5c66 0200                                \\f..", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I need to examine the memory at address 0x0002665c to understand the buffer that is being used for the password copy. This will help determine if there's a buffer overflow vulnerability. I'll use the 'px' command to view the memory at that address and see if it's part of a larger structure or if its size can be inferred.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"px 64 @ 0x0002665c\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"px 64 @ 0x0002665c\"}\n结果：\n - offset -  5C5D 5E5F 6061 6263 6465 6667 6869 6A6B  CDEF0123456789AB\n0x0002665c  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x0002666c  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x0002667c  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x0002668c  0000 0000 0000 0000 0000 0000 0000 0000  ................", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have identified a potential buffer overflow vulnerability in the hdparm binary related to password handling. The function fcn.000098ac processes password input from command-line arguments. It checks that the password length is less than 0x21 (33 characters) using strlen, but then uses strcpy to copy the password to a buffer pointed to by *0x99a0. The destination buffer at *0x99a0 (address 0x0002665c) may be smaller than 33 bytes, as evidenced by the memset of a different buffer (iVar6 + 0x14) with size 0x21. Since strcpy does not check bounds, a password of exactly 32 characters could overflow the destination buffer if it is smaller, leading to memory corruption. However, to confirm exploitability, I need to trace the data flow to see if this can be leveraged for code execution. The function is part of the security command handling, such as --security-set-pass, which is dangerous and could be triggered by an attacker. But without evidence of a specific buffer size and control over adjacent memory, I cannot confirm a full attack chain. Thus, this finding has moderate risk but requires more evidence for high confidence.\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": [\n      {\n        \"description\": \"A potential buffer overflow exists in the password handling function of hdparm. The function fcn.000098ac checks password length using strlen (max 32 characters) but uses strcpy to copy the password to a buffer at *0x99a0 (address 0x0002665c). The destination buffer size is not verified, and if it is smaller than 33 bytes, a buffer overflow can occur. This function is called when processing security commands like --security-set-pass, allowing an attacker to supply a long password via command-line arguments. The use of strcpy without bounds checking is dangerous, but the exact buffer size and controllability of adjacent memory are not confirmed from current analysis. This could lead to memory corruption and potential code execution if exploited.\",\n        \"link_identifiers\": [\"--security-set-pass\", \"PASSWD\"],\n        \"location\": \"fcn.000098ac at address 0x000098ac\",\n        \"code_snippet\": \"uVar2 = sym.imp.strlen(iVar5);\\nif (uVar2 < 0x21) {\\n    sym.imp.memset(iVar6 + 0x14, 0, 0x21);\\n    if ((param_1 == 0) || (iVar3 = sym.imp.strcmp(iVar5, *0x999c), iVar3 != 0)) {\\n        sym.imp.strcpy(*0x99a0, iVar5);\\n    }\",\n        \"risk_score\": 6.5,\n        \"confidence\": 7.0,\n        \"notes\": \"The vulnerability is in a dangerous command (security password set), but the exploitability depends on the actual buffer size at *0x99a0. Further analysis is needed to determine if the overflow can overwrite critical data or return addresses. The function is called from the main command processing logic, so input is controllable via command-line.\"\n      }\n    ]\n  },\n  \"status\": \"complete\"\n}"}
