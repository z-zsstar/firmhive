{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（wifi）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 'wifi' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 助手可以与文件交互以执行特定的文件分析任务。使用场景：当你需要单步任务的分析结果后再决定下一个分析任务时。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n- Name: ParallelTaskDelegator\n  Description: 每个助手可以与文件交互，并行执行多个文件分析子任务。使用场景：1. 当复杂任务需要分解为多个独立的子任务时。2. 子任务之间没有严格的执行顺序依赖。3. 建议对大规模和复杂任务并行执行多个子任务，提高分析效率。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"description\": \"要执行的子任务的详细描述。每个任务描述都是独立的，应指定分析对象。\"\n      },\n      \"description\": \"要分配给子代理并行执行的独立任务描述列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前任务：\n专注于分析文件 'qcawifi.sh' 的内容，寻找可利用的信息和线索。"}
{"role": "assistant", "content": "{\n  \"thought\": \"我需要先获取 'qcawifi.sh' 文件的内容以进行分析。使用 execute_shell 工具来读取文件内容，然后基于证据识别潜在的输入点、数据流和可利用的漏洞链。\",\n  \"action\": \"execute_shell\",\n  \"action_input\": {\n    \"command\": \"cat qcawifi.sh\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：execute_shell\n参数：{\"command\": \"cat qcawifi.sh\"}\n结果：\n 退出代码：0\n标准输出：\n#!/bin/sh\n#\n# Copyright (c) 2014, The Linux Foundation. All rights reserved.\n#\n#  Permission to use, copy, modify, and/or distribute this software for any\n#  purpose with or without fee is hereby granted, provided that the above\n#  copyright notice and this permission notice appear in all copies.\n#\n#  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n#  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n#  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n#  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n#  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n#  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n#  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n#\n\nappend DRIVERS \"qcawifi\"\n\nfind_qca_wifi_dir() {\n    if [ `find /etc/modules.d/ -type f -name \"33-qca-wifi*\" | wc -l` -ge 1 ]; then\n        eval export -- \"${1}=/etc/modules.d\"\n    else\n        eval export -- \"${1}=/lib/wifi\"\n    fi\n}\n\nreload_time_qcawifi() {\n\tlocal devices=\"$2\"\n\tlocal wifi_reload_time=14\n\tlocal wifi_reload_vap_time=2\n\tlocal module_reload_time=16\n\tlocal module_reload=$(uci_get wireless qcawifi module_reload 1)\n\n\ttest \"$module_reload\" = \"1\" && wifi_reload_time=$(( $wifi_reload_time + $module_reload_time ))\n\tfor device in ${devices}; do\n\t\tconfig_get vifs \"$device\" vifs\n\t\tfor vif in $vifs; do\n\t\t\twifi_reload_time=$(( $wifi_reload_time + $wifi_reload_vap_time ))\n\t\tdone\n\tdone\n\teval \"export $1=$wifi_reload_time\"\n}\n\nwlanconfig() {\n\t[ -n \"${DEBUG}\" ] && echo wlanconfig \"$@\"\n\t/usr/sbin/wlanconfig \"$@\"\n}\n\niwconfig() {\n\t[ -n \"${DEBUG}\" ] && echo iwconfig \"$@\"\n\t/usr/sbin/iwconfig \"$@\"\n}\n\niwpriv() {\n\t[ -n \"${DEBUG}\" ] && echo iwpriv \"$@\"\n\t/usr/sbin/iwpriv \"$@\"\n}\n\nfind_qcawifi_phy() {\n\tlocal device=\"$1\"\n\n\tlocal macaddr=\"$(config_get \"$device\" macaddr | tr 'A-Z' 'a-z')\"\n\tconfig_get phy \"$device\" phy\n\t[ -z \"$phy\" -a -n \"$macaddr\" ] && {\n\t\tcd /sys/class/net\n\t\tfor phy in $(ls -d wifi* 2>&-); do\n\t\t\t[ \"$macaddr\" = \"$(cat /sys/class/net/${phy}/address)\" ] || continue\n\t\t\tconfig_set \"$device\" phy \"$phy\"\n\t\t\tbreak\n\t\tdone\n\t\tconfig_get phy \"$device\" phy\n\t}\n\t[ -n \"$phy\" -a -d \"/sys/class/net/$phy\" ] || {\n\t\techo \"phy for wifi device $1 not found\"\n\t\treturn 1\n\t}\n\t[ -z \"$macaddr\" ] && {\n\t\tconfig_set \"$device\" macaddr \"$(cat /sys/class/net/${phy}/address)\"\n\t}\n\treturn 0\n}\n\nscan_qcawifi() {\n\tlocal device=\"$1\"\n\tlocal wds\n\tlocal adhoc sta ap monitor ap_monitor ap_smart_monitor mesh ap_lp_iot disabled\n\n\t[ ${device%[0-9]} = \"wifi\" ] && config_set \"$device\" phy \"$device\"\n\n\tlocal ifidx=0\n\tlocal radioidx=${device#wifi}\n\n\tconfig_get vifs \"$device\" vifs\n\tfor vif in $vifs; do\n\t\tconfig_get_bool disabled \"$vif\" disabled 0\n\t\t[ $disabled = 0 ] || continue\n\n\t\tlocal vifname\n\t\t[ $ifidx -gt 0 ] && vifname=\"ath${radioidx}$ifidx\" || vifname=\"ath${radioidx}\"\n\n\t\tconfig_set \"$vif\" ifname $vifname\n\n\t\tconfig_get mode \"$vif\" mode\n\t\tcase \"$mode\" in\n\t\t\tadhoc|sta|ap|monitor|wrap|ap_monitor|ap_smart_monitor|mesh|ap_lp_iot)\n\t\t\t\tappend \"$mode\" \"$vif\"\n\t\t\t;;\n\t\t\twds)\n\t\t\t\tconfig_get ssid \"$vif\" ssid\n\t\t\t\t[ -z \"$ssid\" ] && continue\n\n\t\t\t\tconfig_set \"$vif\" wds 1\n\t\t\t\tconfig_set \"$vif\" mode sta\n\t\t\t\tmode=\"sta\"\n\t\t\t\taddr=\"$ssid\"\n\t\t\t\t${addr:+append \"$mode\" \"$vif\"}\n\t\t\t;;\n\t\t\t*) echo \"$device($vif): Invalid mode, ignored.\"; continue;;\n\t\tesac\n\n\t\tifidx=$(($ifidx + 1))\n\tdone\n\n\tcase \"${adhoc:+1}:${sta:+1}:${ap:+1}\" in\n\t\t# valid mode combinations\n\t\t1::) wds=\"\";;\n\t\t1::1);;\n\t\t:1:1)config_set \"$device\" nosbeacon 1;; # AP+STA, can't use beacon timers for STA\n\t\t:1:);;\n\t\t::1);;\n\t\t::);;\n\t\t*) echo \"$device: Invalid mode combination in config\"; return 1;;\n\tesac\n\n\tconfig_set \"$device\" vifs \"${ap:+$ap }${ap_monitor:+$ap_monitor }${mesh:+$mesh }${ap_smart_monitor:+$ap_smart_monitor }${wrap:+$wrap }${sta:+$sta }${adhoc:+$adhoc }${wds:+$wds }${monitor:+$monitor}${ap_lp_iot:+$ap_lp_iot}\"\n}\n\n# The country ID is set at the radio level. When the driver attaches the radio,\n# it sets the default country ID to 840 (US STA). This is because the desired\n# VAP modes are not known at radio attach time, and STA functionality is the\n# common unit of 802.11 operation.\n# If the user desires any of the VAPs to be in AP mode, then we set a new\n# default of 843 (US AP with TDWR) from this script. Even if any of the other\n# VAPs are in non-AP modes like STA or Monitor, the stricter default of 843\n# will apply.\n# No action is required here if none of the VAPs are in AP mode.\nset_default_country() {\n\tlocal device=\"$1\"\n\tlocal mode\n\n\tfind_qcawifi_phy \"$device\" || return 1\n\tconfig_get phy \"$device\" phy\n\n\tconfig_get vifs \"$device\" vifs\n\tfor vif in $vifs; do\n\t\tconfig_get_bool disabled \"$vif\" disabled 0\n\t\t[ $disabled = 0 ] || continue\n\n\t\tconfig_get mode \"$vif\" mode\n\t\tcase \"$mode\" in\n\t\t\tap|wrap|ap_monitor|ap_smart_monitor|ap_lp_iot)\n\t\t\t\tiwpriv \"$phy\" setCountryID 843\n\t\t\t\treturn 0;\n\t\t\t;;\n\t\t*) ;;\n\t\tesac\n\tdone\n\n\treturn 0\n}\n\nload_qcawifi() {\n\tlocal umac_args\n\tlocal adf_args\n\techo 3 > /proc/sys/vm/drop_caches\n\n\tconfig_get_bool testmode qcawifi testmode\n\t[ -n \"$testmode\" ] && append umac_args \"testmode=$testmode\"\n\n\tconfig_get vow_config qcawifi vow_config\n\t[ -n \"$vow_config\" ] && append umac_args \"vow_config=$vow_config\"\n\n\tconfig_get ol_bk_min_free qcawifi ol_bk_min_free\n\t[ -n \"$ol_bk_min_free\" ] && append umac_args \"OL_ACBKMinfree=$ol_bk_min_free\"\n\n\tconfig_get ol_be_min_free qcawifi ol_be_min_free\n\t[ -n \"$ol_be_min_free\" ] && append umac_args \"OL_ACBEMinfree=$ol_be_min_free\"\n\n\tconfig_get ol_vi_min_free qcawifi ol_vi_min_free\n\t[ -n \"$ol_vi_min_free\" ] && append umac_args \"OL_ACVIMinfree=$ol_vi_min_free\"\n\n\tconfig_get ol_vo_min_free qcawifi ol_vo_min_free\n\t[ -n \"$ol_vo_min_free\" ] && append umac_args \"OL_ACVOMinfree=$ol_vo_min_free\"\n\n\tconfig_get_bool ar900b_emu qcawifi ar900b_emu\n\t[ -n \"$ar900b_emu\" ] && append umac_args \"ar900b_emu=$ar900b_emu\"\n\n\tconfig_get frac qcawifi frac\n\t[ -n \"$frac\" ] && append umac_args \"frac=$frac\"\n\n\tconfig_get intval qcawifi intval\n\t[ -n \"$intval\" ] && append umac_args \"intval=$intval\"\n\n\tconfig_get atf_mode qcawifi atf_mode\n\t[ -n \"$atf_mode\" ] && append umac_args \"atf_mode=$atf_mode\"\n\n\tconfig_get fw_dump_options qcawifi fw_dump_options\n\t[ -n \"$fw_dump_options\" ] && append umac_args \"fw_dump_options=$fw_dump_options\"\n\n\tconfig_get enableuartprint qcawifi enableuartprint\n\t[ -n \"$enableuartprint\" ] && append umac_args \"enableuartprint=$enableuartprint\"\n\n\tconfig_get ar900b_20_targ_clk qcawifi ar900b_20_targ_clk\n\t[ -n \"$ar900b_20_targ_clk\" ] && append umac_args \"ar900b_20_targ_clk=$ar900b_20_targ_clk\"\n\n\tconfig_get max_descs qcawifi max_descs\n\t[ -n \"$max_descs\" ] && append umac_args \"max_descs=$max_descs\"\n\n\tconfig_get qwrap_enable qcawifi qwrap_enable\n\t[ -n \"$qwrap_enable\" ] && append umac_args \"qwrap_enable=$qwrap_enable\"\n\n\tconfig_get otp_mod_param qcawifi otp_mod_param\n\t[ -n \"$otp_mod_param\" ] && append umac_args \"otp_mod_param=$otp_mod_param\"\n\n\tconfig_get max_active_peers qcawifi max_active_peers\n\t[ -n \"$max_active_peers\" ] && append umac_args \"max_active_peers=$max_active_peers\"\n\n\tconfig_get enable_smart_antenna qcawifi enable_smart_antenna\n\t[ -n \"$enable_smart_antenna\" ] && append umac_args \"enable_smart_antenna=$enable_smart_antenna\"\n\n\tconfig_get wl_tpscale qcawifi wl_tpscale\n\t[ -n \"$wl_tpscale\" ] && append umac_args \"wl_tpscale=$wl_tpscale\"\n\n\tconfig_get wla_tpscale qcawifi wla_tpscale\n\t[ -n \"$wla_tpscale\" ] && append umac_args \"wla_tpscale=$wla_tpscale\"\n\n\tconfig_get nss_wifi_olcfg qcawifi nss_wifi_olcfg\n\t[ -n \"$nss_wifi_olcfg\" ] && append umac_args \"nss_wifi_olcfg=$nss_wifi_olcfg\"\n\n\tconfig_get max_clients qcawifi max_clients\n\t[ -n \"$max_clients\" ] && append umac_args \"max_clients=$max_clients\"\n\n\tconfig_get max_vaps qcawifi max_vaps\n\t[ -n \"$max_vaps\" ] && append umac_args \"max_vaps=$max_vaps\"\n\n\tconfig_get enable_smart_antenna_da qcawifi enable_smart_antenna_da\n\t[ -n \"$enable_smart_antenna_da\" ] && append umac_args \"enable_smart_antenna_da=$enable_smart_antenna_da\"\n\n\tconfig_get prealloc_disabled qcawifi prealloc_disabled\n\t[ -n \"$prealloc_disabled\" ] && append adf_args \"prealloc_disabled=$prealloc_disabled\"\n\n\tif [ -n \"$nss_wifi_olcfg\" ] && [ \"$nss_wifi_olcfg\" != \"0\" ]; then\n\t\tsysctl -w dev.nss.general.extra_pbuf_core0=2936012 >/dev/null 2>/dev/null\n\t\tsysctl dev.nss.n2hcfg.n2h_high_water_core0 >/dev/null 2>/dev/null\n\t\tsysctl dev.nss.n2hcfg.n2h_low_water_core0 >/dev/null 2>/dev/null\n\t\tsysctl -w dev.nss.n2hcfg.n2h_high_water_core0=35840 >/dev/null 2>/dev/null\n\t\tsysctl -w dev.nss.n2hcfg.n2h_low_water_core0=35712 >/dev/null 2>/dev/null\n\tfi\n\n\tregion=`artmtd -r region | grep REGION | cut -d\" \" -f2`\n\t[ \"$region\" = \"US\" ] && append umac_args \"new_fcc_rule=1\"\n\n\tconfig_get specified_BDF qcawifi specified_BDF\n\t[ \"x$specified_BDF\" = \"xPR\" ] && append umac_args \"use_pr_bd=1\"\n\n\tfind_qca_wifi_dir _qca_wifi_dir\n\tfor mod in $(cat ${_qca_wifi_dir}/33-qca-wifi*); do\n\n\t\tcase ${mod} in\n\t\t\tumac) [ -d /sys/module/${mod} ] || { \\\n\n\t\t\t\tinsmod ${mod} ${umac_args} || { \\\n\t\t\t\t\tunload_qcawifi\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t};;\n\n\t\t\tadf) [ -d /sys/module/${mod} ] || { \\\n\t\t\t\tinsmod ${mod} ${adf_args} || { \\\n\t\t\t\t\tunload_qcawifi\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t};;\n\n\t\t\t*) [ -d /sys/module/${mod} ] || { \\\n\t\t\t\tinsmod ${mod} || { \\\n\t\t\t\t\tunload_qcawifi\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t};;\n\n\t\tesac\n\tdone\n}\n\nunload_qcawifi() {\n        find_qca_wifi_dir _qca_wifi_dir\n\tfor mod in $(cat ${_qca_wifi_dir}/33-qca-wifi* | sed '1!G;h;$!d'); do\n\t\t[ -d /sys/module/${mod} ] && rmmod ${mod}\n\tdone\n}\n\n\ndisable_qcawifi() {\n\tlocal device=\"$1\"\n\tlocal parent\n\tlocal retval=0\n\n\techo \"$DRIVERS disable radio $1\" >/dev/console\n\tfind_qcawifi_phy \"$device\" ||  retval=1\n\n\tif [ $retval -ne 0 ]; then\n\t\tunload_qcawifi\n\t\treturn 1\n\tfi\n\n\tconfig_get phy \"$device\" phy\n\n\tset_wifi_down \"$device\"\n\n\tclear_wifi_ebtables\n\n\tinclude /lib/network\n\tcd /sys/class/net\n\tfor dev in *; do\n\t\t[ -f /sys/class/net/${dev}/parent ] && { \\\n\t\t\tlocal parent=$(cat /sys/class/net/${dev}/parent)\n\t\t\t[ -n \"$parent\" -a \"$parent\" = \"$device\" ] && { \\\n\t\t\t\t[ -f \"/var/run/wifi-${dev}.pid\" ] &&\n\t\t\t\t\tkill \"$(cat \"/var/run/wifi-${dev}.pid\")\"\n\t\t\t\t[ -f \"/var/run/hostapd_cli-${dev}.pid\" ] &&\n\t\t\t\t\tkill \"$(cat \"/var/run/hostapd_cli-${dev}.pid\")\"\n\t\t\t\tifconfig \"$dev\" down\n\t\t\t\tunbridge \"$dev\"\n\t\t\t\twlanconfig \"$dev\" destroy\n\t\t\t}\n\t\t}\n\tdone\n\n\t# delete wlan uptime file\n\tband_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n\tif [ \"$band_type\" = \"g\" ]; then\n\t\trm /tmp/WLAN_uptime\n\t\techo \"OFF\" > /tmp/WLAN_2G_status\n\telif [ \"$band_type\" = \"a\" ]; then\n\t\trm /tmp/WLAN_uptime_5G\n\t\techo \"OFF\" > /tmp/WLAN_5G_status\n\tfi\n\n\ttest \"$2\" != \"dni\"  && {\n\t\tifconfig \"$device\" down\n\t\tnrvaps=$(find /sys/class/net/ -name 'ath*'|wc -l)\n\t\t[ ${nrvaps} -gt 0 ] || unload_qcawifi\n\t}\n\n\treturn 0\n}\n\nenable_qcawifi() {\n\tlocal device=\"$1\"\n\techo \"$DRIVERS: enable radio $1\" >/dev/console\n\n\tconfig_get_bool module_reload qcawifi module_reload 1\n\tif [ \"$2\" != \"dni\" ]; then\t    # wifi up\n\t\tload_qcawifi\n\telif [ $module_reload = \"1\" ]; then # wlan up and module reload\n\t\tnrvaps=$(find /sys/class/net/ -name 'ath*'|wc -l)\n\t\t[ ${nrvaps} -gt 0 ] || {\n\t\t    unload_qcawifi\n\t\t    sleep 3\n\t\t    load_qcawifi\n\t\t}\n\telse\t\t\t\t    # wlan up\n\t\techo \"qcawifi modules are not reloaded\"\n\tfi\n\n\tfind_qcawifi_phy \"$device\" || return 1\n\tconfig_get phy \"$device\" phy\n\n\tconfig_get country \"$device\" country\n\tif [ -z \"$country\" ]; then\n\t\tset_default_country $device || return 1\n\telse\n\t\t# If the country parameter is a number (either hex or decimal), we\n\t\t# assume it's a regulatory domain - i.e. we use iwpriv setCountryID.\n\t\t# Else we assume it's a country code - i.e. we use iwpriv setCountry.\n\t\tcase \"$country\" in\n\t\t\t[0-9]*)\n\t\t\t\tiwpriv \"$phy\" setCountryID \"$country\"\n\t\t\t;;\n\t\t\t*)\n\t\t\t\t[ -n \"$country\" ] && iwpriv \"$phy\" setCountry \"$country\"\n\t\t\t;;\n\t\tesac\n\tfi\n\n\tconfig_get channel \"$device\" channel\n\tconfig_get vifs \"$device\" vifs\n\tconfig_get txpower \"$device\" txpower\n\tconfig_get tpscale \"$device\" tpscale\n\t[ -n \"$tpscale\" ] && iwpriv \"$phy\" tpscale \"$tpscale\"\n\n\t[ auto = \"$channel\" ] && channel=0\n\n\tconfig_get_bool antdiv \"$device\" diversity\n\tconfig_get antrx \"$device\" rxantenna\n\tconfig_get anttx \"$device\" txantenna\n\tconfig_get_bool softled \"$device\" softled\n\tconfig_get antenna \"$device\" antenna\n\tconfig_get distance \"$device\" distance\n\n\t[ -n \"$antdiv\" ] && echo \"antdiv option not supported on this driver\"\n\t[ -n \"$antrx\" ] && echo \"antrx option not supported on this driver\"\n\t[ -n \"$anttx\" ] && echo \"anttx option not supported on this driver\"\n\t[ -n \"$softled\" ] && echo \"softled option not supported on this driver\"\n\t[ -n \"$antenna\" ] && echo \"antenna option not supported on this driver\"\n\t[ -n \"$distance\" ] && echo \"distance option not supported on this driver\"\n\n\t# Advanced QCA wifi per-radio parameters configuration\n\tconfig_get txchainmask \"$device\" txchainmask\n\t[ -n \"$txchainmask\" ] && iwpriv \"$phy\" txchainmask \"$txchainmask\"\n\n\tconfig_get rxchainmask \"$device\" rxchainmask\n\t[ -n \"$rxchainmask\" ] && iwpriv \"$phy\" rxchainmask \"$rxchainmask\"\n\n\tconfig_get AMPDU \"$device\" AMPDU\n\t[ -n \"$AMPDU\" ] && iwpriv \"$phy\" AMPDU \"$AMPDU\"\n\n\tconfig_get ampdudensity \"$device\" ampdudensity\n\t[ -n \"$ampdudensity\" ] && iwpriv \"$phy\" ampdudensity \"$ampdudensity\"\n\n\tconfig_get_bool AMSDU \"$device\" AMSDU\n\t[ -n \"$AMSDU\" ] && iwpriv \"$phy\" AMSDU \"$AMSDU\"\n\n\tconfig_get AMPDULim \"$device\" AMPDULim\n\t[ -n \"$AMPDULim\" ] && iwpriv \"$phy\" AMPDULim \"$AMPDULim\"\n\n\tconfig_get AMPDUFrames \"$device\" AMPDUFrames\n\t[ -n \"$AMPDUFrames\" ] && iwpriv \"$phy\" AMPDUFrames \"$AMPDUFrames\"\n\n\tconfig_get AMPDURxBsize \"$device\" AMPDURxBsize\n\t[ -n \"$AMPDURxBsize\" ] && iwpriv \"$phy\" AMPDURxBsize \"$AMPDURxBsize\"\n\n\tconfig_get_bool bcnburst \"$device\" bcnburst 0\n\t[ \"$bcnburst\" -gt 0 ] && iwpriv \"$phy\" set_bcnburst \"$bcnburst\"\n\n\tconfig_get set_smart_antenna \"$device\" set_smart_antenna\n\t[ -n \"$set_smart_antenna\" ] && iwpriv \"$phy\" setSmartAntenna \"$set_smart_antenna\"\n\n\tconfig_get current_ant \"$device\" current_ant\n\t[ -n  \"$current_ant\" ] && iwpriv \"$phy\" current_ant \"$current_ant\"\n\n\tconfig_get default_ant \"$device\" default_ant\n\t[ -n \"$default_ant\" ] && iwpriv \"$phy\" default_ant \"$default_ant\"\n\n\tconfig_get ant_retrain \"$device\" ant_retrain\n\t[ -n \"$ant_retrain\" ] && iwpriv \"$phy\" ant_retrain \"$ant_retrain\"\n\n\tconfig_get retrain_interval \"$device\" retrain_interval\n\t[ -n \"$retrain_interval\" ] && iwpriv \"$phy\" retrain_interval \"$retrain_interval\"\n\n\tconfig_get retrain_drop \"$device\" retrain_drop\n\t[ -n \"$retrain_drop\" ] && iwpriv \"$phy\" retrain_drop \"$retrain_drop\"\n\n\tconfig_get ant_train \"$device\" ant_train\n\t[ -n \"$ant_train\" ] && iwpriv \"$phy\" ant_train \"$ant_train\"\n\n\tconfig_get ant_trainmode \"$device\" ant_trainmode\n\t[ -n \"$ant_trainmode\" ] && iwpriv \"$phy\" ant_trainmode \"$ant_trainmode\"\n\n\tconfig_get ant_traintype \"$device\" ant_traintype\n\t[ -n \"$ant_traintype\" ] && iwpriv \"$phy\" ant_traintype \"$ant_traintype\"\n\n\tconfig_get ant_pktlen \"$device\" ant_pktlen\n\t[ -n \"$ant_pktlen\" ] && iwpriv \"$phy\" ant_pktlen \"$ant_pktlen\"\n\n\tconfig_get ant_numpkts \"$device\" ant_numpkts\n\t[ -n \"$ant_numpkts\" ] && iwpriv \"$phy\" ant_numpkts \"$ant_numpkts\"\n\n\tconfig_get ant_numitr \"$device\" ant_numitr\n\t[ -n \"$ant_numitr\" ] && iwpriv \"$phy\" ant_numitr \"$ant_numitr\"\n\n\tconfig_get ant_train_thres \"$device\" ant_train_thres\n\t[ -n \"$ant_train_thres\" ] && iwpriv \"$phy\" train_threshold \"$ant_train_thres\"\n\n\tconfig_get ant_train_min_thres \"$device\" ant_train_min_thres\n\t[ -n \"$ant_train_min_thres\" ] && iwpriv \"$phy\" train_threshold \"$ant_train_min_thres\"\n\n\tconfig_get ant_traffic_timer \"$device\" ant_traffic_timer\n\t[ -n \"$ant_traffic_timer\" ] && iwpriv \"$phy\" traffic_timer \"$ant_traffic_timer\"\n\n\tconfig_get dcs_enable \"$device\" dcs_enable\n\t[ -n \"$dcs_enable\" ] && iwpriv \"$phy\" dcs_enable \"$dcs_enable\"\n\n\tconfig_get dcs_coch_int \"$device\" dcs_coch_int\n\t[ -n \"$dcs_coch_int\" ] && iwpriv \"$phy\" set_dcs_coch_int \"$dcs_coch_int\"\n\n\tconfig_get dcs_errth \"$device\" dcs_errth\n\t[ -n \"$dcs_errth\" ] && iwpriv \"$phy\" set_dcs_errth \"$dcs_errth\"\n\n\tconfig_get dcs_phyerrth \"$device\" dcs_phyerrth\n\t[ -n \"$dcs_phyerrth\" ] && iwpriv \"$phy\" set_dcs_phyerrth \"$dcs_phyerrth\"\n\n\tconfig_get dcs_usermaxc \"$device\" dcs_usermaxc\n\t[ -n \"$dcs_usermaxc\" ] && iwpriv \"$phy\" set_dcs_usermaxc \"$dcs_usermaxc\"\n\n\tconfig_get dcs_debug \"$device\" dcs_debug\n\t[ -n \"$dcs_debug\" ] && iwpriv \"$phy\" set_dcs_debug \"$dcs_debug\"\n\n\tconfig_get set_ch_144 \"$device\" set_ch_144\n\t[ -n \"$set_ch_144\" ] && iwpriv \"$phy\" setCH144 \"$set_ch_144\"\n\n\tconfig_get eppovrd_ch_144 \"$device\" eppovrd_ch_144\n\t[ -n \"$eppovrd_ch_144\" ] && iwpriv \"$phy\" setCH144EppOvrd \"$eppovrd_ch_144\"\n\n\tconfig_get_bool ani_enable \"$device\" ani_enable\n\t[ -n \"$ani_enable\" ] && iwpriv \"$phy\" ani_enable \"$ani_enable\"\n\n\tconfig_get_bool acs_bkscanen \"$device\" acs_bkscanen\n\t[ -n \"$acs_bkscanen\" ] && iwpriv \"$phy\" acs_bkscanen \"$acs_bkscanen\"\n\n\tconfig_get acs_scanintvl \"$device\" acs_scanintvl\n\t[ -n \"$acs_scanintvl\" ] && iwpriv \"$phy\" acs_scanintvl \"$acs_scanintvl\"\n\n\tconfig_get acs_rssivar \"$device\" acs_rssivar\n\t[ -n \"$acs_rssivar\" ] && iwpriv \"$phy\" acs_rssivar \"$acs_rssivar\"\n\n\tconfig_get acs_chloadvar \"$device\" acs_chloadvar\n\t[ -n \"$acs_chloadvar\" ] && iwpriv \"$phy\" acs_chloadvar \"$acs_chloadvar\"\n\n\tconfig_get acs_lmtobss \"$device\" acs_lmtobss\n\t[ -n \"$acs_lmtobss\" ] && iwpriv \"$phy\" acs_lmtobss \"$acs_lmtobss\"\n\n\tconfig_get acs_ctrlflags \"$device\" acs_ctrlflags\n\t[ -n \"$acs_ctrlflags\" ] && iwpriv \"$phy\" acs_ctrlflags \"$acs_ctrlflags\"\n\n\tconfig_get acs_dbgtrace \"$device\" acs_dbgtrace\n\t[ -n \"$acs_dbgtrace\" ] && iwpriv \"$phy\" acs_dbgtrace \"$acs_dbgtrace\"\n\n\tconfig_get_bool dscp_ovride \"$device\" dscp_ovride\n\t[ -n \"$dscp_ovride\" ] && iwpriv \"$phy\" set_dscp_ovride \"$dscp_ovride\"\n\n\tconfig_get reset_dscp_map \"$device\" reset_dscp_map\n\t[ -n \"$reset_dscp_map\" ] && iwpriv \"$phy\" reset_dscp_map \"$reset_dscp_map\"\n\n\tconfig_get dscp_tid_map \"$device\" dscp_tid_map\n\t[ -n \"$dscp_tid_map\" ] && iwpriv \"$phy\" set_dscp_tid_map $dscp_tid_map\n\n\tconfig_get_bool igmp_dscp_ovride \"$device\" igmp_dscp_ovride\n\t[ -n \"$igmp_dscp_ovride\" ] && iwpriv \"$phy\" sIgmpDscpOvrid \"$igmp_dscp_ovride\"\n\n\tconfig_get igmp_dscp_tid_map \"$device\" igmp_dscp_tid_map\n\t[ -n \"$igmp_dscp_tid_map\" ] && iwpriv \"$phy\" sIgmpDscpTidMap \"$igmp_dscp_tid_map\"\n\n\tconfig_get_bool hmmc_dscp_ovride \"$device\" hmmc_dscp_ovride\n\t[ -n \"$hmmc_dscp_ovride\" ] && iwpriv \"$phy\" sHmmcDscpOvrid \"$hmmc_dscp_ovride\"\n\n\tconfig_get hmmc_dscp_tid_map \"$device\" hmmc_dscp_tid_map\n\t[ -n \"$hmmc_dscp_tid_map\" ] && iwpriv \"$phy\" sHmmcDscpTidMap \"$hmmc_dscp_tid_map\"\n\n\tconfig_get_bool blk_report_fld \"$device\" blk_report_fld\n\t[ -n \"$blk_report_fld\" ] && iwpriv \"$phy\" setBlkReportFld \"$blk_report_fld\"\n\n\tconfig_get_bool drop_sta_query \"$device\" drop_sta_query\n\t[ -n \"$drop_sta_query\" ] && iwpriv \"$phy\" setDropSTAQuery \"$drop_sta_query\"\n\n\tconfig_get_bool burst \"$device\" burst\n\t[ -n \"$burst\" ] && iwpriv \"$phy\" burst \"$burst\"\n\n\tconfig_get burst_dur \"$device\" burst_dur\n\t[ -n \"$burst_dur\" ] && iwpriv \"$phy\" burst_dur \"$burst_dur\"\n\n\tconfig_get TXPowLim2G \"$device\" TXPowLim2G\n\t[ -n \"$TXPowLim2G\" ] && iwpriv \"$phy\" TXPowLim2G \"$TXPowLim2G\"\n\n\tconfig_get TXPowLim5G \"$device\" TXPowLim5G\n\t[ -n \"$TXPowLim5G\" ] && iwpriv \"$phy\" TXPowLim5G \"$TXPowLim5G\"\n\n\tconfig_get_bool enable_ol_stats \"$device\" enable_ol_stats\n\t[ -n \"$enable_ol_stats\" ] && iwpriv \"$phy\" enable_ol_stats \"$enable_ol_stats\"\n\n\tconfig_get_bool emiwar80p80 \"$device\" emiwar80p80\n\t[ -n \"$emiwar80p80\" ] && iwpriv \"$phy\" emiwar80p80 \"$emiwar80p80\"\n\n\tconfig_get_bool rst_tso_stats \"$device\" rst_tso_stats\n\t[ -n \"$rst_tso_stats\" ] && iwpriv \"$phy\" rst_tso_stats \"$rst_tso_stats\"\n\n\tconfig_get_bool rst_lro_stats \"$device\" rst_lro_stats\n\t[ -n \"$rst_lro_stats\" ] && iwpriv \"$phy\" rst_lro_stats \"$rst_lro_stats\"\n\n\tconfig_get_bool rst_sg_stats \"$device\" rst_sg_stats\n\t[ -n \"$rst_sg_stats\" ] && iwpriv \"$phy\" rst_sg_stats \"$rst_sg_stats\"\n\n\tconfig_get_bool set_fw_recovery \"$device\" set_fw_recovery\n\t[ -n \"$set_fw_recovery\" ] && iwpriv \"$phy\" set_fw_recovery \"$set_fw_recovery\"\n\n\tconfig_get_bool allowpromisc \"$device\" allowpromisc\n\t[ -n \"$allowpromisc\" ] && iwpriv \"$phy\" allowpromisc \"$allowpromisc\"\n\n\tconfig_get set_sa_param \"$device\" set_sa_param\n\t[ -n \"$set_sa_param\" ] && iwpriv \"$phy\" set_sa_param $set_sa_param\n\n\tconfig_get_bool aldstats \"$device\" aldstats\n\t[ -n \"$aldstats\" ] && iwpriv \"$phy\" aldstats \"$aldstats\"\n\n\tconfig_get macaddr \"$device\" macaddr\n\t[ -n \"$macaddr\" ] && iwpriv \"$phy\" setHwaddr \"$macaddr\"\n\n\tconfig_get promisc \"$device\" promisc\n\t[ -n \"$promisc\" ] && iwpriv \"$phy\" promisc $promisc\n\n\thandle_aggr_burst() {\n\t\tlocal value=\"$1\"\n\t\t[ -n \"$value\" ] && iwpriv \"$phy\" aggr_burst $value\n\t}\n\n\tconfig_list_foreach \"$device\" aggr_burst handle_aggr_burst\n\n\tconfig_get_bool block_interbss \"$device\" block_interbss\n\t[ -n \"$block_interbss\" ] && iwpriv \"$phy\" block_interbss \"$block_interbss\"\n\n\tconfig_get set_pmf \"$device\" set_pmf\n\t[ -n \"$set_pmf\" ] && iwpriv \"$phy\" set_pmf \"${set_pmf}\"\n\n\tconfig_get txbf_snd_int \"$device\" txbf_snd_int 100\n\t[ -n \"$txbf_snd_int\" ] && iwpriv \"$phy\" txbf_snd_int \"$txbf_snd_int\"\n\n\tconfig_get mcast_echo \"$device\" mcast_echo\n\t[ -n \"$mcast_echo\" ] && iwpriv \"$phy\" mcast_echo \"${mcast_echo}\"\n\n\tif [ \"$device\" = \"wifi1\" ] && [ -n \"$11ngvhtintop\" ]; then\n\t\tiwpriv wifi1 obss_rssi_th 25\n\t\tiwpriv wifi1 obss_rx_rssi_th 20\n\telse\n\n\t\tconfig_get obss_rssi_th \"$device\" obss_rssi_th 35\n\t\t[ -n \"$obss_rssi_th\" ] && iwpriv \"$phy\" obss_rssi_th \"${obss_rssi_th}\"\n\n\t\tconfig_get obss_rx_rssi_th \"$device\" obss_rx_rssi_th 35\n\t\t[ -n \"$obss_rx_rssi_th\" ] && iwpriv \"$phy\" obss_rx_rssi_th \"${obss_rx_rssi_th}\"\n\n\tfi\n\n        config_get acs_txpwr_opt \"$device\" acs_txpwr_opt\n        [ -n \"$acs_txpwr_opt\" ] && iwpriv \"$phy\" acs_tcpwr_opt \"${acs_txpwr_opt}\"\n\n\tconfig_get obss_long_slot \"$device\" obss_long_slot\n\t[ -n \"$obss_long_slot\" ] && iwpriv \"$phy\" obss_long_slot \"${obss_long_slot}\"\n\n\tconfig_get staDFSEnable \"$device\" staDFSEnable\n\t[ -n \"$staDFSEnable\" ] && iwpriv \"$phy\" staDFSEnable \"${staDFSEnable}\"\n\n\t#\n\t# Follow QCA's suggestion and request from Netgear to improve\n\t# 5 GHz Multi-User MIMO throughput.\n\t#\n\tconfig_get hwmode \"$device\" hwmode\n\tcase \"$hwmode\" in\n\t\t*a|*na|*ac)\n\t\t\tiwpriv $phy fc_buf_min 1000\n\t\t\t;;\n\tesac\n\n\tfor vif in $vifs; do\n\t\tlocal start_hostapd= vif_txpower= nosbeacon= wlanaddr=\"\"\n\t\tlocal wlanmode\n\t\tconfig_get ifname \"$vif\" ifname\n\t\tconfig_get enc \"$vif\" encryption \"none\"\n\t\tconfig_get eap_type \"$vif\" eap_type\n\t\tconfig_get mode \"$vif\" mode\n\t\twlanmode=$mode\n\n\t\t[ \"$wlanmode\" = \"ap_monitor\" ] && wlanmode=\"specialvap\"\n\t\t[ \"$wlanmode\" = \"ap_smart_monitor\" ] && wlanmode=\"smart_monitor\"\n\t\t[ \"$wlanmode\" = \"ap_lp_iot\" ] && wlanmode=\"lp_iot_mode\"\n\n\t\tcase \"$mode\" in\n\t\t\tsta)\n\t\t\t\tconfig_get_bool nosbeacon \"$device\" nosbeacon\n\t\t\t\tconfig_get qwrap_enable \"$device\" qwrap_enable 0\n\t\t\t\t[ $qwrap_enable -gt 0 ] && wlanaddr=\"00:00:00:00:00:00\"\n\t\t\t\t;;\n\t\t\tadhoc)\n\t\t\t\tconfig_get_bool nosbeacon \"$vif\" sw_merge 1\n\t\t\t\t;;\n\t\tesac\n\n\t\t[ \"$nosbeacon\" = 1 ] || nosbeacon=\"\"\n\t\t[ -n \"${DEBUG}\" ] && echo wlanconfig \"$ifname\" create wlandev \"$phy\" wlanmode \"$wlanmode\" ${wlanaddr:+wlanaddr \"$wlanaddr\"} ${nosbeacon:+nosbeacon}\n\t\tifname=$(/usr/sbin/wlanconfig \"$ifname\" create wlandev \"$phy\" wlanmode \"$wlanmode\" ${wlanaddr:+wlanaddr \"$wlanaddr\"} ${nosbeacon:+nosbeacon})\n\t\t[ $? -ne 0 ] && {\n\t\t\techo \"enable_qcawifi($device): Failed to set up $mode vif $ifname\" >&2\n\t\t\tcontinue\n\t\t}\n\t\tconfig_set \"$vif\" ifname \"$ifname\"\n\n\t\tconfig_get hwmode \"$device\" hwmode auto\n\t\tconfig_get htmode \"$device\" htmode auto\n\n\t\tpureg=0\n\t\tcase \"$hwmode:$htmode\" in\n\t\t# The parsing stops at the first match so we need to make sure\n\t\t# these are in the right orders (most generic at the end)\n\t\t\t*ng:HT20) hwmode=11NGHT20;;\n\t\t\t*ng:HT40-) hwmode=11NGHT40MINUS;;\n\t\t\t*ng:HT40+) hwmode=11NGHT40PLUS;;\n\t\t\t*ng:HT40) hwmode=11NGHT40;;\n\t\t\t*ng:*) hwmode=11NGHT20;;\n\t\t\t*na:HT20) hwmode=11NAHT20;;\n\t\t\t*na:HT40-) hwmode=11NAHT40MINUS;;\n\t\t\t*na:HT40+) hwmode=11NAHT40PLUS;;\n\t\t\t*na:HT40) hwmode=11NAHT40;;\n\t\t\t*na:*) hwmode=11NAHT40;;\n\t\t\t*ac:HT20) hwmode=11ACVHT20;;\n\t\t\t*ac:HT40+) hwmode=11ACVHT40PLUS;;\n\t\t\t*ac:HT40-) hwmode=11ACVHT40MINUS;;\n\t\t\t*ac:HT40) hwmode=11ACVHT40;;\n\t\t\t*ac:HT80) hwmode=11ACVHT80;;\n\t\t\t*ac:HT160) hwmode=11ACVHT160;;\n\t\t\t*ac:HT80_80) hwmode=11ACVHT80_80;;\n                        *ac:*) hwmode=11ACVHT80\n\t\t\t       if [ -f /sys/class/net/$device/5g_maxchwidth ]; then\n\t\t\t           maxchwidth=\"$(cat /sys/class/net/$device/5g_maxchwidth)\"\n\t\t\t\t   [ -n \"$maxchwidth\" ] && hwmode=11ACVHT$maxchwidth\n\t\t\t       fi;;\n\t\t\t*b:*) hwmode=11B;;\n\t\t\t*bg:*) hwmode=11G;;\n\t\t\t*g:*) hwmode=11G; pureg=1;;\n\t\t\t*a:*) hwmode=11A;;\n\t\t\t*) hwmode=AUTO;;\n\t\tesac\n\t\tiwpriv \"$ifname\" mode \"$hwmode\"\n\t\t[ $pureg -gt 0 ] && iwpriv \"$ifname\" pureg \"$pureg\"\n\n\t\tconfig_get cfreq2 \"$vif\" cfreq2\n\t\t[ -n \"$cfreq2\" -a \"$htmode\" = \"HT80_80\" ] && iwpriv \"$ifname\" cfreq2 \"$cfreq2\"\n\n\t\tconfig_get puren \"$vif\" puren\n\t\t[ -n \"$puren\" ] && iwpriv \"$ifname\" puren \"$puren\"\n\n\t\tiwconfig \"$ifname\" channel \"$channel\"\n\n\t\tconfig_get_bool hidden \"$vif\" hidden 0\n\t\tiwpriv \"$ifname\" hide_ssid \"$hidden\"\n\n\t\tconfig_get_bool shortgi \"$vif\" shortgi 1\n\t\t[ -n \"$shortgi\" ] && iwpriv \"$ifname\" shortgi \"${shortgi}\"\n\n\t\tconfig_get_bool disablecoext \"$vif\" disablecoext\n\t\t[ -n \"$disablecoext\" ] && iwpriv \"$ifname\" disablecoext \"${disablecoext}\"\n\t\t[ \"$disablecoext\" -eq \"0\" ] && iwpriv $ifname extbusythres 10\n\t\t[ \"$disablecoext\" -eq \"1\" ] && iwpriv $ifname extbusythres 100\n\n\t\tconfig_get chwidth \"$vif\" chwidth\n\t\t[ -n \"$chwidth\" ] && iwpriv \"$ifname\" chwidth \"${chwidth}\"\n\n\t\tconfig_get wds \"$vif\" wds\n\t\tcase \"$wds\" in\n\t\t\t1|on|enabled) wds=1;;\n\t\t\t*) wds=0;;\n\t\tesac\n\t\tiwpriv \"$ifname\" wds \"$wds\"\n\n\t\tconfig_get ODM \"$device\" ODM\n\t\tconfig_get bridge \"$vif\" bridge\n\t\t[ \"$ODM\" = \"dni\" ] && [ \"$wds\" = \"1\" ] && brctl stp \"$bridge\" on\n\n\t\tconfig_get vlan_pri \"$vif\" vlan_pri\n\t\tif [ \"$vlan_pri\" = \"\" ]; then\n\t\t\tiwpriv \"$ifname\" dni_vlan_pri -1\n\t\telse\n\t\t\tiwpriv \"$ifname\" dni_vlan_pri \"$vlan_pri\"\n\t\tfi\n\n\t\tconfig_get TxBFCTL \"$vif\" TxBFCTL\n\t\t[ -n \"$TxBFCTL\" ] && iwpriv \"$ifname\" TxBFCTL \"$TxBFCTL\"\n\n\t\tconfig_get bintval \"$vif\" bintval\n\t\t[ -n \"$bintval\" ] && iwpriv \"$ifname\" bintval \"$bintval\"\n\n\t\tconfig_get_bool countryie \"$vif\" countryie\n\t\t[ -n \"$countryie\" ] && iwpriv \"$ifname\" countryie \"$countryie\"\n\n\t\tcase \"$enc\" in\n\t\t\tnone)\n\t\t\t\t# If we're in open mode and want to use WPS, we\n\t\t\t\t# must start hostapd\n\t\t\t\tconfig_get_bool wps_pbc \"$vif\" wps_pbc 0\n\t\t\t\tconfig_get config_methods \"$vif\" wps_config\n\t\t\t\t[ \"$wps_pbc\" -gt 0 ] && append config_methods push_button\n\t\t\t\t[ -n \"$config_methods\" ] && start_hostapd=1\n\t\t\t;;\n\t\t\twep*)\n\t\t\t\tcase \"$enc\" in\n\t\t\t\t\t*mixed*)  iwpriv \"$ifname\" authmode 4;;\n\t\t\t\t\t*shared*) iwpriv \"$ifname\" authmode 2;;\n\t\t\t\t\t*)        iwpriv \"$ifname\" authmode 1;;\n\t\t\t\tesac\n\t\t\t\tfor idx in 1 2 3 4; do\n\t\t\t\t\tconfig_get key \"$vif\" \"key${idx}\"\n\t\t\t\t\tconfig_get key_format \"$vif\" \"key${idx}_format\"\n\t\t\t\t\tif [ \"$key_format\" = \"ASCII\" ]; then\n\t\t\t\t\t\tiwconfig \"$ifname\" enc s:\"${key:-off}\" \"[$idx]\"\n\t\t\t\t\telse\n\t\t\t\t\t\tiwconfig \"$ifname\" enc \"[$idx]\" \"${key:-off}\"\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\t\tconfig_get key \"$vif\" key\n\t\t\t\tkey=\"${key:-1}\"\n\t\t\t\tcase \"$key\" in\n\t\t\t\t\t[1234]) iwconfig \"$ifname\" enc \"[$key]\";;\n\t\t\t\t\t*) iwconfig \"$ifname\" enc \"$key\";;\n\t\t\t\tesac\n\t\t\t;;\n\t\t\tmixed*|psk*|wpa*|8021x)\n\t\t\t\tstart_hostapd=1\n\t\t\t\tconfig_get key \"$vif\" key\n\t\t\t;;\n\t\t\twapi*)\n\t\t\t\tstart_wapid=1\n\t\t\t\tconfig_get key \"$vif\" key\n\t\t\t;;\n\t\tesac\n\n\t\tcase \"$mode\" in\n\t\t\tsta|adhoc)\n\t\t\t\tconfig_get addr \"$vif\" bssid\n\t\t\t\t[ -z \"$addr\" ] || {\n\t\t\t\t\tiwconfig \"$ifname\" ap \"$addr\"\n\t\t\t\t}\n\t\t\t;;\n\t\tesac\n\n\t\tconfig_get_bool uapsd \"$vif\" uapsd 1\n\t\tiwpriv \"$ifname\" uapsd \"$uapsd\"\n\n\t\tconfig_get mcast_rate \"$vif\" mcast_rate\n\t\t[ -n \"$mcast_rate\" ] && iwpriv \"$ifname\" mcast_rate \"${mcast_rate%%.*}\"\n\n\t\tconfig_get powersave \"$vif\" powersave\n\t\t[ -n \"$powersave\" ] && iwpriv \"$ifname\" powersave \"${powersave}\"\n\n\t\tconfig_get_bool ant_ps_on \"$vif\" ant_ps_on\n\t\t[ -n \"$ant_ps_on\" ] && iwpriv \"$ifname\" ant_ps_on \"${ant_ps_on}\"\n\n\t\tconfig_get ps_timeout \"$vif\" ps_timeout\n\t\t[ -n \"$ps_timeout\" ] && iwpriv \"$ifname\" ps_timeout \"${ps_timeout}\"\n\n\t\tconfig_get mcastenhance \"$vif\" mcastenhance\n\t\t[ -n \"$mcastenhance\" ] && iwpriv \"$ifname\" mcastenhance \"${mcastenhance}\"\n\n\t\tconfig_get metimer \"$vif\" metimer\n\t\t[ -n \"$metimer\" ] && iwpriv \"$ifname\" metimer \"${metimer}\"\n\n\t\tconfig_get metimeout \"$vif\" metimeout\n\t\t[ -n \"$metimeout\" ] && iwpriv \"$ifname\" metimeout \"${metimeout}\"\n\n\t\tconfig_get_bool medropmcast \"$vif\" medropmcast\n\t\t[ -n \"$medropmcast\" ] && iwpriv \"$ifname\" medropmcast \"${medropmcast}\"\n\n\t\tconfig_get me_adddeny \"$vif\" me_adddeny\n\t\t[ -n \"$me_adddeny\" ] && iwpriv \"$ifname\" me_adddeny ${me_adddeny}\n\n\t\t#support independent repeater mode\n\t\tconfig_get vap_ind \"$vif\" vap_ind\n\t\t[ -n \"$vap_ind\" ] && iwpriv \"$ifname\" vap_ind \"${vap_ind}\"\n\n\t\t#support extender ap & STA\n\t\tconfig_get extap \"$vif\" extap\n\t\t[ -n \"$extap\" ] && iwpriv \"$ifname\" extap \"${extap}\"\n\n\t\tconfig_get scanband \"$vif\" scanband\n\t\t[ -n \"$scanband\" ] && iwpriv \"$ifname\" scanband \"${scanband}\"\n\n\t\tconfig_get periodicScan \"$vif\" periodicScan\n\t\t[ -n \"$periodicScan\" ] && iwpriv \"$ifname\" periodicScan \"${periodicScan}\"\n\n                config_get cb \"$vif\" cb\n                if [ \"$cb\" = \"qca\" ]; then\n                    iwpriv \"$ifname\" extap 1\n                    iwpriv \"$ifname\" scanband 1\n                    iwpriv \"$ifname\" periodicScan 180000\n                elif [ \"$cb\" = \"dni\" ]; then\n                    iwpriv \"$ifname\" dni_cb 1\n                    iwpriv \"$ifname\" periodicScan 180000\n                fi\n\n\t\tconfig_get_bool short_preamble \"$vif\" short_preamble 1\n\t\t[ -n \"$short_preamble\" ] && iwpriv \"$ifname\" shpreamble \"${short_preamble}\"\n\n\t\tconfig_get frag \"$vif\" frag\n\t\t[ -n \"$frag\" ] && iwconfig \"$ifname\" frag \"${frag%%.*}\"\n\n\t\tconfig_get rts \"$vif\" rts\n\t\t[ -n \"$rts\" ] && iwconfig \"$ifname\" rts \"${rts%%.*}\"\n\n\t\tconfig_get cwmin \"$vif\" cwmin\n\t\t[ -n \"$cwmin\" ] && iwpriv \"$ifname\" cwmin ${cwmin}\n\n\t\tconfig_get cwmax \"$vif\" cwmax\n\t\t[ -n \"$cwmax\" ] && iwpriv \"$ifname\" cwmax ${cwmax}\n\n\t\tconfig_get aifs \"$vif\" aifs\n\t\t[ -n \"$aifs\" ] && iwpriv \"$ifname\" aifs ${aifs}\n\n\t\tconfig_get txoplimit \"$vif\" txoplimit\n\t\t[ -n \"$txoplimit\" ] && iwpriv \"$ifname\" txoplimit ${txoplimit}\n\n\t\tconfig_get noackpolicy \"$vif\" noackpolicy\n\t\t[ -n \"$noackpolicy\" ] && iwpriv \"$ifname\" noackpolicy ${noackpolicy}\n\n\t\tconfig_get_bool wmm \"$vif\" wmm\n\t\t[ -n \"$wmm\" ] && iwpriv \"$ifname\" wmm \"$wmm\"\n\n\t\tconfig_get_bool doth \"$vif\" doth\n\t\t[ -n \"$doth\" ] && iwpriv \"$ifname\" doth \"$doth\"\n\n\t\tconfig_get doth_chanswitch \"$vif\" doth_chanswitch\n\t\t[ -n \"$doth_chanswitch\" ] && iwpriv \"$ifname\" doth_chanswitch ${doth_chanswitch}\n\n\t\tconfig_get quiet \"$vif\" quiet\n\t\t[ -n \"$quiet\" ] && iwpriv \"$ifname\" quiet \"$quiet\"\n\n\t\tconfig_get mfptest \"$vif\" mfptest\n\t\t[ -n \"$mfptest\" ] && iwpriv \"$ifname\" mfptest \"$mfptest\"\n\n\t\tconfig_get dtim_period \"$vif\" dtim_period\n\t\t[ -n \"$dtim_period\" ] && iwpriv \"$ifname\" dtim_period \"$dtim_period\"\n\n\t\tconfig_get noedgech \"$vif\" noedgech\n\t\t[ -n \"$noedgech\" ] && iwpriv \"$ifname\" noedgech \"$noedgech\"\n\n\t\tconfig_get ps_on_time \"$vif\" ps_on_time\n\t\t[ -n \"$ps_on_time\" ] && iwpriv \"$ifname\" ps_on_time \"$ps_on_time\"\n\n\t\tconfig_get inact \"$vif\" inact\n\t\t[ -n \"$inact\" ] && iwpriv \"$ifname\" inact \"$inact\"\n\n\t\tconfig_get wnm \"$vif\" wnm\n\t\t[ -n \"$wnm\" ] && iwpriv \"$ifname\" wnm \"$wnm\"\n\n\t\tconfig_get ampdu \"$vif\" ampdu\n\t\t[ -n \"$ampdu\" ] && iwpriv \"$ifname\" ampdu \"$ampdu\"\n\n\t\tconfig_get amsdu \"$vif\" amsdu\n\t\t[ -n \"$amsdu\" ] && iwpriv \"$ifname\" amsdu \"$amsdu\"\n\n\t\tconfig_get maxampdu \"$vif\" maxampdu\n\t\t[ -n \"$maxampdu\" ] && iwpriv \"$ifname\" maxampdu \"$maxampdu\"\n\n\t\tconfig_get vhtmaxampdu \"$vif\" vhtmaxampdu\n\t\t[ -n \"$vhtmaxampdu\" ] && iwpriv \"$ifname\" vhtmaxampdu \"$vhtmaxampdu\"\n\n\t\tconfig_get setaddbaoper \"$vif\" setaddbaoper\n\t\t[ -n \"$setaddbaoper\" ] && iwpriv \"$ifname\" setaddbaoper \"$setaddbaoper\"\n\n\t\tconfig_get addbaresp \"$vif\" addbaresp\n\t\t[ -n \"$addbaresp\" ] && iwpriv \"$ifname\" $addbaresp\n\n\t\tconfig_get addba \"$vif\" addba\n\t\t[ -n \"$addba\" ] && iwpriv \"$ifname\" addba $addba\n\n\t\tconfig_get delba \"$vif\" delba\n\t\t[ -n \"$delba\" ] && iwpriv \"$ifname\" delba $delba\n\n\t\tconfig_get_bool stafwd \"$vif\" stafwd 0\n\t\t[ -n \"$stafwd\" ] && iwpriv \"$ifname\" stafwd \"$stafwd\"\n\n\t\tconfig_get maclist \"$vif\" maclist\n\t\t[ -n \"$maclist\" ] && {\n\t\t\t# flush MAC list\n\t\t\tiwpriv \"$ifname\" maccmd 3\n\t\t\tfor mac in $maclist; do\n\t\t\t\tiwpriv \"$ifname\" addmac \"$mac\"\n\t\t\tdone\n\t\t}\n\n\t\tconfig_get macfilter \"$vif\" macfilter\n\t\tcase \"$macfilter\" in\n\t\t\tallow)\n\t\t\t\tiwpriv \"$ifname\" maccmd 1\n\t\t\t;;\n\t\t\tdeny)\n\t\t\t\tiwpriv \"$ifname\" maccmd 2\n\t\t\t;;\n\t\t\t*)\n\t\t\t\t# default deny policy if mac list exists\n\t\t\t\t[ -n \"$maclist\" ] && iwpriv \"$ifname\" maccmd 2\n\t\t\t;;\n\t\tesac\n\n\t\tconfig_get nss \"$vif\" nss\n\t\t[ -n \"$nss\" ] && iwpriv \"$ifname\" nss \"$nss\"\n\n\t\tconfig_get vht_mcsmap \"$vif\" vht_mcsmap\n\t\t[ -n \"$vht_mcsmap\" ] && iwpriv \"$ifname\" vht_mcsmap \"$vht_mcsmap\"\n\n\t\tconfig_get chwidth \"$vif\" chwidth\n\t\t[ -n \"$chwidth\" ] && iwpriv \"$ifname\" chwidth \"$chwidth\"\n\n\t\tconfig_get chbwmode \"$vif\" chbwmode\n\t\t[ -n \"$chbwmode\" ] && iwpriv \"$ifname\" chbwmode \"$chbwmode\"\n\n\t\tconfig_get ldpc \"$vif\" ldpc\n\t\t[ -n \"$ldpc\" ] && iwpriv \"$ifname\" ldpc \"$ldpc\"\n\n\t\tconfig_get rx_stbc \"$vif\" rx_stbc\n\t\t[ -n \"$rx_stbc\" ] && iwpriv \"$ifname\" rx_stbc \"$rx_stbc\"\n\n\t\tconfig_get tx_stbc \"$vif\" tx_stbc\n\t\t[ -n \"$tx_stbc\" ] && iwpriv \"$ifname\" tx_stbc \"$tx_stbc\"\n\n\t\tconfig_get cca_thresh \"$vif\" cca_thresh\n\t\t[ -n \"$cca_thresh\" ] && iwpriv \"$ifname\" cca_thresh \"$cca_thresh\"\n\n\t\tconfig_get set11NRetries \"$vif\" set11NRetries\n\t\t[ -n \"$set11NRetries\" ] && iwpriv \"$ifname\" set11NRetries \"$set11NRetries\"\n\n\t\tconfig_get chanbw \"$vif\" chanbw\n\t\t[ -n \"$chanbw\" ] && iwpriv \"$ifname\" chanbw \"$chanbw\"\n\n\t\tconfig_get maxsta \"$vif\" maxsta\n\t\t[ -n \"$maxsta\" ] && iwpriv \"$ifname\" maxsta \"$maxsta\"\n\n\t\tconfig_get sko_max_xretries \"$vif\" sko_max_xretries\n\t\t[ -n \"$sko_max_xretries\" ] && iwpriv \"$ifname\" sko \"$sko_max_xretries\"\n\n\t\tconfig_get extprotmode \"$vif\" extprotmode\n\t\t[ -n \"$extprotmode\" ] && iwpriv \"$ifname\" extprotmode \"$extprotmode\"\n\n\t\tconfig_get extprotspac \"$vif\" extprotspac\n\t\t[ -n \"$extprotspac\" ] && iwpriv \"$ifname\" extprotspac \"$extprotspac\"\n\n\t\tconfig_get_bool cwmenable \"$vif\" cwmenable\n\t\t[ -n \"$cwmenable\" ] && iwpriv \"$ifname\" cwmenable \"$cwmenable\"\n\n\t\tconfig_get_bool protmode \"$vif\" protmode\n\t\t[ -n \"$protmode\" ] && iwpriv \"$ifname\" protmode \"$protmode\"\n\n\t\tconfig_get enablertscts \"$vif\" enablertscts\n\t\t[ -n \"$enablertscts\" ] && iwpriv \"$ifname\" enablertscts \"$enablertscts\"\n\n\t\tconfig_get txcorrection \"$vif\" txcorrection\n\t\t[ -n \"$txcorrection\" ] && iwpriv \"$ifname\" txcorrection \"$txcorrection\"\n\n\t\tconfig_get rxcorrection \"$vif\" rxcorrection\n\t\t[ -n \"$rxcorrection\" ] && iwpriv \"$ifname\" rxcorrection \"$rxcorrection\"\n\n\t\tconfig_get ssid \"$vif\" ssid\n                [ -n \"$ssid\" ] && {\n                        iwconfig \"$ifname\" essid on\n                        iwconfig \"$ifname\" essid \"$ssid\"\n                }\n\n\t\tconfig_get txqueuelen \"$vif\" txqueuelen\n\t\t[ -n \"$txqueuelen\" ] && ifconfig \"$ifname\" txqueuelen \"$txqueuelen\"\n\n                net_cfg=\"$(find_net_config \"$vif\")\"\n\n                config_get mtu $net_cfg mtu\n\n                [ -n \"$mtu\" ] && {\n                        config_set \"$vif\" mtu $mtu\n                        ifconfig \"$ifname\" mtu $mtu\n\t\t}\n\n\t\tconfig_get tdls \"$vif\" tdls\n\t\t[ -n \"$tdls\" ] && iwpriv \"$ifname\" tdls \"$tdls\"\n\n\t\tconfig_get set_tdls_rmac \"$vif\" set_tdls_rmac\n\t\t[ -n \"$set_tdls_rmac\" ] && iwpriv \"$ifname\" set_tdls_rmac \"$set_tdls_rmac\"\n\n\t\tconfig_get tdls_qosnull \"$vif\" tdls_qosnull\n\t\t[ -n \"$tdls_qosnull\" ] && iwpriv \"$ifname\" tdls_qosnull \"$tdls_qosnull\"\n\n\t\tconfig_get tdls_uapsd \"$vif\" tdls_uapsd\n\t\t[ -n \"$tdls_uapsd\" ] && iwpriv \"$ifname\" tdls_uapsd \"$tdls_uapsd\"\n\n\t\tconfig_get tdls_set_rcpi \"$vif\" tdls_set_rcpi\n\t\t[ -n \"$tdls_set_rcpi\" ] && iwpriv \"$ifname\" set_rcpi \"$tdls_set_rcpi\"\n\n\t\tconfig_get tdls_set_rcpi_hi \"$vif\" tdls_set_rcpi_hi\n\t\t[ -n \"$tdls_set_rcpi_hi\" ] && iwpriv \"$ifname\" set_rcpihi \"$tdls_set_rcpi_hi\"\n\n\t\tconfig_get tdls_set_rcpi_lo \"$vif\" tdls_set_rcpi_lo\n\t\t[ -n \"$tdls_set_rcpi_lo\" ] && iwpriv \"$ifname\" set_rcpilo \"$tdls_set_rcpi_lo\"\n\n\t\tconfig_get tdls_set_rcpi_margin \"$vif\" tdls_set_rcpi_margin\n\t\t[ -n \"$tdls_set_rcpi_margin\" ] && iwpriv \"$ifname\" set_rcpimargin \"$tdls_set_rcpi_margin\"\n\n\t\tconfig_get tdls_dtoken \"$vif\" tdls_dtoken\n\t\t[ -n \"$tdls_dtoken\" ] && iwpriv \"$ifname\" tdls_dtoken \"$tdls_dtoken\"\n\n\t\tconfig_get do_tdls_dc_req \"$vif\" do_tdls_dc_req\n\t\t[ -n \"$do_tdls_dc_req\" ] && iwpriv \"$ifname\" do_tdls_dc_req \"$do_tdls_dc_req\"\n\n\t\tconfig_get tdls_auto \"$vif\" tdls_auto\n\t\t[ -n \"$tdls_auto\" ] && iwpriv \"$ifname\" tdls_auto \"$tdls_auto\"\n\n\t\tconfig_get tdls_off_timeout \"$vif\" tdls_off_timeout\n\t\t[ -n \"$tdls_off_timeout\" ] && iwpriv \"$ifname\" off_timeout \"$tdls_off_timeout\"\n\n\t\tconfig_get tdls_tdb_timeout \"$vif\" tdls_tdb_timeout\n\t\t[ -n \"$tdls_tdb_timeout\" ] && iwpriv \"$ifname\" tdb_timeout \"$tdls_tdb_timeout\"\n\n\t\tconfig_get tdls_weak_timeout \"$vif\" tdls_weak_timeout\n\t\t[ -n \"$tdls_weak_timeout\" ] && iwpriv \"$ifname\" weak_timeout \"$tdls_weak_timeout\"\n\n\t\tconfig_get tdls_margin \"$vif\" tdls_margin\n\t\t[ -n \"$tdls_margin\" ] && iwpriv \"$ifname\" tdls_margin \"$tdls_margin\"\n\n\t\tconfig_get tdls_rssi_ub \"$vif\" tdls_rssi_ub\n\t\t[ -n \"$tdls_rssi_ub\" ] && iwpriv \"$ifname\" tdls_rssi_ub \"$tdls_rssi_ub\"\n\n\t\tconfig_get tdls_rssi_lb \"$vif\" tdls_rssi_lb\n\t\t[ -n \"$tdls_rssi_lb\" ] && iwpriv \"$ifname\" tdls_rssi_lb \"$tdls_rssi_lb\"\n\n\t\tconfig_get tdls_path_sel \"$vif\" tdls_path_sel\n\t\t[ -n \"$tdls_path_sel\" ] && iwpriv \"$ifname\" tdls_pathSel \"$tdls_path_sel\"\n\n\t\tconfig_get tdls_rssi_offset \"$vif\" tdls_rssi_offset\n\t\t[ -n \"$tdls_rssi_offset\" ] && iwpriv \"$ifname\" tdls_rssi_o \"$tdls_rssi_offset\"\n\n\t\tconfig_get tdls_path_sel_period \"$vif\" tdls_path_sel_period\n\t\t[ -n \"$tdls_path_sel_period\" ] && iwpriv \"$ifname\" tdls_pathSel_p \"$tdls_path_sel_period\"\n\n\t\tconfig_get tdlsmacaddr1 \"$vif\" tdlsmacaddr1\n\t\t[ -n \"$tdlsmacaddr1\" ] && iwpriv \"$ifname\" tdlsmacaddr1 \"$tdlsmacaddr1\"\n\n\t\tconfig_get tdlsmacaddr2 \"$vif\" tdlsmacaddr2\n\t\t[ -n \"$tdlsmacaddr2\" ] && iwpriv \"$ifname\" tdlsmacaddr2 \"$tdlsmacaddr2\"\n\n\t\tconfig_get tdlsaction \"$vif\" tdlsaction\n\t\t[ -n \"$tdlsaction\" ] && iwpriv \"$ifname\" tdlsaction \"$tdlsaction\"\n\n\t\tconfig_get tdlsoffchan \"$vif\" tdlsoffchan\n\t\t[ -n \"$tdlsoffchan\" ] && iwpriv \"$ifname\" tdlsoffchan \"$tdlsoffchan\"\n\n\t\tconfig_get tdlsswitchtime \"$vif\" tdlsswitchtime\n\t\t[ -n \"$tdlsswitchtime\" ] && iwpriv \"$ifname\" tdlsswitchtime \"$tdlsswitchtime\"\n\n\t\tconfig_get tdlstimeout \"$vif\" tdlstimeout\n\t\t[ -n \"$tdlstimeout\" ] && iwpriv \"$ifname\" tdlstimeout \"$tdlstimeout\"\n\n\t\tconfig_get tdlsecchnoffst \"$vif\" tdlsecchnoffst\n\t\t[ -n \"$tdlsecchnoffst\" ] && iwpriv \"$ifname\" tdlsecchnoffst \"$tdlsecchnoffst\"\n\n\t\tconfig_get tdlsoffchnmode \"$vif\" tdlsoffchnmode\n\t\t[ -n \"$tdlsoffchnmode\" ] && iwpriv \"$ifname\" tdlsoffchnmode \"$tdlsoffchnmode\"\n\n\t\tconfig_get_bool blockdfschan \"$vif\" blockdfschan\n\t\t[ -n \"$blockdfschan\" ] && iwpriv \"$ifname\" blockdfschan \"$blockdfschan\"\n\n\t\tconfig_get dbgLVL \"$vif\" dbgLVL\n\t\t[ -n \"$dbgLVL\" ] && iwpriv \"$ifname\" dbgLVL \"$dbgLVL\"\n\n\t\tconfig_get acsmindwell \"$vif\" acsmindwell\n\t\t[ -n \"$acsmindwell\" ] && iwpriv \"$ifname\" acsmindwell \"$acsmindwell\"\n\n\t\tconfig_get acsmaxdwell \"$vif\" acsmaxdwell\n\t\t[ -n \"$acsmaxdwell\" ] && iwpriv \"$ifname\" acsmaxdwell \"$acsmaxdwell\"\n\n\t\tconfig_get acsreport \"$vif\" acsreport\n\t\t[ -n \"$acsreport\" ] && iwpriv \"$ifname\" acsreport \"$acsreport\"\n\n\t\tconfig_get ch_hop_en \"$vif\" ch_hop_en\n\t\t[ -n \"$ch_hop_en\" ] && iwpriv \"$ifname\" ch_hop_en \"$ch_hop_en\"\n\n\t\tconfig_get ch_long_dur \"$vif\" ch_long_dur\n\t\t[ -n \"$ch_long_dur\" ] && iwpriv \"$ifname\" ch_long_dur \"$ch_long_dur\"\n\n\t\tconfig_get ch_nhop_dur \"$vif\" ch_nhop_dur\n\t\t[ -n \"$ch_nhop_dur\" ] && iwpriv \"$ifname\" ch_nhop_dur \"$ch_nhop_dur\"\n\n\t\tconfig_get ch_cntwn_dur \"$vif\" ch_cntwn_dur\n\t\t[ -n \"$ch_cntwn_dur\" ] && iwpriv \"$ifname\" ch_cntwn_dur \"$ch_cntwn_dur\"\n\n\t\tconfig_get ch_noise_th \"$vif\" ch_noise_th\n\t\t[ -n \"$ch_noise_th\" ] && iwpriv \"$ifname\" ch_noise_th \"$ch_noise_th\"\n\n\t\tconfig_get ch_cnt_th \"$vif\" ch_cnt_th\n\t\t[ -n \"$ch_cnt_th\" ] && iwpriv \"$ifname\" ch_cnt_th \"$ch_cnt_th\"\n\n\t\tconfig_get_bool scanchevent \"$vif\" scanchevent\n\t\t[ -n \"$scanchevent\" ] && iwpriv \"$ifname\" scanchevent \"$scanchevent\"\n\n\t\tconfig_get_bool send_add_ies \"$vif\" send_add_ies\n\t\t[ -n \"$send_add_ies\" ] && iwpriv \"$ifname\" send_add_ies \"$send_add_ies\"\n\n\t\tconfig_get_bool ext_ifu_acs \"$vif\" ext_ifu_acs\n\t\t[ -n \"$ext_ifu_acs\" ] && iwpriv \"$ifname\" ext_ifu_acs \"$ext_ifu_acs\"\n\n\t\tconfig_get_bool rrm \"$vif\" rrm\n\t\t[ -n \"$rrm\" ] && iwpriv \"$ifname\" rrm \"$rrm\"\n\n\t\tconfig_get_bool rrmslwin \"$vif\" rrmslwin\n\t\t[ -n \"$rrmslwin\" ] && iwpriv \"$ifname\" rrmslwin \"$rrmslwin\"\n\n\t\tconfig_get_bool rrmstats \"$vif\" rrmsstats\n\t\t[ -n \"$rrmstats\" ] && iwpriv \"$ifname\" rrmstats \"$rrmstats\"\n\n\t\tconfig_get rrmdbg \"$vif\" rrmdbg\n\t\t[ -n \"$rrmdbg\" ] && iwpriv \"$ifname\" rrmdbg \"$rrmdbg\"\n\n\t\tconfig_get acparams \"$vif\" acparams\n\t\t[ -n \"$acparams\" ] && iwpriv \"$ifname\" acparams $acparams\n\n\t\tconfig_get setwmmparams \"$vif\" setwmmparams\n\t\t[ -n \"$setwmmparams\" ] && iwpriv \"$ifname\" setwmmparams $setwmmparams\n\n\t\tconfig_get_bool qbssload \"$vif\" qbssload\n\t\t[ -n \"$qbssload\" ] && iwpriv \"$ifname\" qbssload \"$qbssload\"\n\n\t\tconfig_get_bool proxyarp \"$vif\" proxyarp\n\t\t[ -n \"$proxyarp\" ] && iwpriv \"$ifname\" proxyarp \"$proxyarp\"\n\n\t\tconfig_get_bool dgaf_disable \"$vif\" dgaf_disable\n\t\t[ -n \"$dgaf_disable\" ] && iwpriv \"$ifname\" dgaf_disable \"$dgaf_disable\"\n\n\t\tconfig_get setibssdfsparam \"$vif\" setibssdfsparam\n\t\t[ -n \"$setibssdfsparam\" ] && iwpriv \"$ifname\" setibssdfsparam \"$setibssdfsparam\"\n\n\t\tconfig_get startibssrssimon \"$vif\" startibssrssimon\n\t\t[ -n \"$startibssrssimon\" ] && iwpriv \"$ifname\" startibssrssimon \"$startibssrssimon\"\n\n\t\tconfig_get setibssrssihyst \"$vif\" setibssrssihyst\n\t\t[ -n \"$setibssrssihyst\" ] && iwpriv \"$ifname\" setibssrssihyst \"$setibssrssihyst\"\n\n\t\tconfig_get noIBSSCreate \"$vif\" noIBSSCreate\n\t\t[ -n \"$noIBSSCreate\" ] && iwpriv \"$ifname\" noIBSSCreate \"$noIBSSCreate\"\n\n\t\tconfig_get setibssrssiclass \"$vif\" setibssrssiclass\n\t\t[ -n \"$setibssrssiclass\" ] && iwpriv \"$ifname\" setibssrssiclass $setibssrssiclass\n\n\t\tconfig_get offchan_tx_test \"$vif\" offchan_tx_test\n\t\t[ -n \"$offchan_tx_test\" ] && iwpriv \"$ifname\" offchan_tx_test $offchan_tx_test\n\n\t\thandle_vow_dbg_cfg() {\n\t\t\tlocal value=\"$1\"\n\t\t\t[ -n \"$value\" ] && iwpriv \"$ifname\" vow_dbg_cfg $value\n\t\t}\n\n\t\tconfig_list_foreach \"$vif\" vow_dbg_cfg handle_vow_dbg_cfg\n\n\t\tconfig_get_bool vow_dbg \"$vif\" vow_dbg\n\t\t[ -n \"$vow_dbg\" ] && iwpriv \"$ifname\" vow_dbg \"$vow_dbg\"\n\n\t\thandle_set_max_rate() {\n\t\t\tlocal value=\"$1\"\n\t\t\t[ -n \"$value\" ] && wlanconfig \"$ifname\" set_max_rate $value\n\t\t}\n\t\tconfig_list_foreach \"$vif\" set_max_rate handle_set_max_rate\n\n\t\t# \"implicitbf\" is set in \"wifi-device\" section\n\t\tconfig_get_bool implicitbf \"$device\" implicitbf\n\t\t[ -n \"$implicitbf\" ] && iwpriv \"$ifname\" implicitbf \"${implicitbf}\"\n\n\t\t#\n\t\t# \"implicitbf\" is set in \"wifi-iface\" section. If set, This will\n\t\t# overwrite \"implicitbf\" in \"wifi-device\" section.\n\t\t#\n\t\tconfig_get_bool implicitbf \"$vif\" implicitbf\n\t\t[ -n \"$implicitbf\" ] && iwpriv \"$ifname\" implicitbf \"${implicitbf}\"\n\n\t\tconfig_get_bool vhtsubfee \"$vif\" vhtsubfee\n\t\t[ -n \"$vhtsubfee\" ] && iwpriv \"$ifname\" vhtsubfee \"${vhtsubfee}\"\n\n\t\tconfig_get_bool vhtmubfee \"$vif\" vhtmubfee\n\t\t[ -n \"$vhtmubfee\" ] && iwpriv \"$ifname\" vhtmubfee \"${vhtmubfee}\"\n\n\t\tconfig_get_bool vhtsubfer \"$vif\" vhtsubfer\n\t\t[ -n \"$vhtsubfer\" ] && iwpriv \"$ifname\" vhtsubfer \"${vhtsubfer}\"\n\n\t\tconfig_get_bool vhtmubfer \"$vif\" vhtmubfer\n\t\t[ -n \"$vhtmubfer\" ] && iwpriv \"$ifname\" vhtmubfer \"${vhtmubfer}\"\n\n\t\tconfig_get bf \"$device\" bf\n\t\tconfig_get hwmode \"$device\" hwmode\n\t\tcase $hwmode in\n\t\t\t# Always enable explicit beamforming for 5 GHz devices\n\t\t\t*a|*na|*ac) bf=1 ;;\n\t\tesac\n\n\t\tif [ \"$bf\" -eq \"0\" ]; then\n\t\t\tiwpriv \"$ifname\" vhtsubfer 0\n\t\t\tiwpriv \"$ifname\" vhtsubfee 0\n\t\telse\n\t\t\tiwpriv \"$ifname\" vhtsubfer 1\n\t\t\tiwpriv \"$ifname\" vhtsubfee 1\n\t\tfi\n\n\t\t# Multi-user MIMO\n\t\tconfig_get_bool mu_mimo \"$device\" mu_mimo 1\n\t\tif [ \"$bf\" -eq \"1\" ] && [ \"$mu_mimo\" -eq \"1\" ]; then\n\t\t\t# Enable Multi-user MIMO\n\t\t\tiwpriv \"$ifname\" vhtmubfer 1\n\t\t\tiwpriv \"$ifname\" vhtmubfee 1\n\t\telse\n\t\t\t# Disable Multi-user MIMO\n\t\t\tiwpriv \"$ifname\" vhtmubfer 0\n\t\t\tiwpriv \"$ifname\" vhtmubfee 0\n\t\tfi\n\n\t\tconfig_get vhtstscap \"$vif\" vhtstscap\n\t\t[ -n \"$vhtstscap\" ] && iwpriv \"$ifname\" vhtstscap \"${vhtstscap}\"\n\n\t\tconfig_get vhtsounddim \"$vif\" vhtsounddim\n\t\t[ -n \"$vhtsounddim\" ] && iwpriv \"$ifname\" vhtsounddim \"${vhtsounddim}\"\n\n\t\tconfig_get encap_type \"$vif\" encap_type\n\t\t[ -n \"$encap_type\" ] && iwpriv \"$ifname\" encap_type \"${encap_type}\"\n\n\t\tconfig_get decap_type \"$vif\" decap_type\n\t\t[ -n \"$decap_type\" ] && iwpriv \"$ifname\" decap_type \"${decap_type}\"\n\n\t\tconfig_get_bool rawsim_txagr \"$vif\" rawsim_txagr\n\t\t[ -n \"$rawsim_txagr\" ] && iwpriv \"$ifname\" rawsim_txagr \"${rawsim_txagr}\"\n\n\t\tconfig_get clr_rawsim_stats \"$vif\" clr_rawsim_stats\n\t\t[ -n \"$clr_rawsim_stats\" ] && iwpriv \"$ifname\" clr_rawsim_stats \"${clr_rawsim_stats}\"\n\n\t\tconfig_get_bool rawsim_debug \"$vif\" rawsim_debug\n\t\t[ -n \"$rawsim_debug\" ] && iwpriv \"$ifname\" rawsim_debug \"${rawsim_debug}\"\n                \n\t\tband_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n\t\tif [ -f /tmp/radardetect.pid ] && [ \"$band_type\" == \"a\" ]; then\n\t\t\t/usr/sbin/radardetect_cli -b\n\t\tfi\n\n\t\tconfig_get_bool vap_only \"$vif\" vap_only 0\n\t\tif [ \"$vap_only\" = \"1\" ]; then\n\t\t\tstart_hostapd=\n\t\telif [ \"$start_hostapd\" = \"\" ]; then\n\t\t\tifconfig \"$ifname\" up\n\t\tfi\n\t\tbrctl addif \"$bridge\" \"$ifname\"\n\t\t#enable hairpin mode\n\t\tbrctl hairpin \"$bridge\" \"$ifname\" on\n\n\t\tconfig_get set_monrxfilter \"$vif\" set_monrxfilter\n\t\t[ -n \"$set_monrxfilter\" ] && iwpriv \"$ifname\" set_monrxfilter \"${set_monrxfilter}\"\n\n\t\tconfig_get neighbourfilter \"$vif\" neighbourfilter\n\t\t[ -n \"$neighbourfilter\" ] && iwpriv \"$ifname\" neighbourfilter \"${neighbourfilter}\"\n\n\t\tconfig_get athnewind \"$vif\" athnewind\n\t\t[ -n \"$athnewind\" ] && iwpriv \"$ifname\" athnewind \"$athnewind\"\n\n\t\tconfig_get osen \"$vif\" osen\n\t\t[ -n \"$osen\" ] && iwpriv \"$ifname\" osen \"$osen\"\n\n\t\tconfig_get ODM \"$device\" ODM\n\n\t\tconfig_get_bool ap_isolation_enabled $device ap_isolation_enabled 0\n\t\tconfig_get_bool isolate \"$vif\" isolate 0\n\n\t\tif [ $ap_isolation_enabled -ne 0 ]; then\n\t\t\t[ \"$mode\" = \"wrap\" ] && isolate=1\n\t\tfi\n\n                config_get_bool ctsprt_dtmbcn \"$vif\" ctsprt_dtmbcn\n                [ -n \"$ctsprt_dtmbcn\" ] && iwpriv \"$ifname\" ctsprt_dtmbcn \"${ctsprt_dtmbcn}\"\n\n\t\tconfig_get assocwar160  \"$vif\" assocwar160\n\t\t[ -n \"$assocwar160\" ] && iwpriv \"$ifname\" assocwar160 \"$assocwar160\"\n\t\t# Force assocwar160 enabled when HT80_80 or HT160 is selected\n\t\t[ \"$htmode\" = \"HT80_80\" -o \"$htmode\" = \"HT160\" ] && iwpriv \"$ifname\" assocwar160 1\n\n\t\tconfig_get rawdwepind \"$vif\" rawdwepind\n\t\t[ -n \"$rawdwepind\" ] && iwpriv \"$ifname\" rawdwepind \"$rawdwepind\"\n\n\t\tconfig_get revsig160  \"$vif\" revsig160\n\t\t[ -n \"$revsig160\" ] && iwpriv \"$ifname\" revsig160 \"$revsig160\"\n\n\t\tif [ \"$ODM\" != \"dni\" ]; then\n\t\t\tlocal net_cfg bridge\n\t\t\tnet_cfg=\"$(find_net_config \"$vif\")\"\n\t\t\t[ -z \"$net_cfg\" -o \"$isolate\" = 1 -a \"$mode\" = \"wrap\" ] || {\n\t\t\t\tbridge=\"$(bridge_interface \"$net_cfg\")\"\n\t\t\t\tconfig_set \"$vif\" bridge \"$bridge\"\n\t\t\t}\n\t\tfi\n\n\t\tcase \"$mode\" in\n\t\t\tap|wrap|ap_monitor|ap_smart_monitor|mesh|ap_lp_iot)\n\n\n\t\t\t\tiwpriv \"$ifname\" ap_bridge \"$((isolate^1))\"\n\n\t\t\t\tconfig_get_bool l2tif \"$vif\" l2tif\n\t\t\t\t[ -n \"$l2tif\" ] && iwpriv \"$ifname\" l2tif \"$l2tif\"\n\n\t\t\t\tif [ -n \"$start_wapid\" ]; then\n\t\t\t\t\twapid_setup_vif \"$vif\" || {\n\t\t\t\t\t\techo \"enable_qcawifi($device): Failed to set up wapid for interface $ifname\" >&2\n\t\t\t\t\t\tifconfig \"$ifname\" down\n\t\t\t\t\t\twlanconfig \"$ifname\" destroy\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tfi\n\n\t\t\t\tif [ -n \"$start_hostapd\" ] && eval \"type hostapd_setup_vif\" 2>/dev/null >/dev/null; then\n\t\t\t\t\thostapd_setup_vif \"$vif\" atheros no_nconfig || {\n\t\t\t\t\t\techo \"enable_qcawifi($device): Failed to set up hostapd for interface $ifname\" >&2\n\t\t\t\t\t\t# make sure this wifi interface won't accidentally stay open without encryption\n\t\t\t\t\t\tifconfig \"$ifname\" down\n\t\t\t\t\t\twlanconfig \"$ifname\" destroy\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tfi\n\t\t\t;;\n\t\t\twds|sta)\n\t\t\t\tif eval \"type wpa_supplicant_setup_vif\" 2>/dev/null >/dev/null; then\n\t\t\t\t\twpa_supplicant_setup_vif \"$vif\" athr || {\n\t\t\t\t\t\techo \"enable_qcawifi($device): Failed to set up wpa_supplicant for interface $ifname\" >&2\n\t\t\t\t\t\tifconfig \"$ifname\" down\n\t\t\t\t\t\twlanconfig \"$ifname\" destroy\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tfi\n\t\t\t;;\n\t\t\tadhoc)\n\t\t\t\tif eval \"type wpa_supplicant_setup_vif\" 2>/dev/null >/dev/null; then\n\t\t\t\t\twpa_supplicant_setup_vif \"$vif\" athr || {\n\t\t\t\t\t\techo \"enable_qcawifi($device): Failed to set up wpa\"\n\t\t\t\t\t\tifconfig \"$ifname\" down\n\t\t\t\t\t\twlanconfig \"$ifname\" destroy\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tfi\n\t\tesac\n\n\t\t[ -z \"$bridge\" -o \"$isolate\" = 1 -a \"$mode\" = \"wrap\" ] || {\n\t\t\tstart_net \"$ifname\" \"$net_cfg\"\n\t\t}\n\n\t\tset_wifi_up \"$vif\" \"$ifname\"\n\n\t\tconfig_get set11NRates \"$vif\" set11NRates\n\t\t[ -n \"$set11NRates\" ] && iwpriv \"$ifname\" set11NRates \"$set11NRates\"\n\n\t\t# 256 QAM capability needs to be parsed first, since\n\t\t# vhtmcs enables/disable rate indices 8, 9 for 2G\n\t\t# only if vht_11ng is set or not\n\t\tconfig_get_bool vht_11ng \"$vif\" vht_11ng\n\t\t[ -n \"$vht_11ng\" ] && {\n\t\t\tiwpriv \"$ifname\" vht_11ng \"$vht_11ng\"\n\t\t\tiwpriv \"$ifname\" 11ngvhtintop \"$vht_11ng\"\n\t\t}\n\n\t\tconfig_get vhtmcs \"$vif\" vhtmcs\n\t\t[ -n \"$vhtmcs\" ] && iwpriv \"$ifname\" vhtmcs \"$vhtmcs\"\n\n\t\t#support nawds\n\t\tconfig_get nawds_mode \"$vif\" nawds_mode\n\t\t[ -n \"$nawds_mode\" ] && wlanconfig \"$ifname\" nawds mode \"${nawds_mode}\"\n\n\t\thandle_nawds() {\n\t\t\tlocal value=\"$1\"\n\t\t\t[ -n \"$value\" ] && wlanconfig \"$ifname\" nawds add-repeater $value\n\t\t}\n\t\tconfig_list_foreach \"$vif\" nawds_add_repeater handle_nawds\n\n\t\thandle_hmwds() {\n\t\t\tlocal value=\"$1\"\n\t\t\t[ -n \"$value\" ] && wlanconfig \"$ifname\" hmwds add_addr $value\n\t\t}\n\t\tconfig_list_foreach \"$vif\" hmwds_add_addr handle_hmwds\n\n\t\tconfig_get nawds_override \"$vif\" nawds_override\n\t\t[ -n \"$nawds_override\" ] && wlanconfig \"$ifname\" nawds override \"${nawds_override}\"\n\n\t\tconfig_get nawds_defcaps \"$vif\" nawds_defcaps\n\t\t[ -n \"$nawds_defcaps\" ] && wlanconfig \"$ifname\" nawds defcaps \"${nawds_defcaps}\"\n\n\t\thandle_hmmc_add() {\n\t\t\tlocal value=\"$1\"\n\t\t\t[ -n \"$value\" ] && wlanconfig \"$ifname\" hmmc add $value\n\t\t}\n\t\tconfig_list_foreach \"$vif\" hmmc_add handle_hmmc_add\n\n\t\t# TXPower settings only work if device is up already\n\t\t# while atheros hardware theoretically is capable of per-vif (even per-packet) txpower\n\t\t# adjustment it does not work with the current atheros hal/madwifi driver\n\n\t\tconfig_get vif_txpower \"$vif\" txpower\n\t\t# use vif_txpower (from wifi-iface) instead of txpower (from wifi-device) if\n\t\t# the latter doesn't exist\n\t\ttxpower=\"${txpower:-$vif_txpower}\"\n\t\t[ -z \"$txpower\" ] || iwconfig \"$ifname\" txpower \"${txpower%%.*}\"\n\n\n\tdone\n\n\t#enable ol statistic in wireless driver\n\tiwpriv \"$phy\" enable_ol_stats 1\n\n\t# update wlan uptime file\n\tfor vif in $vifs; do\n\t\tconfig_get ifname \"$vif\" ifname\n\t\tisup=`ifconfig $ifname | grep UP`\n\t\t[ -n \"$isup\" ] && break\n\tdone\n\tband_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n\tif [ \"$isup\" != \"\" -a \"$band_type\" = \"g\" ]; then\n\t\tcat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime\n\t\techo \"ON\" > /tmp/WLAN_2G_status\n\telif [ \"$isup\" != \"\" -a \"$band_type\" = \"a\" ]; then\n\t\tcat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime_5G\n\t\techo \"ON\" > /tmp/WLAN_5G_status\n\tfi\n\n\t# workaround for guest network cannot up\n\tfor vif in $vifs; do\n\t\tconfig_get ifname \"$vif\" ifname\n\t\tconfig_get mode \"$vif\" mode\n\t\tisup=`ifconfig $ifname | grep UP`\n\t\tno_assoc=`iwconfig $ifname | grep Not-Associated`\n\t\tif [ \"$isup\" != \"\" -a \"$no_assoc\" != \"\" -a \"$mode\" != \"sta\" ]; then\n\t\t\tifconfig \"$ifname\" down\n\t\t\tifconfig \"$ifname\" up\n\t\tfi\n\tdone\n\n\tif [ -f \"/lib/update_smp_affinity.sh\" ]; then\n\t\t. /lib/update_smp_affinity.sh\n\t\tconfig_foreach enable_smp_affinity_wifi wifi-device\n\tfi\n}\n\nwifitoggle_qcawifi()\n{\n    local device=\"$1\"\n    local hw_btn_state=\"$2\"\n    local gui_radio_state=\"$3\"\n\n    find_qcawifi_phy \"$device\" || return 1\n\n    band_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n    config_get vifs \"$device\" vifs\n    for vif in $vifs; do\n        config_get ifname \"$vif\" ifname\n        if [ \"$hw_btn_state\" = \"on\" ]; then\n\t    if [ \"$gui_radio_state\" = \"on\" ] ||\n\t\t[ \"$band_type\" = \"g\" -a \"$gui_radio_state\" = \"g_on\" ] ||\n\t\t[ \"$band_type\" = \"a\" -a \"$gui_radio_state\" = \"a_on\" ]; then\n                config_get mode \"$vif\" mode\n                test -f /var/run/wifi-${ifname}.pid && kill $(cat /var/run/wifi-${ifname}.pid)\n                if [ \"$mode\" = \"ap\" ]; then\n                    test -f /var/run/hostapd_cli-${ifname}.pid && kill $(cat /var/run/hostapd_cli-${ifname}.pid)\n                fi\n                ifconfig \"$ifname\" down\n\t    fi\n        elif [ \"$hw_btn_state\" = \"off\" ]; then\n\t    if [ \"$gui_radio_state\" = \"on\" ] ||\n\t\t[ \"$band_type\" = \"g\" -a \"$gui_radio_state\" = \"g_on\" ] ||\n\t\t[ \"$band_type\" = \"a\" -a \"$gui_radio_state\" = \"a_on\" ]; then\n                isup=`ifconfig $ifname | grep UP`\n                [ -n \"$isup\" ] && continue\n                config_get enc \"$vif\" encryption \"none\"\n                case \"$enc\" in\n                    none)\n                        # If we're in open mode and want to use WPS, we\n                        # must start hostapd\n                        config_get_bool wps_pbc \"$vif\" wps_pbc 0\n                        config_get config_methods \"$vif\" wps_config\n                        [ \"$wps_pbc\" -gt 0 ] && append config_methods push_button\n                        if [ -n \"$config_methods\" ]; then \n                            hostapd_setup_vif \"$vif\" atheros no_nconfig\n                        else\n                            ifconfig \"$ifname\" up\n                        fi\n                        ;;\n                    mixed*|psk*|wpa*)\n                        config_get mode \"$vif\" mode\n                        if [ \"$mode\" = \"ap\" ]; then\n                            hostapd_setup_vif \"$vif\" atheros no_nconfig\n                        else\n                            wpa_supplicant_setup_vif \"$vif\" athr\n                        fi\n                        ;;\n                    *)\n                        ifconfig \"$ifname\" up\n                        ;;\n                esac\n\t    fi\n        fi\n    done\n\n    # update wlan uptime file\n    config_get ifname \"$vif\" ifname\n    isup=`ifconfig $ifname | grep UP`\n    \n    if [ \"$isup\" != \"\" -a \"$band_type\" = \"g\" ]; then\n        cat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime\n        echo \"ON\" > /tmp/WLAN_2G_status\n    elif [ \"$isup\" != \"\" -a \"$band_type\" = \"a\" ]; then\n        cat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime_5G\n        echo \"ON\" > /tmp/WLAN_5G_status\n    elif [ \"$isup\" = \"\" -a \"$band_type\" = \"g\" ]; then\n        rm /tmp/WLAN_uptime\n        echo \"OFF\" > /tmp/WLAN_2G_status\n    elif [ \"$isup\" = \"\" -a \"$band_type\" = \"a\" ]; then\n        rm /tmp/WLAN_uptime_5G\n        echo \"OFF\" > /tmp/WLAN_5G_status\n    fi\n}\n\nwifischedule_qcawifi()\n{\n    local device=\"$1\"\n    local hw_btn_state=\"$2\"\n    local band=\"$3\"\n    local newstate=\"$4\"\n\n    find_qcawifi_phy \"$device\" || return 1\n\n    config_get hwmode \"$device\" hwmode\n    config_get vifs \"$device\" vifs\n    for vif in $vifs; do\n        config_get ifname \"$vif\" ifname\n        if [ \"$newstate\" = \"on\" -a \"$hw_btn_state\" = \"on\" ]; then\n            isup=`ifconfig $ifname | grep UP`\n            [ -n \"$isup\" ] && continue\n            config_get enc \"$vif\" encryption \"none\"\n            case \"$enc\" in\n                none)\n                    # If we're in open mode and want to use WPS, we\n                    # must start hostapd\n                    config_get_bool wps_pbc \"$vif\" wps_pbc 0\n                    config_get config_methods \"$vif\" wps_config\n                    [ \"$wps_pbc\" -gt 0 ] && append config_methods push_button\n                    if [ -n \"$config_methods\" ]; then\n                        hostapd_setup_vif \"$vif\" atheros no_nconfig\n                    else\n                        ifconfig \"$ifname\" up\n                    fi\n                    ;;\n                mixed*|psk*|wpa*)\n                    hostapd_setup_vif \"$vif\" atheros no_nconfig\n                    ;;\n                *)\n                    ifconfig \"$ifname\" up\n                    ;;\n            esac\n            if [ \"$((`grep -c g_device /etc/ath/wifi.conf`+`grep -c a_device /etc/ath/wifi.conf`))\" = \"1\" ]; then\n\t        logger \"[Wireless signal schedule] The wireless signal is ON,\"\n            else\n                case \"$hwmode\" in\n                    *b|*g|*ng) logger \"[Wireless signal schedule] The wireless 2.4GHz signal is ON,\";;\n                    *a|*na|*ac) logger \"[Wireless signal schedule] The wireless 5GHz signal is ON,\" ;;\n                esac\n            fi\n        else\n            test -f /var/run/wifi-${ifname}.pid && kill $(cat /var/run/wifi-${ifname}.pid)\n            test -f /var/run/hostapd_cli-${ifname}.pid && kill $(cat /var/run/hostapd_cli-${ifname}.pid)\n            ifconfig \"$ifname\" down\n            if [ \"$((`grep -c g_device /etc/ath/wifi.conf`+`grep -c a_device /etc/ath/wifi.conf`))\" = \"1\" ]; then\n                logger \"[Wireless signal schedule] The wireless signal is OFF,\"\n            else\n                case \"$hwmode\" in\n                    *b|*g|*ng) logger \"[Wireless signal schedule] The wireless 2.4GHz signal is OFF,\";;\n                    *a|*na|*ac) logger \"[Wireless signal schedule] The wireless 5GHz signal is OFF,\" ;;\n                esac\n            fi\n        fi\n    done\n\n    # update wlan uptime file\n    config_get ifname \"$vif\" ifname\n    isup=`ifconfig $ifname | grep UP`\n    \n    band_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n    if [ \"$isup\" != \"\" -a \"$band_type\" = \"g\" ]; then\n        cat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime\n        echo \"ON\" > /tmp/WLAN_2G_status\n    elif [ \"$isup\" != \"\" -a \"$band_type\" = \"a\" ]; then\n        cat /proc/uptime | sed 's/ .*//' > /tmp/WLAN_uptime_5G\n        echo \"ON\" > /tmp/WLAN_5G_status\n    elif [ \"$isup\" = \"\" -a \"$band_type\" = \"g\" ]; then\n        rm /tmp/WLAN_uptime\n        echo \"OFF\" > /tmp/WLAN_2G_status\n    elif [ \"$isup\" = \"\" -a \"$band_type\" = \"a\" ]; then\n        rm /tmp/WLAN_uptime_5G\n        echo \"OFF\" > /tmp/WLAN_5G_status\n    fi\n}\n\nwifistainfo_qcawifi()\n{\n    local device=\"$1\"\n\n    find_qcawifi_phy \"$device\" || return 1\n\n    tmpfile=/tmp/sta_info.$$\n    touch $tmpfile\n\n    config_get vifs \"$device\" vifs\n    for vif in $vifs; do\n        config_get ifname \"$vif\" ifname\n        wlanconfig \"$ifname\" list sta >> $tmpfile\n        band_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy  | cut -d_ -f1`\n        if [ \"$band_type\" = \"g\" ]; then\n            echo $vif | grep 'guest' > /dev/null 2>&1\n            if [ \"$?\" -eq \"1\" ]; then\n                echo \"###2.4G###\"\n            else\n                echo \"###2.4G Guest###\"\n            fi\n        else\n            echo $vif | grep 'guest' > /dev/null 2>&1\n            if [ \"$?\" -eq \"1\" ]; then\n                echo \"###5G###\"\n            else\n                echo \"###5G Guest###\"\n            fi\n        fi\n        [ -f /usr/lib/stainfo.awk ] && awk -f /usr/lib/stainfo.awk $tmpfile\n        rm $tmpfile\n        echo \"\"\n    done\n}\n\nwifiradio_qcawifi()\n{\n    local device=$1\n\n    config_get vifs \"$device\" vifs\n\n    shift\n    while [ \"$#\" -gt \"0\" ]; do\n        case $1 in\n            -s|--status)\n                for vif in $vifs; do\n                    config_get ifname \"$vif\" ifname\n                    isup=`ifconfig $ifname | grep UP`\n                done\n                [ -n \"$isup\" ] && echo \"ON\" || echo \"OFF\"\n                shift\n                ;;\n            -c|--channel)\n                for vif in $vifs; do\n                    config_get ifname \"$vif\" ifname\n                    isap=`iwconfig $ifname | grep Master`\n                    [ -z \"$isap\" ] && continue\n                    p_chan=`iwlist $ifname chan | grep Current | awk '{printf \"%d\\n\", substr($5,1,length($5))}'`\n                    cur_mode=`iwpriv $ifname g_dni_curmode | cut -d: -f2`\n                    is_20=`echo $cur_mode | grep '20'`\n                    is_plus=`echo $cur_mode | grep 'PLUS'`\n                    is_minus=`echo $cur_mode | grep 'MINUS'`\n                    is_80=`echo $cur_mode | grep '80'`\n\n                    # when enable wla_ht160, need change mode to HT160 for EU and HT80_80 for NA.\n                    # EU use channel \"36+40+44+48+52+56+60+64\" or \"100+104+108+112+116+120+124+128\"\n                    # NA use channel \"36+40+44+48+149+153+157+161\"\n                    is_80_80=`echo $cur_mode | grep '80_80'`\n                    is_160=`echo $cur_mode | grep '160'`\n\n                    if [ -n \"$is_20\" ]; then\n                        chan=$p_chan\n                    elif [ -n \"$is_plus\" ]; then\n                        s_chan=$(($p_chan + 4));\n                        chan=\"${p_chan}(p) + ${s_chan}(s)\"\n                    elif [ -n \"$is_minus\" ]; then\n                        s_chan=$(($p_chan - 4));\n                        chan=\"${s_chan}(s) + ${p_chan}(p)\"\n                    elif [ -z \"$is_80_80\" -a -n \"$is_80\" ]; then\n                        case \"${p_chan}\" in\n                            36) chan=\"36(p) + 40 + 44 + 48\" ;;\n                            40) chan=\"36 + 40(p) + 44 + 48\" ;;\n                            44) chan=\"36 + 40 + 44(p) + 48\" ;;\n                            48) chan=\"36 + 40 + 44 + 48(p)\" ;;\n                            52) chan=\"52(p) + 56 + 60 + 64\" ;;\n                            56) chan=\"52 + 56(p) + 60 + 64\" ;;\n                            60) chan=\"52 + 56 + 60(p) + 64\" ;;\n                            64) chan=\"52 + 56 + 60 + 64(p)\" ;;\n                            100) chan=\"100(p) + 104 + 108 + 112\" ;;\n                            104) chan=\"100 + 104(p) + 108 + 112\" ;;\n                            108) chan=\"100 + 104 + 108(p) + 112\" ;;\n                            112) chan=\"100 + 104 + 108 + 112(p)\" ;;\n                            116) chan=\"116(p) + 120 + 124 + 128\" ;;\n                            120) chan=\"116 + 120(p) + 124 + 128\" ;;\n                            124) chan=\"116 + 120 + 124(p) + 128\" ;;\n                            128) chan=\"116 + 120 + 124 + 128(p)\" ;;\n                            149) chan=\"149(p) + 153 + 157 + 161\";;\n                            153) chan=\"149 + 153(p) + 157 + 161\";;\n                            157) chan=\"149 + 153 + 157(p) + 161\";;\n                            161) chan=\"149 + 153 + 157 + 161(p)\";;\n                        esac\n                    elif [ -n \"$is_80_80\" ]; then\n                        case \"${p_chan}\" in\n                            132) chan=\"132(p) + 136 + 140 + 144 + 149 + 153 + 157 + 161\" ;;\n                            136) chan=\"132 + 136(p) + 140 + 144 + 149 + 153 + 157 + 161\" ;;\n                            140) chan=\"132 + 136 + 140(p) + 144 + 149 + 153 + 157 + 161\" ;;\n                            144) chan=\"132 + 136 + 140 + 144(p) + 149 + 153 + 157 + 161\" ;;\n                            149) chan=\"132 + 136 + 140 + 144 + 149(p) + 153 + 157 + 161\" ;;\n                            153) chan=\"132 + 136 + 140 + 144 + 149 + 153(p) + 157 + 161\" ;;\n                            157) chan=\"132 + 136 + 140 + 144 + 149 + 153 + 157(p) + 161\" ;;\n                            161) chan=\"132 + 136 + 140 + 144 + 149 + 153 + 157 + 161(p)\" ;;\n                         esac\n                    elif [ -n \"$is_160\" ]; then\n                        case \"${p_chan}\" in\n                            36) chan=\"36(p) + 40 + 44 + 48 + 52 + 56 + 60 + 64\" ;;\n                            40) chan=\"36 + 40(p) + 44 + 48 + 52 + 56 + 60 + 64\" ;;\n                            44) chan=\"36 + 40 + 44(p) + 48 + 52 + 56 + 60 + 64\" ;;\n                            48) chan=\"36 + 40 + 44 + 48(p) + 52 + 56 + 60 + 64\" ;;\n                            52) chan=\"36 + 40 + 44 + 48 + 52(p) + 56 + 60 + 64\" ;;\n                            56) chan=\"36 + 40 + 44 + 48 + 52 + 56(p) + 60 + 64\" ;;\n                            60) chan=\"36 + 40 + 44 + 48 + 52 + 56 + 60(p) + 64\" ;;\n                            64) chan=\"36 + 40 + 44 + 48 + 52 + 56 + 60 + 64(p)\" ;;\n                            100) chan=\"100(p) + 104 + 108 + 112 + 116 + 120 + 124 + 128\" ;;\n                            104) chan=\"100 + 104(p) + 108 + 112 + 116 + 120 + 124 + 128\" ;;\n                            108) chan=\"100 + 104 + 108(p) + 112 + 116 + 120 + 124 + 128\" ;;\n                            112) chan=\"100 + 104 + 108 + 112(p) + 116 + 120 + 124 + 128\" ;;\n                            116) chan=\"100 + 104 + 108 + 112 + 116(p) + 120 + 124 + 128\" ;;\n                            120) chan=\"100 + 104 + 108 + 112 + 116 + 120(p) + 124 + 128\" ;;\n                            124) chan=\"100 + 104 + 108 + 112 + 116 + 120 + 124(p) + 128\" ;;\n                            128) chan=\"100 + 104 + 108 + 112 + 116 + 120 + 124 + 128(p)\" ;;\n                        esac\n                    else\n                        chan=$p_chan\n                    fi\n                    echo \"$chan\"\n                    break;\n                done\n                shift\n                ;;\n            --coext)\n                for vif in $vifs; do\n                    config_get ifname \"$vif\" ifname\n                    isap=`iwconfig $ifname | grep Master`\n                    [ -z \"$isap\" ] && continue\n                    if [ \"$2\" = \"on\" ]; then\n                        iwpriv $ifname disablecoext 0\n                        iwpriv $ifname extbusythres 10\n                    else\n                        iwpriv $ifname disablecoext 1\n                        iwpriv $ifname extbusythres 100\n                    fi\n                done\n                shift 2\n                ;;\n            *)\n                shift\n                ;;\n        esac\n    done\n}\n\nwps_qcawifi()\n{\n    local device=$1\n    local hostapd_if=/var/run/hostapd-${device}\n    local supplicant_if=var/run/wpa_supplicant-${device}\n\n    config_get vifs \"$device\" vifs\n    vif=`echo $vifs | cut -d\" \" -f1`\n\n    shift\n    while [ \"$#\" -gt \"0\" ]; do\n        case $1 in\n            -c|--client_pin)\n                    config_get ifname \"$vif\" ifname\n                    [ -e \"$hostapd_if/$ifname\" ] && {\n                        hostapd_cli -i \"$ifname\" -p \"$hostapd_if\" wps_cancel\n                        sleep 1\n                        hostapd_cli -i \"$ifname\" -p \"$hostapd_if\" wps_pin any $2\n                    }\n                shift 2\n                ;;\n            -p|--pbc_start)\n                    config_get ifname \"$vif\" ifname\n                    [ -e \"$hostapd_if/$ifname\" ] && {\n                        hostapd_cli -i \"$ifname\" -p \"$hostapd_if\" wps_cancel\n                        sleep 1\n                        hostapd_cli -i \"$ifname\" -p \"$hostapd_if\" wps_pbc\n                    }\n                    [ -e \"$supplicant_if/$ifname\" ] && {\n                        wpa_cli -i \"$ifname\" -p \"$hostapd_if\" wps_cancel\n                        sleep 1\n                        wpa_cli -i \"$ifname\" -p \"$hostapd_if\" wps_pbc\n                    }\n                shift\n                ;;\n            -s|--wps_stop)\n                    config_get ifname \"$vif\" ifname\n                    [ -e \"$hostapd_if/$ifname\" ] && hostapd_cli -i \"$ifname\" -p \"$hostapd_if\" wps_cancel\n                    [ -e \"$supplicant_if/$ifname\" ] && wpa_cli -i \"$ifname\" -p \"$hostapd_if\" wps_cancel\n                shift\n                ;;\n            *)\n                shift\n                ;;\n        esac\n    done\n}\n\nwifitrfled_qcawifi()\n{\n    local device=$1\n    local led_option=$2\n\n    [ \"$device\" != \"wifi0\" ] && return\n\n    if [ \"$led_option\" = \"0\" ]; then\n        echo 1 > /proc/sys/qca_dni/blink_2g_led\n    elif [ \"$led_option\" = \"1\" ]; then\n        echo 0 > /proc/sys/qca_dni/blink_2g_led\n    elif [ \"$led_option\" = \"2\" ]; then\n        echo 0 > /proc/sys/qca_dni/blink_2g_led\n        /usr/sbin/iwpriv wifi0 gpio_output 1 1\n    fi\n}\n\nstatistic_qcawifi()\n{\n    local device=$1\n\n    find_qcawifi_phy \"$device\" || return 1\n\n    ifconfig $1 > /dev/null 2>&1\n    if [ \"$?\" = \"0\" ]; then\n        tx_packets=`athstats -i $1 | grep 'ast_tx_packets' | cut -f 2`\n        rx_packets=`athstats -i $1 | grep 'ast_rx_packets' | cut -f 2`\n        collisions=0\n        tx_bytes=`athstats -i $1 | grep 'ast_tx_bytes' | cut -f 2`\n        rx_bytes=`athstats -i $1 | grep 'ast_rx_bytes' | cut -f 2`\n\n        band_type=`grep \"^[ga]_device\" /etc/ath/wifi.conf | grep $phy | cut -d_ -f1`\n        if [ \"$band_type\" = \"g\" ]; then\n            echo \"###2.4G###\"\n        else\n            echo \"###5G###\"\n        fi\n        echo \"TX packets:$tx_packets\"\n        echo \"RX packets:$rx_packets\"\n        echo \"collisons:$collisions\"\n        echo \"TX bytes:$tx_bytes\"\n        echo \"RX bytes:$rx_bytes\"\n        echo \"\"\n    fi\n}\n\nqwrap_stop() {\n\tlocal device=$1\n\tlocal ifidx=0\n\tlocal radioidx=${device#wifi}\n\n\tconfig_get qwrap_enable \"$device\" qwrap_enable 0\n\n\t[ \"$qwrap_enable\" -gt 0 ] || return\n\n\tconfig_get vifs $device vifs\n\n\tfor vif in $vifs; do\n\n\t\tconfig_get mode \"$vif\" mode\n\n\t\tcase \"$mode\" in\n\t\t\twrap)\n\t\t\t\tconfig_load network\n\t\t\t\tnet_cfg=\"$(find_net_config \"$vif\")\"\n\n\t\t\t\t[ -z \"$net_cfg\" ] || {\n\n\t\t\t\t\tbridge=\"$(bridge_interface \"$net_cfg\")\"\n\t\t\t\t\tcd /sys/class/net/${bridge}/brif\n\n\t\t\t\t\tfor eth in $(ls -d eth* 2>&-); do\n\t\t\t\t\t\tbr_macaddr=\"$(cat /sys/class/net/${eth}/address)\"\n\t\t\t\t\t\t[ -n \"$br_macaddr\" ] && break\n\t\t\t\t\tdone\n\n\t\t\t\t\tifconfig \"$bridge\" hw ether \"$br_macaddr\"\n\t\t\t\t}\n\t\t\t;;\n\t\tesac\n\n\t\tifidx=$(($ifidx + 1))\n\n\tdone\n\n\tkill \"$(cat \"/var/run/wrapd-$device.pid\")\"\n\n\tkill \"$(cat \"/var/run/wpa_supplicant-qwrap-$device.pid\")\"\n\n\t[ -f \"/tmp/qwrap_conf_filename\" ] &&\n\t\trm /tmp/qwrap_conf_filename\n\n\t[ -f \"/var/run/wrapd-global-$device\" ] &&\n\t\trm -rf /var/run/wrapd-global-$device\n\n\t[ -f \"/var/run/wpa_supplicant-global-$device\" ] &&\n\t\trm -rf /var/run/wpa_supplicant-global-$device\n}\n\nsetup_wps_enhc() {\n\tlocal device=$1\n\tlocal wps_enhc_cfg=\n\n\tconfig_get_bool wps_pbc_try_sta_always \"$device\" wps_pbc_try_sta_always 0\n\tconfig_get_bool wps_pbc_skip_ap_if_sta_disconnected \"$device\" wps_pbc_skip_ap_if_sta_disconnected 0\n\tconfig_get_bool wps_pbc_overwrite_ap_settings \"$device\" wps_pbc_overwrite_ap_settings 0\n\t[ $wps_pbc_try_sta_always -ne 0 ] && \\\n\t\t\tappend wps_enhc_cfg \"$device:try_sta_always\" \"$N\"\n\t[ $wps_pbc_skip_ap_if_sta_disconnected -ne 0 ] && \\\n\t\t\tappend wps_enhc_cfg \"$device:skip_ap_if_sta_disconnected\" \"$N\"\n\t[ $wps_pbc_overwrite_ap_settings -ne 0 ] && \\\n\t\t\tappend wps_enhc_cfg \"$device:overwrite_ap_settings\" \"$N\"\n\n\tconfig_get vifs $device vifs\n\n\tfor vif in $vifs; do\n\t\tconfig_get ifname \"$vif\" ifname\n\n\t\tconfig_get_bool wps_pbc_enable \"$vif\" wps_pbc_enable 0\n\t\tconfig_get wps_pbc_start_time \"$vif\" wps_pbc_start_time\n\t\tconfig_get wps_pbc_duration \"$vif\" wps_pbc_duration\n\t\tif [ $wps_pbc_enable -ne 0 ]; then\n\t\t\t[ -n \"$wps_pbc_start_time\" -a -n \"$wps_pbc_duration\" ] && \\\n\t\t\t\t\tappend wps_enhc_cfg \"$ifname:$wps_pbc_start_time:$wps_pbc_duration:$device\" \"$N\"\n\t\tfi\n\tdone\n\n\tcat >> /var/run/wifi-wps-enhc-extn.conf <<EOF\n$wps_enhc_cfg\nEOF\n}\n\nqcawifi_start_hostapd_cli() {\n\tlocal device=$1\n\tlocal ifidx=0\n\tlocal radioidx=${device#wifi}\n\n\tconfig_get vifs $device vifs\n\n\tfor vif in $vifs; do\n\t\tlocal config_methods vifname\n\n\t\tconfig_get vifname \"$vif\" ifname\n\n\t\tif [ -n $vifname ]; then\n\t\t\t[ $ifidx -gt 0 ] && vifname=\"ath${radioidx}$ifidx\" || vifname=\"ath${radioidx}\"\n\t\tfi\n\n\t\tconfig_get_bool wps_pbc \"$vif\" wps_pbc 0\n\t\tconfig_get config_methods \"$vif\" wps_config\n\t\t[ \"$wps_pbc\" -gt 0 ] && append config_methods push_button\n\n\t\tif [ -n \"$config_methods\" ]; then\n\t\t\tpid=/var/run/hostapd_cli-$vifname.pid\n\t\t\thostapd_cli -i $vifname -P $pid -a /lib/wifi/wps-hostapd-update-uci -p /var/run/hostapd-$device -B\n\t\tfi\n\n\t\tifidx=$(($ifidx + 1))\n\tdone\n}\n\npre_qcawifi() {\n\tlocal action=${1}\n\n\tconfig_load wireless\n\n\tcase \"${action}\" in\n\t\tdisable)\n\t\t\tconfig_get_bool wps_vap_tie_dbdc qcawifi wps_vap_tie_dbdc 0\n\n\t\t\tif [ $wps_vap_tie_dbdc -ne 0 ]; then\n\t\t\t\tkill \"$(cat \"/var/run/hostapd.pid\")\"\n\t\t\t\t[ -f \"/tmp/hostapd_conf_filename\" ] &&\n\t\t\t\t\trm /tmp/hostapd_conf_filename\n\t\t\tfi\n\n\t\t\teval \"type qwrap_teardown\" >/dev/null 2>&1 && qwrap_teardown\n\t\t\teval \"type icm_teardown\" >/dev/null 2>&1 && icm_teardown\n\t\t\teval \"type wpc_teardown\" >/dev/null 2>&1 && wpc_teardown\n\t\t\t[ ! -f /etc/init.d/lbd ] || /etc/init.d/lbd stop\n\t\t\t[ ! -f /etc/init.d/ssid_steering ] || /etc/init.d/ssid_steering stop\n\t\t\t[ ! -f /etc/init.d/mcsd ] || /etc/init.d/mcsd stop\n\n\t\t\trm -f /var/run/wifi-wps-enhc-extn.conf\n\t\t\t[ -r /var/run/wifi-wps-enhc-extn.pid ] && kill \"$(cat \"/var/run/wifi-wps-enhc-extn.pid\")\"\n\t\t;;\n\tesac\n}\n\npost_qcawifi() {\n\tlocal action=${1}\n\n\tcase \"${action}\" in\n\t\tenable)\n\t\t\tlocal icm_enable qwrap_enable\n\n\t\t\t# Run a single hostapd instance for all the radio's\n\t\t\t# Enables WPS VAP TIE feature\n\n\t\t\tconfig_get_bool wps_vap_tie_dbdc qcawifi wps_vap_tie_dbdc 0\n\n\t\t\tif [ $wps_vap_tie_dbdc -ne 0 ]; then\n\t\t\t\thostapd_conf_file=$(cat \"/tmp/hostapd_conf_filename\")\n\t\t\t\thostapd -P /var/run/hostapd.pid $hostapd_conf_file -B\n\t\t\t\tconfig_foreach qcawifi_start_hostapd_cli wifi-device\n\t\t\tfi\n\n\t\t\tconfig_get_bool icm_enable icm enable 0\n\t\t\t[ ${icm_enable} -gt 0 ] && \\\n\t\t\t\t\teval \"type icm_setup\" >/dev/null 2>&1 && {\n\t\t\t\ticm_setup\n\t\t\t}\n\n\t\t\tconfig_get_bool wpc_enable wpc enable 0\n\t\t\t[ ${wpc_enable} -gt 0 ] && \\\n\t\t\t\t\teval \"type wpc_setup\" >/dev/null 2>&1 && {\n\t\t\t\twpc_setup\n\t\t\t}\n\n\t\t\teval \"type qwrap_setup\" >/dev/null 2>&1 && qwrap_setup\n\n\t\t\t# The init script will check whether lbd is actually\n\t\t\t# enabled\n\t\t\t[ ! -f /etc/init.d/lbd ] || /etc/init.d/lbd start\n\n\t\t\tshift\n\t\t\twl_lan_restricted_access $@\n\n\t\t\t[ ! -f /etc/init.d/ssid_steering ] || /etc/init.d/ssid_steering start\n\n\t\t\tconfig_get_bool wps_pbc_extender_enhance qcawifi wps_pbc_extender_enhance 0\n\t\t\t[ ${wps_pbc_extender_enhance} -ne 0 ] && { \\\n\t\t\t\trm -f /var/run/wifi-wps-enhc-extn.conf\n\t\t\t\tconfig_foreach setup_wps_enhc wifi-device\n\t\t\t}\n\t\t;;\n\tesac\n}\n\ncheck_qcawifi_device() {\n\t[ ${1%[0-9]} = \"wifi\" ] && config_set \"$1\" phy \"$1\"\n\tconfig_get phy \"$1\" phy\n\t[ -z \"$phy\" ] && {\n\t\tfind_qcawifi_phy \"$1\" >/dev/null || return 1\n\t\tconfig_get phy \"$1\" phy\n\t}\n\t[ \"$phy\" = \"$dev\" ] && found=1\n}\n\n\ndetect_qcawifi() {\n\tlocal ODM=$1\n\tlocal noinsert=$2\n\tdevidx=0\n\t[ \"$ODM\" = \"dni\" -a \"$noinsert\" = \"1\" ] || load_qcawifi\n\tconfig_load wireless\n\twhile :; do\n\t\tconfig_get type \"wifi$devidx\" type\n\t\t[ -n \"$type\" ] || break\n\t\tdevidx=$(($devidx + 1))\n\tdone\n\tcd /sys/class/net\n\t[ -d wifi0 ] || return\n\tfor dev in $(ls -d wifi* 2>&-); do\n\t\tfound=0\n\t\tconfig_foreach check_qcawifi_device wifi-device\n\t\t[ \"$found\" -gt 0 ] && continue\n\n\t\thwcaps=$(cat ${dev}/hwcaps)\n\t\tcase \"${hwcaps}\" in\n\t\t\t*11bgn) mode_11=ng;;\n\t\t\t*11abgn) mode_11=ng;;\n\t\t\t*11an) mode_11=na;;\n\t\t\t*11an/ac) mode_11=ac;;\n\t\t\t*11abgn/ac) mode_11=ac;;\n\t\tesac\n\n\t\tcat <<EOF\nconfig wifi-device  wifi$devidx\n\toption type\tqcawifi\n\toption channel\tauto\n\toption macaddr\t$(cat /sys/class/net/${dev}/address)\n\toption hwmode\t11${mode_11}\n\t# REMOVE THIS LINE TO ENABLE WIFI:\n\toption disabled 1\n\nconfig wifi-iface\n\toption device\twifi$devidx\n\toption network\tlan\n\toption mode\tap\n\toption ssid\tOpenWrt\n\toption encryption none\n\nEOF\n\tdevidx=$(($devidx + 1))\n\tdone\n}\n\nwl_lan_restricted_access()\n{\n    devices=$@\n    inited=0\n    ETH_P_ARP=0x0806\n    ETH_P_RARP=0x8035\n    ETH_P_IP=0x0800\n    ETH_P_IPv6=0x86dd\n    IPPROTO_ICMP=1\n    IPPROTO_UDP=17\n    IPPROTO_ICMPv6=58\n    DHCPS_DHCPC=67:68\n    DHCP6S_DHCP6C=546:547\n    PORT_DNS=53\n\n    if ! eval \"type ebtables\" 2>>/dev/null >/dev/null; then\n        echo \"Please install tool ebtables first\"\n        return\n    fi\n    ebtables -D FORWARD -p \"$ETH_P_ARP\" -j ACCEPT\n    ebtables -D FORWARD -p \"$ETH_P_RARP\" -j ACCEPT\n    ebtables -D FORWARD -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$PORT_DNS\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_ICMPv6\" --ip6-icmp-type ! echo-request -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$DHCP6S_DHCP6C\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$PORT_DNS\" -j ACCEPT\n    ebtables -L | grep  \"ath\" > /tmp/wifi_rules\n    while read loop\n    do\n        ebtables -D INPUT \"$loop\";\n        ebtables -D FORWARD \"$loop\";\n    done < /tmp/wifi_rules\n    rm  /tmp/wifi_rules\n\n    for device in ${devices}; do\n\tconfig_get vifs \"$device\" vifs\n\tfor vif in $vifs; do\n            config_get_bool lan_restricted \"$vif\" lan_restricted\n            if [ \"$lan_restricted\" = \"1\" -a \"$inited\" = \"0\" ]; then\n                ebtables -P FORWARD ACCEPT\n                ebtables -A FORWARD -p \"$ETH_P_ARP\" -j ACCEPT\n                ebtables -A FORWARD -p \"$ETH_P_RARP\" -j ACCEPT\n                ebtables -A FORWARD -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n                ebtables -P INPUT ACCEPT\n                ebtables -A INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n                ebtables -A INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$PORT_DNS\" -j ACCEPT\n                ebtables -A INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_ICMPv6\" --ip6-icmp-type ! echo-request -j ACCEPT\n                ebtables -A INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$DHCP6S_DHCP6C\" -j ACCEPT\n                ebtables -A INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$PORT_DNS\" -j ACCEPT\n                inited=1\n            fi\n        done\n    done\n\n    for device in ${devices}; do\n        config_get vifs \"$device\" vifs\n        for vif in $vifs; do\n            config_get_bool lan_restricted \"$vif\" lan_restricted\n            if [ \"$lan_restricted\" = \"1\" ]; then\n                config_get ifname \"$vif\" ifname\n                config_get lan_ipaddr \"$vif\" lan_ipaddr\n                config_get bridge \"$vif\" bridge\n                lan_ipv6addr=$(ifconfig $bridge | grep Scope:Link | awk '{print $3}' | awk -F '/' '{print $1}')\n                ebtables -A FORWARD -i \"$ifname\" -j DROP\n                ebtables -A FORWARD -o \"$ifname\" -j DROP\n                ebtables -A INPUT -i \"$ifname\" -p \"$ETH_P_IP\" --ip-dst \"$lan_ipaddr\" -j DROP\n                ebtables -A INPUT -i \"$ifname\" -p \"$ETH_P_IPv6\" --ip6-dst \"$lan_ipv6addr\" -j DROP\n            fi\n        done\n    done\n}\n\nclear_wifi_ebtables()\n{\n    ETH_P_ARP=0x0806\n    ETH_P_RARP=0x8035\n    ETH_P_IP=0x0800\n    ETH_P_IPv6=0x86dd\n    IPPROTO_ICMP=1\n    IPPROTO_UDP=17\n    IPPROTO_ICMPv6=58\n    DHCPS_DHCPC=67:68\n    DHCP6S_DHCP6C=546:547\n    PORT_DNS=53\n\n    if ! eval \"type ebtables\" 2>>/dev/null >/dev/null; then\n        echo \"Please install tool ebtables first\"\n        return\n    fi\n    ebtables -D FORWARD -p \"$ETH_P_ARP\" -j ACCEPT\n    ebtables -D FORWARD -p \"$ETH_P_RARP\" -j ACCEPT\n    ebtables -D FORWARD -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$DHCPS_DHCPC\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IP\" --ip-proto \"$IPPROTO_UDP\" --ip-dport \"$PORT_DNS\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_ICMPv6\" --ip6-icmp-type ! echo-request -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$DHCP6S_DHCP6C\" -j ACCEPT\n    ebtables -D INPUT -p \"$ETH_P_IPv6\" --ip6-proto \"$IPPROTO_UDP\" --ip6-dport \"$PORT_DNS\" -j ACCEPT\n    ebtables -L | grep  \"ath\" > /tmp/wifi_rules\n    while read loop\n    do\n        ebtables -D INPUT $loop;\n        ebtables -D FORWARD $loop;\n    done < /tmp/wifi_rules\n    rm  /tmp/wifi_rules\n}\n\n", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已分析了 'qcawifi.sh' 文件的内容。这是一个用于管理 QCA WiFi 驱动的 shell 脚本。我专注于识别不可信输入点、数据流追踪、组件交互和可利用的漏洞链。脚本主要通过 UCI 配置获取输入，并使用这些输入构建参数传递给命令如 iwpriv、iwconfig、wlanconfig 和 insmod。虽然存在多个配置输入点，但变量通常被引用使用，降低了命令注入风险。我未找到从不可信输入到危险操作的完整、可验证的攻击链。所有配置输入需要特权访问（如通过 Web 接口），且缺乏证据表明输入能导致实际可利用的漏洞（如命令注入或内核参数注入）。因此，我无法报告任何高风险发现。\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": \"基于对 'qcawifi.sh' 文件的深入分析，我未识别出任何完整、可行且实际可利用的攻击链。以下是详细分析结果：\\n\\n### 输入点识别\\n- **潜在不可信输入源**：脚本通过 UCI 配置获取输入，使用 `config_get` 和 `config_get_bool` 命令。这些配置可能来自网络接口（如 Web 接口）、NVRAM 或环境变量，但脚本本身在本地执行，需要特权访问。\\n- **具体输入点**：包括 `country`、`channel`、`txpower`、`vow_config` 等众多配置参数，用于构建命令行参数。\\n\\n### 数据流追踪\\n- **数据传播路径**：配置值被直接用于命令执行（如 `iwpriv`、`insmod`），但变量通常被引用（例如 `iwpriv \\\"$phy\\\" setCountryID \\\"$country\\\"`），减少了命令注入风险。\\n- **验证缺失**：脚本未对输入进行显式验证或过滤，但依赖二进制工具（如 `iwpriv`）处理输入。缺乏证据表明这些工具易受攻击。\\n\\n### 组件交互分析\\n- **组件交互**：脚本与内核模块（通过 `insmod`）、网络接口（通过 `ifconfig`、`iwconfig`）和桥接（通过 `brctl`）交互。外部数据通过配置影响这些组件，但交互是受控的。\\n\\n### 利用链评估\\n- **未发现完整攻击链**：尽管配置输入可能被恶意控制，但未找到从输入点到危险操作（如代码执行或权限提升）的完整路径。例如：\\n  - 在 `load_qcawifi` 函数中，`umac_args` 和 `adf_args` 由配置构建并用于 `insmod`，但缺乏证据表明内核模块参数注入可利用。\\n  - 在 `enable_qcawifi` 函数中，`country` 等参数直接传递给 `iwpriv`，但 `iwpriv` 是二进制工具，可能安全处理输入。\\n- **触发条件**：攻击者需能修改 UCI 配置（通常需特权），但即使如此，未验证输入会导致实际漏洞。\\n- **可利用性分析**：无证据表明缺少清理或逻辑缺陷可被利用；变量引用和工具设计可能 mitigating 风险。\\n\\n### 最终输出\\n- **无高风险发现**：所有潜在问题理论上的，缺乏完整证据链。风险评分低于 7.0，因此不报告具体发现。\\n- **建议**：后续分析可结合二进制工具（如 `iwpriv`、内核模块）以验证输入处理安全性。\\n\\n总结：在当前分析范围内，未发现实际可利用的漏洞。\"\n  },\n  \"status\": \"complete\"\n}"}
