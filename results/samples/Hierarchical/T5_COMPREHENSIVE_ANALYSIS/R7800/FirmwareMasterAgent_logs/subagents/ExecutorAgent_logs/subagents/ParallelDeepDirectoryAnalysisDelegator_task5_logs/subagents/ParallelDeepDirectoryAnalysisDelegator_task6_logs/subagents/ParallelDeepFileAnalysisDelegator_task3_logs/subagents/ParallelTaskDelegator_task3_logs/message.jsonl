{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（3.4.103）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 '3.4.103' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: FunctionDelegator\n  Description: \n    函数分析委托器 - 专门分析二进制文件中函数调用链的代理。它的职责是正向追踪函数调用之间的污点数据流。你可以将潜在的外部入口点委托给此代理进行深入追踪。\n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"task\": {\n            \"type\": \"string\",\n            \"description\": \"为子函数创建分析任务时，你的描述必须清楚地包括以下四点：\\n1. **目标函数**：要分析的子函数的名称和地址。\\n2. **污点入口**：污点在子函数中所在的特定寄存器或栈地址（例如，'污点在第一个参数寄存器 r0 中'）。\\n3. **污点来源**：这个污点数据在父函数中是如何产生的（例如，'这个值是父函数 main 通过调用 nvram_get(\\\"lan_ipaddr\\\") 获取的'）。\\n4. **分析目标**：清楚地指出新任务应该追踪这个新的污点入口（例如，'在子函数内追踪 r0'）。\"\n          },\n          \"task_context\": {\n            \"type\": \"string\",\n            \"description\": \"（可选）提供可能影响分析的补充上下文。这些信息不是污点流本身的一部分，但可能影响子函数的执行路径。例如：\\n- '此时寄存器 r2 的值为 0x500，表示最大缓冲区长度。'\\n- '在此调用之前，全局变量 `is_admin` 被设置为 1。'\\n- '在分析期间假设文件已成功打开。'\"\n          }\n        },\n        \"required\": [\n          \"task\"\n        ]\n      },\n      \"description\": \"要执行的函数分析任务列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 用于查询此固件文件系统的所有已知信息。可以查询文件的已知发现以及其他文件的已知发现。你可以优先查询文件的已知发现，然后通过结果链接到其他文件的已知发现。注意：没有发现意味着当前还没有发现。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前具体任务：\n分析函数 'ath_iw_setcountry' 的代码，寻找输入点和数据流"}
{"role": "assistant", "content": "{\n  \"thought\": \"我需要开始分析函数 'ath_iw_setcountry' 的代码，以识别输入点和数据流。首先，我应该获取当前分析任务的上下文信息，了解正在分析的文件是什么。然后，使用 Radare2 工具来反编译和查看该函数的代码。\",\n  \"action\": \"get_context_info\",\n  \"action_input\": {},\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：get_context_info\n参数：{}\n结果：\n 当前分析焦点：\n- 文件：ath_dev.ko\n- 目录：3.4.103\n- 相对于固件根目录的目录路径：lib/modules/3.4.103", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"现在我知道当前分析的文件是 'ath_dev.ko'，我需要分析函数 'ath_iw_setcountry'。我将使用 Radare2 工具来反编译这个函数，以查看其代码结构、输入点和数据流。首先，我需要打开文件并查找该函数。由于 r2 会话会自动维护，我可以直接发送命令来反编译函数。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ ath_iw_setcountry\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ ath_iw_setcountry\"}\n结果：\n [pdg @ ath_iw_setcountry 命令无输出]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"Radare2 的 'pdg' 命令对函数 'ath_iw_setcountry' 无输出，这可能表示函数不存在、名称错误或需要先加载符号。我将使用 'afl' 命令列出所有函数，以确认 'ath_iw_setcountry' 是否存在。如果存在，我将使用 'pdf' 命令反汇编该函数来获取代码。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"afl\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"afl\"}\n结果：\n 0x08000034   20     66 fcn.08000034\n0x080060d8    1     20 sym.ath_reg_notify_tx_bcn\n0x080060ec    1     20 sym.ath_dereg_notify_tx_bcn\n0x08006100    1     20 sym.ath_vap_info_get\n0x08006114    1     32 sym.ath_reg_vap_info_notify\n0x08006134    1     20 sym.ath_vap_info_update_notify\n0x08006148    1     32 sym.ath_dereg_vap_info_notify\n0x08006168    5     88 sym.ath_set_txpowlimit\n0x080061c0    1     32 sym.ath_enable_tpc\n0x0800627c    1     36 sym.ath_up_beacon\n0x080062a0    1     40 sym.ath_get_channel\n0x080062c8    1     32 sym.ath_get_rxfilter\n0x080062e8    3     56 sym.ath_monitor_filter_phyerr\n0x08006320    1     16 sym.ath_enter_led_scan_state\n0x08006330    1     20 sym.ath_led_state\n0x08006344    1     40 sym.ath_radio_info\n0x0800636c    1     16 sym.ath_leave_led_scan_state\n0x0800637c    1     16 sym.ath_notify_force_ppm\n0x0800638c    1     56 sym.ath_vap_dfs_wait\n0x080063c4    1     48 sym.ath_enable_intr\n0x080063f4    1     40 sym.ath_disable_intr\n0x0800641c    1     16 sym.ath_suspend_led_control\n0x0800642c    1     52 sym.ath_get_ciphers\n0x08006460    1     32 sym.ath_get_phy_stats\n0x08006480    1     24 sym.ath_get_phy_stats_allmodes\n0x08006498    1     24 sym.ath_get_ath_stats\n0x080064b0    1     24 sym.ath_get_11n_stats\n0x080064c8    1     24 sym.ath_get_dfs_stats\n0x080064e0    5    144 sym.ath_update_beacon_info\n0x08006570    1     32 sym.ath_update_loc_ctl_reg\n0x08006590    1     32 sym.ath_read_loc_timer_reg\n0x080065b0    1     32 sym.ath_get_eeprom_chain_mask\n0x080065d0    1     24 sym.ath_set_extprotspacing\n0x080065e8    1     32 sym.ath_get_extbusyper\n0x08006608    3     48 sym.ath_start_pktlog\n0x0800663c    3     60 sym.ath_read_pktlog_hdr\n0x0800667c    3     60 sym.ath_read_pktlog_buf\n0x080066bc    1     52 sym.ath_setacparams\n0x080066f0    1     40 sym.ath_setrtparams\n0x08006718    1     76 sym.ath_sethbrparams\n0x08006764    1     32 sym.ath_setrxtimeout\n0x08006784    1     68 sym.ath_dev_get_chan_stats\n0x080067c8    1     40 sym.ath_get_goodput\n0x080067f0    1     56 sym.ath_get_tid_seqno\n0x08006828    1     24 sym.ath_keycache_size\n0x08006860    1     24 sym.ath_get_current_tx_antenna\n0x08006878    1     24 sym.ath_get_default_antenna\n0x08006890    5    112 sym.ath_get_noisefloor\n0x08006900    3     80 sym.ath_get_chainnoisefloor\n0x08006950    3     72 sym.ath_get_rx_nf_offset\n0x08006998   10    396 sym.ath_get_rx_signal_dbm\n0x08006b24    1     32 sym.ath_disable_dcsim\n0x08006b44    1     80 sym.ath_ibss_beacon_update_start\n0x08006f68    1     76 sym.ath_getmfpsupport\n0x08006fb8    1     28 sym.ath_get_tx_hw_retries\n0x08006fd4    1     28 sym.ath_get_tx_hw_success\n0x08006ff0    1     36 sym.ath_spectral_get_tsf64\n0x08007014    1     60 sym.ath_spectral_get_capability\n0x08007050    1     44 sym.ath_spectral_set_rxfilter\n0x0800707c    1     36 sym.ath_spectral_get_rxfilter\n0x080070a0    1     36 sym.ath_spectral_is_spectral_active\n0x080070c4    1     36 sym.ath_spectral_is_spectral_enabled\n0x080070e8    1     44 sym.ath_spectral_start_spectral_scan\n0x08007114    1     44 sym.ath_spectral_stop_spectral_scan\n0x08007140    1     44 sym.ath_spectral_get_extension_channel\n0x0800716c    1     92 sym.ath_spectral_reset_hw\n0x080071c8    3     60 sym.ath_spectral_get_chain_noise_floor\n0x08007204    1     28 sym.ath_spectral_get_current_channel\n0x08007220    1     40 sym.ath_spectral_get_ctl_noisefloor\n0x08007248    1     40 sym.ath_spectral_get_ext_noisefloor\n0x08007270    1     36 sym.ath_spectral_get_nominal_noisefloor\n0x08007294    1     44 sym.ath_spectral_configure_params\n0x080072c0    1     32 sym.ath_spectral_get_ent_mask\n0x080072e0    1     32 sym.ath_spectral_set_icm_active\n0x080073a4    1     32 sym.ath_cdd_control\n0x080073c4    1     32 sym.ath_set_rifs\n0x080073e4    1     24 sym.ath_get_txbuf_free\n0x08007424    3     48 sym.ath_get_tpc_tables\n0x08007454    1     60 sym.ath_set_node_tx_chainmask\n0x08007490    1     20 sym.ath_detach_dfs\n0x080074a4    1     36 sym.ath_get_mib_cycle_counts_pct\n0x080074c8    1     40 sym.ath_get_radar_thresholds\n0x080074f0    4     72 sym.ath_smart_ant_set_tx_antenna\n0x08007538    1     24 sym.ath_smart_ant_set_tx_defaultantenna\n0x08007550    1     24 sym.ath_set_beacon_interval\n0x08007568    1     56 sym.ath_txbf_loforceon_update\n0x080075a0    1     24 sym.ath_node_pspoll\n0x080075b8    4     88 sym.ath_traffic_fast_recover\n0x08007640    5    220 sym.ath_spectral_get_params\n0x080079a8    5    212 sym.ath_dev_noisefloor\n0x08007a7c    5    244 sym.ath_printreg\n0x08007b70    5    228 sym.ath_disable_dfs\n0x08007c54    5    252 sym.ath_set_quiet\n0x08007d50    1     72 sym.ath_set_ps_state\n0x08007d98    8    264 sym.ath_key_reset\n0x08007ea0   10    316 sym.ath_set_mcastlist\n0x080082cc    1     36 sym.ath_get_mac_address\n0x080082f0    1     36 sym.ath_get_hw_mac_address\n0x08008314    1     64 sym.ath_set_mac_address\n0x08008354    1     64 sym.ath_set_bssid_mask\n0x08008394    3    108 sym.ath_key_save_halkey\n0x08008400    1     44 sym.ath_spectral_get_mac_address\n0x0800842c    1    120 sym.ath_smart_ant_set_training_info\n0x08008608    7    132 sym.ath_set_noise_detection_param\n0x08008694   10    224 sym.ath_smart_ant_enable\n0x08008778    1    472 sym.ath_getiqueconfig\n0x08008df8    1     20 sym.ath_get_ps_state\n0x0800930c    1     36 sym.athop_rate_newstate\n0x080094f8    1     20 sym.ath_set_ps_awake\n0x0800950c    5    216 sym.ath_set_rxfilter\n0x080096a4    3     64 sym.ath_detach_spectral\n0x080096e4    1     24 sym.ath_find_countrycode\n0x080096fc    1     64 sym.ath_sc_reset_lowest_txrate\n0x0800973c    1     20 sym.ath_set_ps_fullsleep\n0x08009750    7    116 sym.ath_read_pci_config_space\n0x080097c4    1     20 sym.ath_smart_ant_prepare_rateset\n0x080097d8    1     48 sym.ath_conf_rx_intr_mit\n0x08009808    1     28 sym.ath_setmfpQos\n0x08009824    3     36 sym.ath_node_pause_control\n0x08009848   33    740 sym.ath_node_update_pwrsave\n0x08009b40    1     24 sym.ath_green_ap_dev_get_enable_print\n0x08009b58    1     24 sym.ath_green_ap_dev_set_enable_print\n0x08009b70    1     24 sym.ath_green_ap_dev_get_on_time\n0x08009b88    1     24 sym.ath_green_ap_dev_set_on_time\n0x08009ba0    1     24 sym.ath_green_ap_dev_get_transition_time\n0x08009bb8    1     24 sym.ath_green_ap_dev_set_transition_time\n0x08009bd0    1     24 sym.ath_green_ap_dev_get_enable\n0x08009be8    1     20 sym.ath_atf_get_unused_txtoken\n0x08009bfc    1     20 sym.ath_atf_clear\n0x08009c10    1     20 sym.ath_atf_set\n0x08009c24    1     20 sym.ath_atf_update_node_txtoken\n0x08009c38    1     44 sym.athop_rate_newassoc\n0x08009c64    1     20 sym.ath_node_getmaxphyrate\n0x08009c78    1     20 sym.ath_node_gettxrate\n0x08009c8c    1     28 sym.ath_mhz2ieee\n0x08009ca8    1     36 sym.ath_get_ctl_by_country\n0x08009ccc    1     20 sym.ath_set_ps_netsleep\n0x08009ce0   14    232 sym.ath_newassoc\n0x08009dc8   16    420 sym.ath_node_detach\n0x08009f80  137   4600 sym.ath_get_caps\n0x0800f92c   30    512 fcn.0800f92c\n0x0801ebf4   30    656 fcn.0801ebf4\n0x0800a9f8   22    548 fcn.0800a9f8\n0x0800b670    8    332 sym.ath_attach_spectral\n0x0800a624    1     32 sym.ath_clear_stats\n0x0800a644    1    180 sym.ath_radar_get_info\n0x0800a6f8   24    760 sym.ath_set_country\n0x0800ac24    3    112 sym.ath_print\n0x0800adf0    7    280 sym.ath_keyset\n0x0800af08    9    276 sym.ath_set_sel_evm\n0x0800b01c    5    232 sym.ath_set_macmode\n0x0800b104    1     76 sym.ath_ibss_beacon_update_stop\n0x0800b150    7    140 sym.ath_get_noise_detection_param\n0x0800b1e4    5    108 sym.ath_vap_config\n0x0800b518    6    100 sym.ath_green_ap_dev_set_enable\n0x0800b580    3     76 sym.ath_get_dfsdomain\n0x0800b5d0    3     76 sym.ath_get_regdomain\n0x0800b620    1     80 sym.ath_get_currentCountry\n0x0800b9a0    6    188 sym.ath_set_regdomain\n0x0800bc98    1    100 sym.ath_vap_pause_control\n0x0800bd04   16    252 sym.ath_update_sm_pwrsave\n0x0800be08   22    656 sym.ath_enable_dfs\n0x0800c0b0    8    444 sym.ath_attach_dfs\n0x0800c27c    9    308 sym.ath_set_tx_antenna_select\n0x0800c3b8    9    160 sym.ath_key_alloc_single\n0x0800c464   12    236 sym.ath_key_alloc_pair\n0x0800c55c   14    348 sym.ath_key_alloc_2pair\n0x0800c6c4    5    372 sym.ath_scan_end\n0x0800c844    5    340 sym.ath_scan_start\n0x0800c9a8    3    104 sym.ath_switch_opmode\n0x0800ca18   70   1896 sym.ath_handle_intr\n0x0800d1b4   40   1336 sym.ath_mesg_intr\n0x0800d708   42   1404 sym.ath_intr\n0x0800dca4   24    988 sym.ath_node_attach\n0x0800e098   29    612 sym.ath_vap_stopping\n0x0800e314   62   1620 sym.ath_vap_up\n0x0800e980   21    948 sym.ath_vap_join\n0x0800ed48   15    668 sym.ath_vap_listen\n0x0800effc   27    736 sym.ath_vap_down\n0x0800f2ec   19    616 sym.ath_vap_detach\n0x0800f564    7    192 sym.ath_vap_attach\n0x0800f864   25    488 sym.ath_get_device_info\n0x0800fb00   15    456 sym.ath_txq_stuck_checker\n0x0800fcdc   10    316 sym.ath_rx_hwreg_checker\n0x0800fe28   18    460 sym.ath_rx_stuck_checker\n0x08010008  145   4420 sym.ath_calibrate\n0x08011afc    7    260 sym.ath_updateslot\n0x08011fd0   16    492 sym.ath_vap_reap_txqs\n0x080121cc    5    184 sym.ath_set_proxysta\n0x080131b8   11    256 sym.ath_suspend\n0x080132b8   25   1124 sym.ath_open\n0x08015500   33    776 sym.ath_node_cleanup\n0x0801920c   28    944 sym.ath_rx_timer\n0x0801ad90    3    104 sym._ath_internal_timer_handler\n0x08026c50   21    580 sym.ath_addba_timer\n0x08038ff8    1     40 sym.null_get_current_channel_flags\n0x08039020    1     40 sym.null_get_current_channel\n0x08039048    1     40 sym.null_is_vap_active\n0x08039070    1     40 sym.null_ap_ps_on_off\n0x08039808    1     36 sym.ath_green_ap_ant_ps_mode_on_tmr_fun\n0x0803a698    3     68 sym.ath_iw_setcountry\n0x0803a6dc    1    104 sym.ath_iw_getcountry\n0x0803a744    1     52 sym.ath_iw_set_dscp_tid_map\n0x0803a778    1     56 sym.ath_iw_get_dscp_tid_map\n0x0803a7b0    5    140 sym.ath_iw_gethwaddr\n0x0803a83c    1     44 sym.ath_iw_set_saparam\n0x0803a868    1     44 sym.ath_iw_get_saparam\n0x0803bb8c   10    124 sym.find_ath_ioctl_name\n0x0803a8b0   13    336 sym.ath_iw_getparam\n0x0803aa0c   21    424 sym.ath_iw_setparam\n0x0803ac00   11    188 sym.ath_iw_sethwaddr\n0x0803acbc    1     48 sym.__wbuf_map_single\n0x0803acec    1     40 sym.__wbuf_unmap_single\n0x0803b0b0    5     92 sym.ath_adhoc_netlink_receive\n0x08033004   62   1448 sym.ath_node_pwrsaveq_send\n0x08039bac   16    628 sym.ath_ald_collect_ni_data\n0x0802d658    5    156 sym.ath_rx_process_uapsd\n0x0801f464   13    404 sym.ath_tx_flush\n0x08022f5c    1     84 sym.ath_tx_pause_tid_nolock\n0x0801b020   11    344 sym.ath_tx_cleanup\n0x0801ae88    1     20 sym.ath_set_timer_period\n0x08008bac   16    580 sym.ath_reset\n0x0801af88    1     36 sym.ath_ratecode_to_ratekbps\n0x0800623c    1     32 sym.ath_get_channel_busy_info\n0x08038f98    1     56 sym.green_ap_register_funcs\n0x0801bd1c    3    172 sym.ath_cabq_update\n0x0802fb34    4    124 sym.ath_tx_edma_init\n0x080361c0    3     88 sym.ath_check_swretry_req\n0x0801bde0    4    228 sym.ath_tx_mcast_draintxq\n0x08007fdc    5    212 sym.ath_wnm_beacon_config\n0x0801ee90    1     60 sym.ath_tx_abortalldma\n0x080084a4    1     92 sym.ath_set_tx_chainmask\n0x08015f30    3    100 sym.ath_pwrsave_awake\n0x0803b114    5    216 sym.ath_adhoc_netlink_send\n0x0800771c    5    212 sym.ath_update_mib_macstats\n0x0803a364    1     40 sym.ath_proc_read_rtscts\n0x0802aa48   27    584 sym.ath_tx_node_cleanup\n0x080091bc   10    296 sym.ath_spectral_control\n0x08009330    3    100 sym.ath_pkt_log_text\n0x08031ce0    6    232 sym.ath_node_leftovercleanup\n0x0802fc40   18    320 sym.ath_txbf_alloc_key\n0x0801164c   19    648 sym.ath_update_txpow\n0x0803b898    7    144 sym.bus_free_consistent\n0x0802fe34    3     72 sym.ath_txbf_chk_rpt_frm\n0x08001c08   18    182 sym.ath_beacon_return\n0x08021718    1     36 sym.ath_txto_tasklet\n0x080137b0    5    140 sym.ath_gpio_register_callback\n0x0801aa50    3     52 sym.ath_delba_process\n0x08015224   23    572 sym.ath_dev_free\n0x08016eec    5    160 sym.ath_rx_requeue\n0x0801665c    8    332 fcn.0801665c\n0x080078d0    5    216 sym.ath_gettsf32\n0x0803b068    1     16 sym.__wbuf_uapsd_update\n0x0801f5fc    1     32 sym.ath_txq_depth\n0x08019988   36   1136 sym.ath_bar_rx\n0x08018d14    3    104 sym.ath_rx_node_free\n0x08039b3c    1     32 sym.ath_green_ap_suspend\n0x080195d4    1     32 sym.ath_set_addbaresponse\n0x0803a124    1     48 sym.ath_proc_write\n0x08003b08    1     32 sym.ath_hw_beacon_rssi_reset\n0x08033e6c   60   1292 sym.ath_node_pwrsaveq_age\n0x080115a8    5    164 sym.ath_update_tpscale\n0x0801aa84    8    288 sym.ath_rx_node_init\n0x0802cea0   19    552 sym.ath_rx_edma_init\n0x0803a4f8    1     36 sym.ath_handle_tx_intr\n0x08025864   95   2456 sym.ath_tx_send_ampdu\n0x080114a0    6    264 sym.ath_extend_tsf\n0x080170bc   23    576 sym.ath_startrecv\n0x0802fbf8    3     72 sym.ath_get_txbfcaps\n0x08029468   22    556 sym.ath_addba_responseprocess\n0x08003ed4    9    296 sym.ath_timbcast_return\n0x08005df8    4    152 sym.ath_tx_uapsd_node_stageq_cleanup\n0x08006018    4    124 sym.ath_tx_uapsd_pause_begin\n0x08027130    1    136 sym.ath_bar_tx\n0x0803afa8    3    152 sym.__wbuf_map_sg\n0x0803addc   13    392 sym.ath_rxbuf_alloc\n0x08031dc8    4     84 sym._modify_sw_retry_limit\n0x0802ad40   10    252 sym.ath_tx_node_resume\n0x0803bb0c    1     96 sym.cleanup_module\n0x08016584    3    108 sym.ath_pwrsave_proc_intdone\n0x08015f94   20    644 sym.ath_radio_enable\n0x08030034   27    888 sym.ath_tx_paprd_init\n0x0802aee8    4     60 sym.ath_set_config\n0x08035aac    5    140 sym.ath_set_swretrystate\n0x0802037c  154   4952 sym.ath_tx_start_dma\n0x0801af18    1     40 sym.ath_timer_is_initialized\n0x08038f38    1     32 sym.ath_green_ap_sc_get_transition_time\n0x0801aedc    1     40 sym.ath_cancel_timer\n0x08039458   41    908 sym.ath_green_ap_state_mc\n0x08022b0c    7    104 sym.ath_addba_cancel_timers\n0x0802cc80   16    380 sym.ath_rx_edma_cleanup\n0x0801eed0   22    556 sym.ath_reset_draintxq\n0x0801594c    1     80 sym.ath_init_green_ap_ops\n0x080360f4    5     96 sym.ath_exist_pendingfrm_tidq\n0x08013948   41   1692 sym.ath_dev_attach\n0x0801b2e8   51   1360 sym.ath_txq_setup\n0x0802d29c    8    304 sym.ath_edmaAllocRxbufsForFreeList\n0x08023fe0  233   6228 sym.ath_txq_schedule\n0x0803af7c    1     24 sym.wbuf_release\n0x0802297c    5    200 sym.ath_aggr_check\n0x08015b4c    1     28 sym.ath_get_sw_phystate\n0x0803a38c    1     40 sym.ath_proc_read_version\n0x0802bdc8    3     60 sym.ath_get_config\n0x0800b494    5    132 sym.ath_scan_enable_txq\n0x0800736c    1     28 sym.ath_green_ap_get_current_channel\n0x080080b0   25    540 sym.ath_get_noderssi\n0x08022fe8  111   3060 sym.ath_tx_sched_normal\n0x0800ad44    3     52 sym.ath_ant_swcom_sel\n0x08017ad4   59   2092 sym.ath_rx_process\n0x08032258    7    188 sym._pktlog_update_txcomp\n0x08015820    1     40 sym.ath_spectral_indicate\n0x080111a8   23    632 sym.ath_reset_start\n0x0801f63c    1     32 sym.ath_txq_aggr_depth\n0x08033a1c   47   1084 sym.ath_node_pwrsaveq_drain\n0x0800452c    1     16 sym.ath_desc_swap\n0x0803a4d0    1     40 sym.ath_hw_phystate_change\n0x0801ae18    1    108 sym.ath_initialize_timer_int\n0x080095e4    1     20 sym.ath_get_common_power\n0x08015b84    1     32 sym.ath_set_sw_phystate\n0x0803b964   11    352 sym.init_module\n0x0802d0d0    6    236 sym.ath_rx_edma_requeue\n0x08012850   45   1408 sym.ath_lean_chan_set\n0x0802d1c4    3    196 sym.ath_edma_attach\n0x08005e90   11    384 sym.ath_tx_prepend_uapsd_stage_queue\n0x0800537c   41   1700 sym.ath_process_uapsd_trigger\n0x080061e0    1     92 sym.ath_setdefantenna\n0x0801b8d8   49   1632 sym.ath_txq_update\n0x08038b2c    3     40 sym.ath_get_retries_num\n0x0801f9f8   92   2428 sym.ath_buf_set_rate\n0x08018308   78   2348 sym.ath_rx_tasklet\n0x08001cac    1     36 sym.ath_beacon_free\n0x0800453c    1     20 sym.ath_tx_uapsd_depth\n0x08006e58    1     44 sym.ath_get_maxtxpower\n0x0803a0b0    1     20 sym.ath_proc_write_version\n0x0802ac90    3     64 sym.ath_tx_node_free\n0x080335d0   42   1060 sym.ath_node_pwrsaveq_flush\n0x08016504    5    128 sym.ath_pwrsave_netsleep\n0x0801f8d0    4    180 sym.ath_pkt_duration\n0x080119b4    3     84 sym.ath_setTxPwrAdjust\n0x0800bb44    9    332 sym.ath_checkandplumb_key\n0x0801bdc8    1     24 sym.ath_set_protmode\n0x080039e0    5    264 sym.ath_hw_beacon_rssi_threshold_disable\n0x08013864    6    228 sym.ath_gpio_set_intr\n0x0803ad14    1     48 sym.__wbuf_map_single_tx\n0x0801c330  126   4240 sym.ath_tx_txqaddbuf\n0x08006da4    1     84 sym.ath_set_diversity\n0x08036218   11    624 sym.ath_form_swretry_frm\n0x080346c8    1     44 sym.ath_node_pwrsaveq_set_param\n0x08007330    3     60 sym.ath_green_ap_is_vap_active\n0x08018f68    9    352 sym.ath_rx_duration\n0x08015adc    1     32 sym.ath_pcie_pwrsave_enable_on_phystate_change\n0x0803a51c    1     48 sym.ath_handle_rx_intr\n0x08011428    5    112 sym.ath_wait_sc_inuse_cnt\n0x08027d88  214   5808 sym.ath_txq_schedule_before_eapol\n0x0803b318    3     68 sym.ahb_free_consistent\n0x08005a48   20    936 sym.ath_tx_stage_queue_uapsd\n0x08006df8    1     48 sym.ath_set_rx_chainmasklegacy\n0x080312ec    5    192 sym.ath_paprd_send\n0x08039afc    3     64 sym.ath_green_ap_is_powersave_on\n0x08016bd8   10    440 sym.ath_opmode_init\n0x0803a3b4    1     40 sym.ath_proc_read\n0x08034678    3     76 sym.ath_node_pwrsaveq_detach\n0x080352a4   74   1760 sym.ath_tx_vap_pause_control\n0x0803a314    1     40 sym.ath_proc_read_ignoredfs\n0x08019e14   81   2656 sym.ath_ampdu_input\n0x0801bec4    8    284 sym.ath_tx_drain_backlogq\n0x080037a4    3    132 sym.ath_get_hwbeaconproc_active\n0x08006840    1     32 sym.ath_keycache_print\n0x080303cc   35   1076 sym.ath_tx_paprd_complete\n0x0803001c    1     24 sym.ath_paprd_getrate\n0x08003760    1     60 sym.ath_bmiss_tasklet\n0x0803a154   15    416 sym.ath_proc_write_nodefixedrate\n0x0801b7fc   13    148 sym.ath_tx_get_qnum\n0x08035b48   67   1424 sym.ath_handlepspoll\n0x0802ad08    3     56 sym.ath_tx_node_pause_nolock\n0x08001a14    1     12 sym.ath_beacon_alloc\n0x08019940    1     72 sym.ath_addba_responsesetup\n0x0801d460  110   2276 sym.ath_tx_start\n0x0802710c    3     36 sym.ath_aggr_teardown\n0x0803b274    1     16 sym.ath_adhoc_netlink_reply\n0x08006c1c    1     32 sym.ath_clear_mib_counters\n0x080095f8    8    172 sym.ath_resched_txq\n0x080313b4   20    460 sym.ath_tx_paprd_cleanup\n0x08036ce8   31    864 sym.ath_tx_dec_eligible_frms\n0x08022a7c    5    144 sym.ath_addba_clear\n0x08004814    4    232 sym.ath_tx_uapsd_node_cleanup\n0x08022dd0    1    140 sym.ath_tx_pause_tid\n0x08038f18    1     32 sym.ath_green_ap_sc_set_transition_time\n0x0803ad44    7    152 sym.wbuf_alloc\n0x08003b6c    1     28 sym.ath_beacon_attach\n0x0800ba64    1     56 sym.ath_dprintf\n0x08031ad0   19    528 sym.ath_tx_complete_buf\n0x08023ddc   19    516 sym.ath_insertq_inorder\n0x080019a0    1    116 sym.ath_beaconq_setup\n0x08011a08    5    244 sym.ath_setslottime\n0x08038114    1     32 sym.ath_atf_sc_set\n0x08011c00   18    412 sym.ath_chan_change\n0x08015bbc   39    884 sym.ath_pwrsave_set_state\n0x0803b92c    3     56 sym.bus_read_cachesize\n0x0803b040    1     40 sym.__wbuf_unmap_sg\n0x0800625c    1     32 sym.ath_disable_hwq\n0x0801b178   13    336 sym.ath_tx_init\n0x0802a6e0   10    308 sym.ath_txq_drain_pending_buffers\n0x08022c2c    7    200 fcn.08022c2c\n0x080225b0    4    172 fcn.080225b0\n0x08023bf8   14    340 sym.ath_tx_num_badfrms\n0x08006094    1     68 sym.ath_tx_uapsd_pause_end\n0x0800ba9c    4    160 sym.ath_process_phyerr\n0x080345f0    1    136 sym.ath_node_pwrsaveq_attach\n0x08006b94    1     32 sym.ath_gettsftstamp\n0x0800b3a0    5    188 sym.ath_set_tx_chainmaskopt\n0x0802acd0    3     56 sym.ath_tx_node_pause\n0x08003630    9    296 sym.ath_beacon_sync\n0x0801af04    1     20 sym.ath_timer_is_active\n0x0801e094   42   1456 sym.ath_tx_update_stats\n0x080317ac   25    804 sym.ath_edma_free_complete_buf\n0x0801f988    5    112 sym.ath_txchainmask_reduction\n0x08032318   54   1500 sym.ath_tx_complete_aggr_compact\n0x08002880    1     72 sym.ath_beacon_config\n0x08039254   18    412 sym.ath_green_ap_detach\n0x0803a54c   10    324 sym.ath_rx_indicate\n0x08006be8    3     52 sym.ath_get_mib_macstats\n0x0801c028   25    764 sym.ath_tx_mcastqaddbuf\n0x0801b524    3     84 sym.ath_tx_cleanupq\n0x080167a8    6    100 sym.ath_rx_cleanup\n0x0802a814   19    560 sym.ath_tx_node_init\n0x08031594   20    512 sym.ath_tx_paprd_draintxq\n0x08038154    1     28 sym.ath_atf_sc_get_unused_txtoken\n0x0801694c   37    652 sym.ath_calcrxfilter\n0x0802fa38    9    248 sym.ath_tx_edma_tasklet\n0x0803982c   16    372 sym.ath_green_ap_stop\n0x08036488   31    952 sym.ath_tx_drain_sxmitq\n0x08018f2c    1     60 sym.ath_fill_radiotap_hdr\n0x08003b88    1     16 sym.ath_beacon_detach\n0x08009010   15    408 sym.ath_dev_start_spectral_scan\n0x08015afc    1     48 sym.ath_notify_device_removal\n0x0801bcd0    1     76 sym.ath_txq_burst_update\n0x0802d538   10    288 sym.ath_edma_stoprecv\n0x08038170   30    668 sym.ath_atf_sc_update_node_txtoken\n0x08019630   26    748 sym.ath_addba_requestprocess\n0x0803a0f4    1     48 sym.ath_proc_write_rtscts\n0x08003b28    1     60 sym.ath_brssi_tasklet\n0x0803b3c8   18    336 sym.bus_dma_sync_single\n0x0803b3a4    1     20 sym.bus_alloc_nonconsistent\n0x08008564    6    156 sym.ath_node_set_fixedrate\n0x08015b68    1     28 sym.ath_get_hw_phystate\n0x080222cc   17    396 sym.ath_tx_tasklet\n0x08015b2c    1     32 sym.ath_detect_card_present\n0x08006bb4    3     52 sym.ath_get_mib_cyclecounts\n0x080038d4    5    268 sym.ath_hw_beacon_rssi_threshold_enable\n0x08032918    4    132 sym.ath_tx_mark_aggr_rifs_done\n0x0802d6f4   17    528 sym.ath_rx_intr\n0x080399b4    3     88 sym.ath_green_ap_sc_set_enable\n0x08030004    1     24 sym.ath_paprd_setrate\n0x08022b74    4    184 sym.ath_tx_update_baw\n0x08012de8    8    272 sym.ath_lean_set_channel\n0x080048fc    8    376 sym.ath_tx_queue_uapsd\n0x0802e7e8    8    316 sym.ath_rx_edma_intr\n0x08004508    1     36 sym.ath_txstatus_cleanup\n0x0802e928  128   4300 sym.ath_tx_edma_process\n0x08015ba4    1     24 sym.ath_pwrsave_get_state\n0x080043e4    4    168 sym.ath_txstatus_setup\n0x0801680c   11    304 sym.ath_rx_init\n0x0802ae58    1     84 sym.ath_set_weptkip_rxdelim\n0x0801f65c    1     88 sym.ath_txq_set_minfree\n0x08038f58    1     32 sym.ath_green_ap_sc_set_on_time\n0x08038420    3     64 sym.ath_calc_ack_duration\n0x08038fd0    1     40 sym.null_reset_dev\n0x08004550    6    128 sym.ath_tx_uapsd_cleanup\n0x08015848    1    260 sym.ath_init_spectral_ops\n0x0802d3dc    6    336 sym.ath_edma_startrecv\n0x0801a8a4   16    404 sym.ath_rx_aggr_teardown\n0x08022a44    1     56 sym.ath_addba_status\n0x08006c98    6    116 sym.ath_set_txqproperty\n0x0803a894    1     28 sym.ath_iw_attach\n0x0801b578    3     96 sym.ath_tx_setup\n0x08017308   43   1268 sym.ath_rx_input\n0x080329f8   58   1500 sym.ath_node_pwrsaveq_queue\n0x08003b98   16    820 sym.ath_timbcast_alloc\n0x0802fe0c    1     40 sym.ath_txbf_set_rpt_received\n0x08029698  129   4124 sym.ath_tx_complete_aggr_rifs\n0x0801ae9c    1     64 sym.ath_start_timer\n0x08026b0c   12    324 sym.ath_tx_resume_tid\n0x0801e644   43   1428 sym.ath_tx_draintxq\n0x08026e9c   21    624 sym.ath_tx_aggr_teardown\n0x0801ae04    1     20 sym.ath_initialize_timer_module\n0x08011f90    1     64 sym.ath_green_ap_reset_dev\n0x0803a0c4    1     48 sym.ath_proc_write_ignoredfs\n0x08003ae8    1     32 sym.ath_hw_beacon_rssi\n0x0800ad78    4    120 sym.ath_set_ctl_pwr\n0x0801228c   50   1460 sym.ath_set_channel\n0x0801aba8   23    464 sym.ath_rx_node_cleanup\n0x08006e84    1     76 sym.ath_read_from_eeprom\n0x0801dd50   16    700 sym._ath_tx_complete_buf\n0x08004a7c    9    308 sym.ath_tx_uapsdqnulbf_complete\n0x08004df8   44   1384 sym.ath_tx_uapsd_draintxq\n0x0801546c    4    148 sym.ath_tx_frag_cleanup\n0x08036160    3     96 sym.ath_reset_paused_tid\n0x08006ed0    1     44 sym.ath_fixed_log_text\n0x08003ffc   31    984 sym.ath_descdma_setup\n0x08039a0c    6    204 sym.ath_green_ap_attach\n0x0801f2d0    1      8 sym.ath_draintxq\n0x08006d94    1     16 sym.ath_get_hwrevs\n0x08022fb0    1     56 sym.ath_smart_ant_select_train_packet\n0x0802fd80    1     52 sym.ath_txbf_set_key\n0x080073fc    1     40 sym.ath_get_pwrsaveq_len\n0x080045d0    8    568 sym.ath_tx_uapsd_init\n0x08039b80    1     44 sym.ath_green_ap_sc_set_enable_print\n0x080320a8   17    404 sym._ath_swretry_comp_aggr_dec_eligible_frms\n0x08001d34   18    402 sym.ath_hw_hang_check\n0x0803b078    3     52 sym.ath_adhoc_netlink_delete\n0x0802fe7c   10    320 sym.ath_apply_paprd_table\n0x080092e4    1     40 sym.ath_rate_newstate_set\n0x08039e20   19    548 sym.ath_ald_collect_data\n0x0803b7c4   11    208 sym.bus_alloc_consistent\n0x08001e94    1      4 sym.ath_beacon_tasklet\n0x0802ae40    1     24 sym.ath_set_ampduparams\n0x080359a8    7    236 sym.dumpTxQueue\n0x08036858    1     12 sym.ath_tx_flush_node_sxmitq\n0x08004494    4    116 sym.ath_descdma_cleanup\n0x08016288   18    628 sym.ath_radio_disable\n0x0803b3b8    1     16 sym.bus_free_nonconsistent\n0x08038134    1     32 sym.ath_atf_sc_clear\n0x0801af40    1     72 sym.ath_free_timer_int\n0x08016f8c    8    288 sym.ath_allocRxbufsForFreeList\n0x080093ac    1     20 sym.ath_rc_rate_maprix\n0x08038f78    1     32 sym.ath_green_ap_sc_get_on_time\n0x0801e014    6    128 sym.ath_tx_update_hwretries_estimate\n0x08016d98   10    332 sym.ath_stoprecv\n0x08021774   84   2860 sym.ath_tx_processq\n0x08007614    1     44 sym.ath_tx99_ops\n0x0801599c    7    320 sym.ath_pcie_pwrsave_enable\n0x0802fdb4    1     40 sym.ath_txbf_set_hw_cvtimeout\n0x08031e1c    4    180 sym._txcomp_handle_subframe_retry\n0x0801f61c    1     32 sym.ath_txq_num_buf_used\n0x08031ed0   18    452 sym._ath_swretry_comp_handle_tim\n0x0803b6fc   11    196 sym.bus_unmap_single\n0x08039b5c    1     36 sym.ath_green_ap_sc_get_enable_print\n0x08007300    1     48 sym.ath_green_ap_ps_on_off\n0x08018c58    8    180 sym.ath_flushrecv\n0x0802e798    1     80 sym.ath_rx_edma_tasklet\n0x0802df10   75   2148 fcn.0802df10\n0x08006e28    1     48 sym.ath_set_tx_chainmasklegacy\n0x08030830   33   1596 sym.ath_sendpaprd_single\n0x08016224    3    100 sym.ath_pwrsave_fullsleep\n0x08012ef8   22    596 sym.ath_stop_locked\n0x0801d414    6     76 sym.ath_rate_findrix\n0x0801b5dc   20    516 sym.ath_set_tx\n0x08038bac   33    824 sym.ath_atf_node_airtime_consumed\n0x08006f00    5    104 sym.ath_rate_findrc\n0x0802aeac    1     60 sym.ath_get_amsdusupported\n0x0802ffcc    1     32 sym.ath_paprd_set_enable\n0x08022e5c    6    256 sym.ath_addba_requestsetup\n0x08030e8c   29   1084 sym.ath_paprd_cal\n0x08008e0c   19    492 sym.ath_dev_stop_spectral_scan\n0x08007388    1     28 sym.ath_green_ap_get_current_channel_flags\n0x08008504    1     92 sym.ath_set_rx_chainmask\n0x08023d4c    6    144 sym.ath_check_seq_order\n0x0802245c   18    328 sym.ath_print_tbf_usage\n0x08018d7c   18    432 sym.ath_rx_proc_descfast\n0x0803b1f0    4    108 sym.ath_adhoc_netlink_init\n0x0803a33c    1     40 sym.ath_proc_read_nodefixedrate\n0x08038ef8    1     32 sym.ath_green_ap_sc_get_enable\n0x0803b360    1     68 sym.pci_read_cachesize\n0x08003884    1     80 sym.ath_hwbeaconproc_disable\n0x0801372c    7    124 sym.ath_gpio_config\n0x0803a05c    1     84 sym.ath_ald_update_frame_stats\n0x08037c60   37   1176 sym.ath_tx_mpdu_resend\n0x080093c0    5    304 sym.ath_do_pwrworkaround\n0x0803b284    1     24 sym.ahb_read_cachesize\n0x08009398    1     20 sym.ath_rc_rate_set_mcast_rate\n0x08008978   17    544 sym.ath_dev_record_chan_info\n0x08026210   83   2280 sym.ath_tx_send_normal\n0x08034398   25    580 sym.ath_node_pwrsaveq_get_info\n0x0802fddc    1     16 sym.ath_txbf_print_cv_cache\n0x0801bfe0    5     72 sym.ath_tx_node_queue_depth\n0x0802fbb4    1     68 sym.ath_tx_edma_cleanup\n0x08013844    1     32 sym.ath_gpio_get_intr\n0x08036bd0    7    280 sym.ath_tx_modify_rateseries\n0x080370d8   79   2180 sym.ath_tx_mpdu_requeue\n0x0802fdec    1     32 sym.ath_txbf_get_cvcache_nr\n0x08003828    1     92 sym.ath_hwbeaconproc_enable\n0x0803af94    1     20 sym.wbuf_start_dma\n0x08006d0c    6    136 sym.ath_update_txqproperty\n0x0800ac98   15    172 sym.ath_get_noderate\n0x080077f0    5    224 sym.ath_gettsf64\n0x08039098   18    412 sym.ath_green_ap_start\n0x08011db8   14    464 sym.ath_reset_end\n0x08004bb8   23    556 sym.ath_tx_uapsd_complete\n0x08021740    1     52 sym.ath_tx_get_rts_retrylimit\n0x080195f4    3     60 sym.ath_clear_addbaresponsestatus\n0x0802d914   42   1524 sym.ath_rx_bf_handler\n0x0803b29c    5    120 sym.ahb_alloc_consistent\n0x0802ffec    1     24 sym.ath_paprd_get_enable\n0x080384e8   65   1580 sym.ath_atf_check_txtokens\n0x080118e0   11    212 sym.ath_setTxPwrLimit\n0x0803a3dc    6    232 sym.ath_internal_reset\n0x0803b528   19    452 sym.bus_map_single\n0x08017814   28    672 sym.ath_rx_bf_process\n0x08002794    6    204 sym.ath_bstuck_tasklet\n0x08006c3c    6     92 sym.ath_get_txqproperty\n0x0801f6b4   26    532 sym.ath_tx_drop_policy\n0x080165f0    1    108 sym.ath_pwrsave_init\n0x0800b460    3     52 sym.ath_setrxfilter\n0x0800b818    8    380 fcn.0800b818\n0x0800b258    3    320 fcn.0800b258\n0x0801315c    5     92 fcn.0801315c\n0x080190d0    9    308 fcn.080190d0\n0x0801afac    1    116 fcn.0801afac\n0x0802265c   22    616 fcn.0802265c\n0x080271b8   63   2176 fcn.080271b8\n0x08027a9c   20    732 fcn.08027a9c\n0x080228c4    3    184 fcn.080228c4\n0x08022cf4    6    220 fcn.08022cf4\n0x0802ca08   11    208 fcn.0802ca08\n0x0802cdfc    6    164 fcn.0802cdfc\n0x0802cae4   14    396 fcn.0802cae4\n0x0803299c    3     92 fcn.0803299c\n0x080346f4  114   2936 fcn.080346f4\n0x08039410    3     64 fcn.08039410\n0x0803abc0    1     64 fcn.0803abc0", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我找到了 'ath_iw_setcountry' 函数在地址 0x0803a698。现在我将使用 'pdf' 命令来反汇编这个函数，以查看其代码结构、输入点和数据流。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdf @ sym.ath_iw_setcountry\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdf @ sym.ath_iw_setcountry\"}\n结果：\n ┌ 68: sym.ath_iw_setcountry (int32_t arg1);\n│ `- args(r0) vars(1:sp[0x4..0x4])\n│           0x0803a698      0dc0a0e1       mov ip, sp\n│           0x0803a69c      00d82de9       push {fp, ip, lr, pc}\n│           0x0803a6a0      04b04ce2       sub fp, ip, 4\n│           0x0803a6a4      142d09e3       movw r2, 0x9d14\n│           0x0803a6a8      022090e7       ldr r2, [r0, r2]            ; arg1\n│           0x0803a6ac      701492e5       ldr r1, [r2, 0x470]\n│           0x0803a6b0      0cc091e5       ldr ip, [r1, 0xc]\n│           0x0803a6b4      00005ce3       cmp ip, 0\n│       ┌─< 0x0803a6b8      0500000a       beq 0x803a6d4\n│       │   0x0803a6bc      0310a0e1       mov r1, r3\n│       │   0x0803a6c0      6c0492e5       ldr r0, [r2, 0x46c]\n│       │   0x0803a6c4      0230a0e3       mov r3, 2\n│       │   0x0803a6c8      0020a0e3       mov r2, 0\n│       │   0x0803a6cc      3cff2fe1       blx ip\n│       │   0x0803a6d0      00a89de8       ldm sp, {fp, sp, pc}\n│       │   ; CODE XREF from sym.ath_iw_setcountry @ 0x803a6b8(x)\n│       └─> 0x0803a6d4      5e00e0e3       mvn r0, 0x5e\n└           0x0803a6d8      00a89de8       ldm sp, {fp, sp, pc}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已经分析了函数 'ath_iw_setcountry' 的反汇编代码。该函数似乎是一个包装器，它从通过参数传递的结构体中提取一个函数指针并调用它。输入点包括参数 arg1（可能是一个上下文指针）和寄存器 r3（可能是一个用户提供的值）。数据流涉及从 arg1 的偏移量读取数据，最终调用函数指针。为了更深入地了解输入点和数据流，我需要查看这个函数被谁调用，以确定 arg1 和 r3 的来源。我将使用 Radare2 查找对 'ath_iw_setcountry' 的引用。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"axt sym.ath_iw_setcountry\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"axt sym.ath_iw_setcountry\"}\n结果：\n [axt sym.ath_iw_setcountry 命令无输出]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the 'ath_iw_setcountry' function. It appears to be a wrapper that calls a function pointer from a structure. The input points include the argument passed to the function (likely a context pointer) and the value in register r3 (which may be user-controlled data). The data flow involves reading from memory offsets based on the input argument and eventually calling a function pointer. However, without knowing the caller or the source of the arguments, I cannot establish a complete attack chain. The function might be part of wireless IOCTL handlers, but no direct callers were found in this binary. I need to investigate further by looking at related functions or the registration point, such as 'ath_iw_attach', to understand how this function is invoked and what controls its inputs.\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdf @ sym.ath_iw_attach\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdf @ sym.ath_iw_attach\"}\n结果：\n ┌ 28: sym.ath_iw_attach (int32_t arg1);\n│ `- args(r0) vars(1:sp[0x4..0x4])\n│           0x0803a894      0dc0a0e1       mov ip, sp\n│           0x0803a898      00d82de9       push {fp, ip, lr, pc}\n│           0x0803a89c      04b04ce2       sub fp, ip, 4\n│           0x0803a8a0      003000e3       movw r3, .LANCHOR0          ; RELOC 32 .LANCHOR0 @ 0x08045be4 - 0x1\n│           ;-- reloc..LANCHOR0:\n│           0x0803a8a4      003040e3       movt r3, .LANCHOR0          ; RELOC 32 .LANCHOR0 @ 0x08045be4 - 0x1\n│           0x0803a8a8      183180e5       str r3, [r0, 0x118]         ; arg1\n└           0x0803a8ac      00a89de8       ldm sp, {fp, sp, pc}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"I have analyzed the 'ath_iw_setcountry' function. It is a wrapper that calls a function pointer from a structure. The input points include the function's argument (likely a context pointer) and the value in register r3, which may be user-controlled. The data flow involves reading from memory offsets based on the input argument and eventually calling a function pointer with parameters derived from these reads and r3. However, without knowing the caller or the source of the arguments, I cannot establish a complete attack chain. The function might be part of wireless IOCTL handlers, but no direct callers were found in this binary. I investigated 'ath_iw_attach', which sets a pointer to .LANCHOR0, but without further context, I cannot determine the exact data flow or identify exploitable vulnerabilities. Based on the current evidence, there is no complete, verified attack chain from an untrusted input to a dangerous operation. Therefore, I must conclude that no exploitable vulnerability has been identified in this function with the available information.\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": {\n      \"findings\": [\n        {\n          \"description\": \"The function 'ath_iw_setcountry' was analyzed, but no complete attack chain was identified. The function acts as a wrapper that calls a function pointer from a structure. Input points include the function's argument (likely a context pointer) and register r3 (which may be user-controlled). Data flow involves reading from memory offsets (e.g., [r0+0x9d14], [r2+0x470], [r1+0xc]) and calling a function pointer with parameters including r3. However, without knowledge of the caller or the source of these arguments, the propagation path from untrusted input to a dangerous operation cannot be verified. The function may be part of wireless IOCTL handling, but no direct callers or exploitable conditions were found.\",\n          \"link_identifiers\": [],\n          \"location\": \"sym.ath_iw_setcountry (0x0803a698)\",\n          \"code_snippet\": \"0x0803a698      0dc0a0e1       mov ip, sp\\n0x0803a69c      00d82de9       push {fp, ip, lr, pc}\\n0x0803a6a0      04b04ce2       sub fp, ip, 4\\n0x0803a6a4      142d09e3       movw r2, 0x9d14\\n0x0803a6a8      022090e7       ldr r2, [r0, r2]\\n0x0803a6ac      701492e5       ldr r1, [r2, 0x470]\\n0x0803a6b0      0cc091e5       ldr ip, [r1, 0xc]\\n0x0803a6b4      00005ce3       cmp ip, 0\\n0x0803a6b8      0500000a       beq 0x803a6d4\\n0x0803a6bc      0310a0e1       mov r1, r3\\n0x0803a6c0      6c0492e5       ldr r0, [r2, 0x46c]\\n0x0803a6c4      0230a0e3       mov r3, 2\\n0x0803a6c8      0020a0e3       mov r2, 0\\n0x0803a6cc      3cff2fe1       blx ip\\n0x0803a6d0      00a89de8       ldm sp, {fp, sp, pc}\\n0x0803a6d4      5e00e0e3       mvn r0, 0x5e\\n0x0803a6d8      00a89de8       ldm sp, {fp, sp, pc}\",\n          \"risk_score\": 0.0,\n          \"confidence\": 2.0,\n          \"notes\": \"No callers were found within the binary, so the source of arguments is unknown. The function might be invoked via IOCTL or other external mechanisms, but this cannot be verified from the current analysis. Further analysis would require identifying callers or the system context in which this function is used.\"\n        }\n      ]\n    }\n  },\n  \"status\": \"complete\"\n}"}
{"role": "system", "content": "\n你是一个专门的文件分析代理。你的任务是深入分析当前指定的文件并提供详细的、有证据支持的分析结果。请专注于当前焦点文件或当前特定任务。当你认为你的分析已完成或无法进一步推进时，继续下一个任务或结束任务。\n\n**工作原则：**\n-   **基于证据**：所有分析都必须基于从工具获取的实际证据；禁止无根据的猜测。\n-   **结果验证**：批判性地评估委托子任务（例如函数分析）返回的结果，并始终验证其真实性和可靠性，以防止虚假结果污染最终结论。\n\n**工作流程：**\n1.  **理解任务**：专注于当前分析文件的特定任务，并充分参考用户的整体要求。注意，如果任务与当前分析焦点不匹配，你需要停止分析并及时向用户反馈。不要执行跨目录分析。\n2.  **执行分析**：确保你的分析有足够的深度。对于复杂任务，将其分解为多个具有明确目标和步骤的子任务，并合理地按顺序或并行调用分析助手或工具。选择最合适的工具或助手来获取证据。对于复杂的调用链，使用 `FunctionAnalysisDelegator` 并提供详细的污点信息和上下文。谨慎使用某些工具，避免结果过长导致分析失败，例如 `strings` 工具。\n3.  **完成并报告**：完成分析后，使用 `finish` 动作并严格按照以下格式提交最终报告。\n\n**最终响应要求**：\n*   回答与当前任务相关的所有问题，你的响应必须有完整的证据。不要遗漏任何有效信息。\n*   用具体证据支持所有发现，并如实报告任何证据不足或困难。\n\n每个发现必须包含以下**核心字段**：\n- **`description`**：对发现的详细描述，必须包括：\n* **完整且可验证的攻击链**：从攻击者可控源到危险汇聚点的具体污点传播路径，每一步都有证据支持。\n* **精确的触发条件**：到达易受攻击代码路径所需的确切条件。\n* **可利用性分析**：清楚说明*为什么*这是可利用的（例如，缺少清理、逻辑缺陷）。\n\n- **`link_identifiers`**：特定的 NVRAM 或 ENV 变量名、文件路径、IPC 套接字路径和自定义共享函数符号。\n- **`location`**：代码汇聚点或关键逻辑的精确位置。\n- **`code_snippet`**：返回完整的相关代码片段，展示漏洞。\n- **`risk_score`**：风险评分（0.0-10.0）。**只有具有经过验证的完整攻击链和明确安全影响的发现才能得分 >= 7.0。**\n- **`confidence`**：对发现准确性和可利用性分析的置信度（0.0-10.0）。**得分 >= 8.0 需要从源到汇聚点的完整、可验证的攻击链。**\n- **`notes`**：供人工分析师参考。包括：需要进一步验证的假设、相关文件或函数、后续分析的建议方向。\n\n#### 关键原则：\n- **可利用性是必须的**：只报告实际可利用的发现。理论上的弱点或不良实践（如使用 `strcpy`）是不够的，除非你能证明它们会导致漏洞。\n- **需要完整路径**：部分或推测性路径（\"如果...可能存在漏洞\"）是不可接受的。你必须提供完整、经过验证的链。\n- **证据优于推测**：所有声明都必须由工具的证据支持。如果缺少证据，请明确说明。不要猜测。\n\n*   在 'action' 字段中选择工具或 'finish'，并在 'action_input' 中提供参数或最终响应。\n\n\n当前可用工具：\n- Name: get_context_info\n  Description: 获取当前分析任务的上下文信息，例如正在分析的文件或目录。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}\n\n- Name: execute_shell\n  Description: 在当前目录（3.4.103）中执行只读 shell 命令。\n    **警告：** 此工具严格限制在当前工作目录内。所有文件操作不得引用父目录或任何其他目录。建议使用 `file` 工具在当前目录内进行探索和识别。\n    **注意：** 所有命令都在当前目录中执行。所有路径参数应相对于当前目录。禁止包含 '/' 或 '..' 的路径。\n    支持的命令：file, find, strings, grep, head, tail, readelf, cat, sort, ls。\n    禁止输出重定向（'>'、'>>'）、命令链接和目录更改。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的 shell 命令。命令将在 '3.4.103' 目录中执行。命令中的所有路径应相对于此目录。\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: r2\n  Description: \n    与 Radare2 交互式会话交互以分析当前二进制文件。注意，此工具会自动为当前分析焦点文件建立并维护 r2 会话。\n\n    主要功能：\n    - 发送 Radare2 命令并获取输出\n    - 会话状态在调用之间保持（对于同一文件）\n    - 支持使用 r2ghidra 插件进行反编译：\n    * 使用 `pdg` 命令反编译函数\n    * 提供类似 C 的伪代码输出\n    \n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"command\": {\n      \"type\": \"string\",\n      \"description\": \"Command to interact directly with Radare2\"\n    }\n  },\n  \"required\": [\n    \"command\"\n  ]\n}\n\n- Name: FunctionDelegator\n  Description: \n    函数分析委托器 - 专门分析二进制文件中函数调用链的代理。它的职责是正向追踪函数调用之间的污点数据流。你可以将潜在的外部入口点委托给此代理进行深入追踪。\n    \n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tasks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"task\": {\n            \"type\": \"string\",\n            \"description\": \"为子函数创建分析任务时，你的描述必须清楚地包括以下四点：\\n1. **目标函数**：要分析的子函数的名称和地址。\\n2. **污点入口**：污点在子函数中所在的特定寄存器或栈地址（例如，'污点在第一个参数寄存器 r0 中'）。\\n3. **污点来源**：这个污点数据在父函数中是如何产生的（例如，'这个值是父函数 main 通过调用 nvram_get(\\\"lan_ipaddr\\\") 获取的'）。\\n4. **分析目标**：清楚地指出新任务应该追踪这个新的污点入口（例如，'在子函数内追踪 r0'）。\"\n          },\n          \"task_context\": {\n            \"type\": \"string\",\n            \"description\": \"（可选）提供可能影响分析的补充上下文。这些信息不是污点流本身的一部分，但可能影响子函数的执行路径。例如：\\n- '此时寄存器 r2 的值为 0x500，表示最大缓冲区长度。'\\n- '在此调用之前，全局变量 `is_admin` 被设置为 1。'\\n- '在分析期间假设文件已成功打开。'\"\n          }\n        },\n        \"required\": [\n          \"task\"\n        ]\n      },\n      \"description\": \"要执行的函数分析任务列表。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"tasks\"\n  ]\n}\n\n- Name: TaskDelegator\n  Description: 用于查询此固件文件系统的所有已知信息。可以查询文件的已知发现以及其他文件的已知发现。你可以优先查询文件的已知发现，然后通过结果链接到其他文件的已知发现。注意：没有发现意味着当前还没有发现。\n  Parameters (JSON Schema format):\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"task\": {\n      \"type\": \"string\",\n      \"description\": \"要执行的子任务的详细描述。请指定分析对象。\"\n    },\n    \"run_in_background\": {\n      \"type\": \"boolean\",\n      \"description\": \"是否在后台运行此任务。\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"task\"\n  ]\n}\n\n**后台执行和任务调度**：\n- 在 action_input 中设置 `run_in_background: true` 可异步运行任务。\n- 后台任务完成时，结果会自动注入。\n- 当需要后台结果才能继续时，使用 'wait' 动作。\n\n调度策略（避免遗漏和重复，最大化效率）：\n1. 识别独立任务，如果不立即需要结果，在后台启动它们。\n2. 在后台任务并行运行时继续其他工作。\n3. 当依赖任务需要后台结果时使用 'wait'。\n4. 在脑海中跟踪所有启动的后台任务以避免重复。\n5. 在 'finish' 之前，确保所有后台任务都已完成并整合结果。\n\n响应格式要求：\n\n你必须以严格的 JSON 格式响应。不要在 JSON 对象之外添加任何其他文本。\n不要使用 markdown 格式（如 ```json）。直接输出单个 JSON 对象。\n\n响应必须是符合以下模式的有效 JSON 对象：\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thought\": {\n      \"type\": \"string\",\n      \"description\": \"在这里逐步思考。分析当前情况、目标、可用工具和对话历史。决定是调用工具还是使用 'finish' 动作提供最终答案。\"\n    },\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"选择下一个动作。必须是可用工具名称之一、'wait' 或 'finish'。\"\n    },\n    \"action_input\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"string\"\n        }\n      ],\n      \"description\": \"工具调用的参数或最终响应。如果 action 是工具名称，提供该工具所需的参数（通常是对象）；如果是 'finish'，使用 'final_response' 作为 action_input 的键提供最终响应（通常是包含字符串的对象）。\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"continue\",\n        \"complete\"\n      ],\n      \"description\": \"必须是 'continue'（如果选择了工具）或 'complete'（如果选择了 'finish'）。\"\n    }\n  },\n  \"required\": [\n    \"thought\",\n    \"action\",\n    \"action_input\",\n    \"status\"\n  ]\n}\n\n"}
{"role": "user", "content": "用户初始请求：\n对固件进行全面的安全分析。核心目标是识别并报告从不可信输入点到危险操作的完整、可行且**实际可利用**的攻击链。分析必须关注具有明确可利用性证据的漏洞，而不是理论缺陷。\n1. **输入点识别**：识别所有潜在的不可信输入源，包括但不限于网络接口（HTTP、API、套接字）、IPC、NVRAM/环境变量等。\n2. **数据流追踪**：追踪不可信数据在系统内的传播路径，并分析是否存在缺少适当验证、过滤或边界检查的过程。\n3. **组件交互分析**：关注组件之间的交互（例如 `nvram` get/set、IPC 通信），观察外部可控数据如何在系统内流动并影响其他组件。\n4. **利用链评估**：对于发现的每个潜在攻击链，评估其触发条件、重现步骤以及成功利用的概率。**只有找到完整且可验证的链时，发现才是有效的。**\n5. **最终输出**：报告应清楚地描述攻击者最有可能成功利用的攻击路径和安全漏洞。\n\n当前具体任务：\n分析函数 'ath_proc_read' 的代码，寻找输入点和数据流"}
{"role": "assistant", "content": "{\n  \"thought\": \"我需要分析函数 'ath_proc_read' 的代码，寻找输入点和数据流。首先，我将使用 get_context_info 来确认当前分析的文件，然后使用 r2 工具反编译 'ath_proc_read' 函数以获取代码。之后，我将分析代码以识别输入点和数据流，检查是否有不安全操作。如果需要深入追踪函数调用链，我可能会使用 FunctionDelegator。\",\n  \"action\": \"get_context_info\",\n  \"action_input\": {},\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：get_context_info\n参数：{}\n结果：\n 当前分析焦点：\n- 文件：ath_dev.ko\n- 目录：3.4.103\n- 相对于固件根目录的目录路径：lib/modules/3.4.103", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"现在我知道当前分析焦点是文件 'ath_dev.ko'。我需要使用 r2 工具来反编译 'ath_proc_read' 函数，以获取其代码并分析输入点和数据流。我将发送 r2 命令 'pdg @ sym.ath_proc_read' 来反编译该函数。如果该函数不存在，我可能需要先查找函数地址或使用其他命令。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdg @ sym.ath_proc_read\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdg @ sym.ath_proc_read\"}\n结果：\n //WARNING: Possible PIC construction at 0x0803a3d4: Changing call to branch\n//WARNING: Removing unreachable block (ram,0x0803a3d8)\n\nvoid sym.ath_proc_read(void)\n\n{\n    uint unaff_r11;\n    uint in_lr;\n    uint *puVar1;\n    uint uStack_10;\n    uchar auStack_c [4];\n    uint auStack_8 [2];\n    int32_t iVar2;\n    \n    *(*0x54 + -4) = 0x803a3c0;\n    puVar1 = *0x54 + -4 + -4;\n    *puVar1 = in_lr;\n    iVar2 = puVar1 + -4;\n    *iVar2 = *0x54;\n    *(iVar2 + -4) = unaff_r11;\n    do {\n    //WARNING: Do nothing block with infinite loop\n    } while( true );\n}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"反编译 'ath_proc_read' 函数的结果显示一个无限循环，没有明显的输入点或数据流。这可能是反编译问题或函数本身未实现。我需要使用反汇编命令 'pdf' 来获取更可靠的汇编代码，以验证函数行为。如果仍然没有有用信息，我可能需报告未找到可利用的输入点。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"pdf @ sym.ath_proc_read\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"pdf @ sym.ath_proc_read\"}\n结果：\n ┌ 40: sym.ath_proc_read (int32_t arg_8h);\n│ `- args(sp[0x8..0x8]) vars(1:sp[0x4..0x4])\n│           0x0803a3b4      0dc0a0e1       mov ip, sp\n│           0x0803a3b8      00d82de9       push {fp, ip, lr, pc}\n│           0x0803a3bc      04b04ce2       sub fp, ip, 4\n│           0x0803a3c0      0310a0e1       mov r1, r3\n│           0x0803a3c4      08309be5       ldr r3, [arg_8h]\n│           0x0803a3c8      002000e3       movw r2, .LC6               ; RELOC 32 .LC6 @ 0x08044e44 - 0x1\n│           ;-- reloc..LC6:\n│           0x0803a3cc      002040e3       movt r2, .LC6               ; RELOC 32 .LC6 @ 0x08044e44 - 0x1\n│           0x0803a3d0      003093e5       ldr r3, [r3]\n│           ;-- reloc.snprintf:\n│           0x0803a3d4      feffffeb       bl reloc.snprintf           ; RELOC 24 snprintf\n└           0x0803a3d8      00a89de8       ldm sp, {fp, sp, pc}", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"基于反汇编代码，函数 'ath_proc_read' 调用 'snprintf'，但代码似乎不完整或未实现核心逻辑（例如无限循环）。我需要进一步分析输入点和数据流。首先，检查格式字符串 .LC6 的内容以了解 snprintf 的用途。然后，分析参数传递，特别是 arg_8h 的来源，这可能是一个输入点。如果 .LC6 包含用户可控数据或存在缓冲区溢出风险，我将深入追踪。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"psz @ .LC6\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"psz @ .LC6\"}\n结果：\n [psz @ .LC6 命令无输出]", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我分析了 'ath_proc_read' 函数的反汇编代码，但发现代码不完整（有无限循环警告），且输入点和数据流不清晰。我尝试获取 .LC6 格式字符串的内容，但 'psz' 命令无输出。现在，我将使用 'iz' 命令列出所有字符串，以查找可能的格式字符串或输入源。如果仍无结果，我可能需要报告未找到可利用的输入点，因为代码似乎未实现或损坏。\",\n  \"action\": \"r2\",\n  \"action_input\": {\n    \"command\": \"iz\"\n  },\n  \"status\": \"continue\"\n}"}
{"role": "user", "content": "工具：r2\n参数：{\"command\": \"iz\"}\n结果：\n nth  paddr      vaddr      len size section        type    string\n―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n0    0x0003bf58 0x0803bf58 18  19   .rodata        ascii   ath_beaconq_config\n1    0x0003bf6c 0x0803bf6c 27  28   .rodata        ascii   ath_beacon_config_ap_timers\n2    0x0003bf88 0x0803bf88 16  17   .rodata        ascii   ath_beacon_setup\n3    0x0003bf9c 0x0803bf9c 18  19   .rodata        ascii   ath_timbcast_setup\n4    0x0003bfb0 0x0803bfb0 29  30   .rodata        ascii   ath_beacon_config_beacon_slot\n5    0x0003bfd0 0x0803bfd0 28  29   .rodata        ascii   ath_beacon_config_tsf_offset\n6    0x0003bff0 0x0803bff0 19  20   .rodata        ascii   ath_beacon_generate\n7    0x0003c004 0x0803c004 29  30   .rodata        ascii   ath_beacon_config_ibss_timers\n8    0x0003c024 0x0803c024 22  23   .rodata        ascii   ath_beacon_start_adhoc\n9    0x0003c03c 0x0803c03c 16  17   .rodata        ascii   ath_beacon_alloc\n10   0x0003c050 0x0803c050 18  19   .rodata        ascii   ath_beacon_tasklet\n11   0x0003c064 0x0803c064 18  19   .rodata        ascii   ath_bstuck_tasklet\n12   0x0003c0b4 0x0803c0b4 17  18   .rodata        ascii   ath_beacon_config\n13   0x0003c0c8 0x0803c0c8 26  27   .rodata        ascii   ath_beacon_config_sta_mode\n14   0x0003c0e4 0x0803c0e4 28  29   .rodata        ascii   ath_beacon_config_sta_timers\n15   0x0003c104 0x0803c104 17  18   .rodata        ascii   ath_bmiss_tasklet\n16   0x0003c118 0x0803c118 17  18   .rodata        ascii   ath_brssi_tasklet\n17   0x0003c12c 0x0803c12c 18  19   .rodata        ascii   ath_timbcast_alloc\n18   0x0003c140 0x0803c140 17  18   .rodata        ascii   ath_descdma_setup\n19   0x0003c154 0x0803c154 18  19   .rodata        ascii   ath_txstatus_setup\n20   0x0003c168 0x0803c168 18  19   .rodata        ascii   ath_tx_queue_uapsd\n21   0x0003c17c 0x0803c17c 27  28   .rodata        ascii   ath_tx_uapsdqnulbf_complete\n22   0x0003c198 0x0803c198 21  22   .rodata        ascii   ath_tx_uapsd_complete\n23   0x0003c1b0 0x0803c1b0 21  22   .rodata        ascii   ath_tx_uapsd_draintxq\n24   0x0003c1c8 0x0803c1c8 25  26   .rodata        ascii   ath_process_uapsd_trigger\n25   0x0003c1e4 0x0803c1e4 21  22   .rodata        ascii   ath_uapsd_sendqosnull\n26   0x0003c1fc 0x0803c1fc 24  25   .rodata        ascii   ath_tx_stage_queue_uapsd\n27   0x0003c218 0x0803c218 32  33   .rodata        ascii   ath_tx_prepend_uapsd_stage_queue\n28   0x0003c244 0x0803c244 20  21   .rodata        ascii   ath_set_tx_chainmask\n29   0x0003c25c 0x0803c25c 20  21   .rodata        ascii   ath_set_rx_chainmask\n30   0x0003c274 0x0803c274 22  23   .rodata        ascii   ath_node_set_fixedrate\n31   0x0003c28c 0x0803c28c 29  30   .rodata        ascii   ath_set_noise_detection_param\n32   0x0003c2ac 0x0803c2ac 24  25   .rodata        ascii   ath_dev_record_chan_info\n33   0x0003c2c8 0x0803c2c8 9   10   .rodata        ascii   ath_reset\n34   0x0003c2d4 0x0803c2d4 26  27   .rodata        ascii   ath_dev_stop_spectral_scan\n35   0x0003c2f0 0x0803c2f0 27  28   .rodata        ascii   ath_dev_start_spectral_scan\n36   0x0003c30c 0x0803c30c 20  21   .rodata        ascii   ath_do_pwrworkaround\n37   0x0003c324 0x0803c324 23  24   .rodata        ascii   ath_node_update_pwrsave\n38   0x0003c33c 0x0803c33c 15  16   .rodata        ascii   ath_node_detach\n39   0x0003c34c 0x0803c34c 12  13   .rodata        ascii   ath_get_caps\n40   0x0003c35c 0x0803c35c 15  16   .rodata        ascii   ath_set_country\n41   0x0003c3dc 0x0803c3dc 29  30   .rodata        ascii   ath_get_noise_detection_param\n42   0x0003c3fc 0x0803c3fc 14  15   .rodata        ascii   ath_vap_config\n43   0x0003c40c 0x0803c40c 16  17   .rodata        ascii   ath_halchan2mode\n44   0x0003c420 0x0803c420 19  20   .rodata        ascii   ath_attach_spectral\n45   0x0003c434 0x0803c434 15  16   .rodata        ascii   ath_getchannels\n46   0x0003c444 0x0803c444 17  18   .rodata        ascii   ath_set_regdomain\n47   0x0003c458 0x0803c458 18  19   .rodata        ascii   ath_process_phyerr\n48   0x0003c46c 0x0803c46c 21  22   .rodata        ascii   ath_checkandplumb_key\n49   0x0003c484 0x0803c484 21  22   .rodata        ascii   ath_vap_pause_control\n50   0x0003c49c 0x0803c49c 21  22   .rodata        ascii   ath_update_sm_pwrsave\n51   0x0003c4b4 0x0803c4b4 15  16   .rodata        ascii   ath_adjust_difs\n52   0x0003c4c4 0x0803c4c4 14  15   .rodata        ascii   ath_attach_dfs\n53   0x0003c4d4 0x0803c4d4 25  26   .rodata        ascii   ath_set_tx_antenna_select\n54   0x0003c4f0 0x0803c4f0 20  21   .rodata        ascii   ath_key_alloc_single\n55   0x0003c508 0x0803c508 18  19   .rodata        ascii   ath_key_alloc_pair\n56   0x0003c51c 0x0803c51c 19  20   .rodata        ascii   ath_key_alloc_2pair\n57   0x0003c530 0x0803c530 12  13   .rodata        ascii   ath_scan_end\n58   0x0003c548 0x0803c548 14  15   .rodata        ascii   ath_scan_start\n59   0x0003c558 0x0803c558 17  18   .rodata        ascii   ath_switch_opmode\n60   0x0003c56c 0x0803c56c 15  16   .rodata        ascii   ath_handle_intr\n61   0x0003c57c 0x0803c57c 13  14   .rodata        ascii   ath_mesg_intr\n62   0x0003c58c 0x0803c58c 15  16   .rodata        ascii   ath_common_intr\n63   0x0003c59c 0x0803c59c 8   9    .rodata        ascii   ath_intr\n64   0x0003c5a8 0x0803c5a8 15  16   .rodata        ascii   ath_node_attach\n65   0x0003c5b8 0x0803c5b8 17  18   .rodata        ascii   ath_dfs_clear_cac\n66   0x0003c5cc 0x0803c5cc 16  17   .rodata        ascii   ath_vap_stopping\n67   0x0003c5e0 0x0803c5e0 10  11   .rodata        ascii   ath_vap_up\n68   0x0003c5ec 0x0803c5ec 12  13   .rodata        ascii   ath_vap_join\n69   0x0003c5fc 0x0803c5fc 14  15   .rodata        ascii   ath_vap_listen\n70   0x0003c60c 0x0803c60c 12  13   .rodata        ascii   ath_vap_down\n71   0x0003c61c 0x0803c61c 14  15   .rodata        ascii   ath_vap_detach\n72   0x0003c650 0x0803c650 14  15   .rodata        ascii   ath_vap_attach\n73   0x0003c660 0x0803c660 19  20   .rodata        ascii   ath_get_device_info\n74   0x0003c674 0x0803c674 14  15   .rodata        ascii   ath_rate_setup\n75   0x0003c684 0x0803c684 21  22   .rodata        ascii   ath_txq_stuck_checker\n76   0x0003c69c 0x0803c69c 20  21   .rodata        ascii   ath_rx_hwreg_checker\n77   0x0003c6b4 0x0803c6b4 20  21   .rodata        ascii   ath_rx_stuck_checker\n78   0x0003c6cc 0x0803c6cc 15  16   .rodata        ascii   ath_sc_chk_intr\n79   0x0003c6dc 0x0803c6dc 13  14   .rodata        ascii   ath_calibrate\n80   0x0003c6ec 0x0803c6ec 15  16   .rodata        ascii   ath_reset_start\n81   0x0003c6fc 0x0803c6fc 21  22   .rodata        ascii   ath_wait_sc_inuse_cnt\n82   0x0003c714 0x0803c714 16  17   .rodata        ascii   ath_update_txpow\n83   0x0003c728 0x0803c728 15  16   .rodata        ascii   ath_chan_change\n84   0x0003c738 0x0803c738 13  14   .rodata        ascii   ath_reset_end\n85   0x0003c748 0x0803c748 17  18   .rodata        ascii   ath_vap_reap_txqs\n86   0x0003c75c 0x0803c75c 16  17   .rodata        ascii   ath_set_proxysta\n87   0x0003c770 0x0803c770 12  13   .rodata        ascii   ath_chan_set\n88   0x0003c780 0x0803c780 17  18   .rodata        ascii   ath_lean_chan_set\n89   0x0003c794 0x0803c794 15  16   .rodata        ascii   ath_stop_locked\n90   0x0003c7a4 0x0803c7a4 8   9    .rodata        ascii   ath_open\n91   0x0003c7b0 0x0803c7b0 15  16   .rodata        ascii   ath_gpio_config\n92   0x0003c7c0 0x0803c7c0 26  27   .rodata        ascii   ath_gpio_register_callback\n93   0x0003c7dc 0x0803c7dc 14  15   .rodata        ascii   ath_dev_attach\n94   0x0003cd47 0x0803cd47 7   8    .rodata        ascii   \\a\\b\\t\\n\\v\\f\\r\n95   0x0003cd68 0x0803cd68 12  13   .rodata        ascii   ath_dev_free\n96   0x0003cd78 0x0803cd78 16  17   .rodata        ascii   ath_node_cleanup\n97   0x0003cd8c 0x0803cd8c 16  17   .rodata        ascii   macaddr_override\n98   0x0003cda0 0x0803cda0 16  17   .rodata        ascii   ath_radio_enable\n99   0x0003cdb4 0x0803cdb4 17  18   .rodata        ascii   ath_radio_disable\n100  0x0003cdc8 0x0803cdc8 11  12   .rodata        ascii   ath_rx_init\n101  0x0003cdd4 0x0803cdd4 15  16   .rodata        ascii   ath_opmode_init\n102  0x0003cde4 0x0803cde4 12  13   .rodata        ascii   ath_stoprecv\n103  0x0003cdf4 0x0803cdf4 26  27   .rodata        ascii   ath_allocRxbufsForFreeList\n104  0x0003ce10 0x0803ce10 13  14   .rodata        ascii   ath_startrecv\n105  0x0003ce20 0x0803ce20 12  13   .rodata        ascii   ath_rx_input\n106  0x0003ce30 0x0803ce30 17  18   .rodata        ascii   ath_rx_bf_process\n107  0x0003ce44 0x0803ce44 14  15   .rodata        ascii   ath_rx_tasklet\n108  0x0003ce54 0x0803ce54 13  14   .rodata        ascii   ath_flushrecv\n109  0x0003ce68 0x0803ce68 7   32   .rodata        utf32le 64lN¢hØ\n110  0x0003cea4 0x0803cea4 4   20   .rodata        utf32le 4lhØ\n111  0x0003cf70 0x0803cf70 16  17   .rodata        ascii   ath_rx_flush_tid\n112  0x0003cf84 0x0803cf84 12  13   .rodata        ascii   ath_rx_timer\n113  0x0003cf94 0x0803cf94 24  25   .rodata        ascii   ath_addba_requestprocess\n114  0x0003cfb0 0x0803cfb0 10  11   .rodata        ascii   ath_bar_rx\n115  0x0003cfbc 0x0803cfbc 15  16   .rodata        ascii   ath_ampdu_input\n116  0x0003cfcc 0x0803cfcc 20  21   .rodata        ascii   ath_rx_aggr_teardown\n117  0x0003cfe4 0x0803cfe4 19  20   .rodata        ascii   ath_rx_node_cleanup\n118  0x0003cff8 0x0803cff8 27  28   .rodata        ascii   _ath_internal_timer_handler\n119  0x0003d014 0x0803d014 14  15   .rodata        ascii   ath_tx_stopdma\n120  0x0003d024 0x0803d024 10  11   .rodata        ascii   ath_set_tx\n121  0x0003d040 0x0803d040 14  15   .rodata        ascii   ath_txq_update\n122  0x0003d050 0x0803d050 28  29   .rodata        ascii   ath_tx_mcastqaddbuf_internal\n123  0x0003d070 0x0803d070 16  17   .rodata        ascii   ath_tx_txqaddbuf\n124  0x0003d088 0x0803d088 5   6    .rodata        ascii   \\t\\r\\b\\f\\f\n125  0x0003d08f 0x0803d08f 6   7    .rodata        ascii   $0H`l\\f\n126  0x0003d097 0x0803d097 25  26   .rodata        ascii   $0H`l_ath_tx_complete_buf\n127  0x0003d0b4 0x0803d0b4 15  16   .rodata        ascii   ath_tx_draintxq\n128  0x0003d0c4 0x0803d0c4 17  18   .rodata        ascii   ath_drain_txdataq\n129  0x0003d0d8 0x0803d0d8 18  19   .rodata        ascii   ath_tx_abortalldma\n130  0x0003d0ec 0x0803d0ec 18  19   .rodata        ascii   ath_reset_draintxq\n131  0x0003d100 0x0803d100 23  24   .rodata        ascii   ath_reset_drain_txdataq\n132  0x0003d118 0x0803d118 12  13   .rodata        ascii   ath_draintxq\n133  0x0003d134 0x0803d134 7   32   .rodata        utf32le 64lN¢hØ\n134  0x0003d170 0x0803d170 4   20   .rodata        utf32le 4lhØ\n135  0x0003d234 0x0803d234 16  17   .rodata        ascii   ath_tx_start_dma\n136  0x0003d248 0x0803d248 16  17   .rodata        ascii   ath_txto_tasklet\n137  0x0003d25c 0x0803d25c 15  16   .rodata        ascii   ath_tx_processq\n138  0x0003d26c 0x0803d26c 19  20   .rodata        ascii   ath_tx_sched_normal\n139  0x0003d280 0x0803d280 17  18   .rodata        ascii   ath_tx_sched_aggr\n140  0x0003d294 0x0803d294 17  18   .rodata        ascii   ath_tx_send_ampdu\n141  0x0003d2a8 0x0803d2a8 18  19   .rodata        ascii   ath_tx_send_normal\n142  0x0003d2bc 0x0803d2bc 15  16   .rodata        ascii   ath_addba_timer\n143  0x0003d2cc 0x0803d2cc 16  17   .rodata        ascii   ath_tx_form_aggr\n144  0x0003d2e8 0x0803d2e8 22  23   .rodata        ascii   ath_tx_sched_mimoburst\n145  0x0003d300 0x0803d300 25  26   .rodata        ascii   ath_tx_complete_aggr_rifs\n146  0x0003d31c 0x0803d31c 19  20   .rodata        ascii   ath_rx_removebuffer\n147  0x0003d330 0x0803d330 16  17   .rodata        ascii   ath_rx_addbuffer\n148  0x0003d344 0x0803d344 16  17   .rodata        ascii   ath_rx_edma_init\n149  0x0003d358 0x0803d358 19  20   .rodata        ascii   ath_rx_edma_requeue\n150  0x0003d36c 0x0803d36c 30  31   .rodata        ascii   ath_edmaAllocRxbufsForFreeList\n151  0x0003d38c 0x0803d38c 18  19   .rodata        ascii   ath_edma_startrecv\n152  0x0003d3a0 0x0803d3a0 11  12   .rodata        ascii   ath_rx_intr\n153  0x0003d3ac 0x0803d3ac 17  18   .rodata        ascii   ath_rx_bf_handler\n154  0x0003d3c0 0x0803d3c0 14  15   .rodata        ascii   ath_rx_handler\n155  0x0003d3d0 0x0803d3d0 19  20   .rodata        ascii   ath_tx_edma_process\n156  0x0003d3e4 0x0803d3e4 21  22   .rodata        ascii   ath_apply_paprd_table\n157  0x0003d3fc 0x0803d3fc 17  18   .rodata        ascii   ath_tx_paprd_init\n158  0x0003d410 0x0803d410 21  22   .rodata        ascii   ath_tx_paprd_complete\n159  0x0003d428 0x0803d428 20  21   .rodata        ascii   ath_sendpaprd_single\n160  0x0003d440 0x0803d440 13  14   .rodata        ascii   ath_paprd_cal\n161  0x0003d450 0x0803d450 14  15   .rodata        ascii   ath_paprd_send\n162  0x0003d460 0x0803d460 20  21   .rodata        ascii   ath_tx_paprd_cleanup\n163  0x0003d478 0x0803d478 21  22   .rodata        ascii   ath_tx_paprd_draintxq\n164  0x0003d490 0x0803d490 28  29   .rodata        ascii   _ath_swretry_comp_handle_tim\n165  0x0003d4b0 0x0803d4b0 40  41   .rodata        ascii   _ath_swretry_comp_aggr_dec_eligible_frms\n166  0x0003d4dc 0x0803d4dc 28  29   .rodata        ascii   ath_tx_complete_aggr_compact\n167  0x0003d4fc 0x0803d4fc 23  24   .rodata        ascii   ath_node_pwrsaveq_queue\n168  0x0003d514 0x0803d514 34  35   .rodata        ascii   ath_node_pwrsaveq_handle_ps_frames\n169  0x0003d538 0x0803d538 22  23   .rodata        ascii   ath_node_pwrsaveq_send\n170  0x0003d550 0x0803d550 23  24   .rodata        ascii   ath_node_pwrsaveq_flush\n171  0x0003d568 0x0803d568 23  24   .rodata        ascii   ath_node_pwrsaveq_drain\n172  0x0003d580 0x0803d580 21  22   .rodata        ascii   ath_node_pwrsaveq_age\n173  0x0003d598 0x0803d598 26  27   .rodata        ascii   ath_node_pwrsaveq_get_info\n174  0x0003d5b4 0x0803d5b4 20  21   .rodata        ascii   ath_tx_vap_pause_txq\n175  0x0003d5cc 0x0803d5cc 21  22   .rodata        ascii   ath_tx_vap_pause_txqs\n176  0x0003d5e4 0x0803d5e4 20  21   .rodata        ascii   ath_set_swretrystate\n177  0x0003d5fc 0x0803d5fc 16  17   .rodata        ascii   ath_handlepspoll\n178  0x0003d610 0x0803d610 25  26   .rodata        ascii   ath_exist_pendingfrm_tidq\n179  0x0003d62c 0x0803d62c 19  20   .rodata        ascii   ath_tx_drain_sxmitq\n180  0x0003d640 0x0803d640 24  25   .rodata        ascii   ath_tx_flush_node_sxmitq\n181  0x0003d65c 0x0803d65c 24  25   .rodata        ascii   ath_tx_dec_eligible_frms\n182  0x0003d678 0x0803d678 19  20   .rodata        ascii   ath_tx_mpdu_requeue\n183  0x0003d68c 0x0803d68c 18  19   .rodata        ascii   ath_tx_mpdu_resend\n184  0x0003d6a0 0x0803d6a0 30  31   .rodata        ascii   ath_atf_sc_update_node_txtoken\n185  0x0003d6c0 0x0803d6c0 21  22   .rodata        ascii   ath_calc_ack_duration\n186  0x0003d6d8 0x0803d6d8 22  23   .rodata        ascii   ath_atf_check_txtokens\n187  0x0003d6f8 0x0803d6f8 29  30   .rodata        ascii   ath_atf_node_airtime_consumed\n188  0x0003d718 0x0803d718 18  19   .rodata        ascii   ath_green_ap_start\n189  0x0003d72c 0x0803d72c 19  20   .rodata        ascii   ath_green_ap_detach\n190  0x0003d740 0x0803d740 21  22   .rodata        ascii   ath_green_ap_state_mc\n191  0x0003d758 0x0803d758 17  18   .rodata        ascii   ath_green_ap_stop\n192  0x0003d76c 0x0803d76c 20  21   .rodata        ascii   ath_ald_collect_data\n193  0x0003d784 0x0803d784 27  28   .rodata        ascii   ath_node_set_fixedrate_proc\n194  0x0003d7a0 0x0803d7a0 18  19   .rodata        ascii   ath_internal_reset\n195  0x0003d7b4 0x0803d7b4 12  13   .rodata        ascii   min_buf_resv\n196  0x0003d7c4 0x0803d7c4 12  13   .rodata        ascii   UAPSDMinfree\n197  0x0003d7d4 0x0803d7d4 10  11   .rodata        ascii   CABMinfree\n198  0x0003d7e0 0x0803d7e0 11  12   .rodata        ascii   ACVOMinfree\n199  0x0003d7ec 0x0803d7ec 11  12   .rodata        ascii   ACVIMinfree\n200  0x0003d7f8 0x0803d7f8 11  12   .rodata        ascii   ACBEMinfree\n201  0x0003d804 0x0803d804 11  12   .rodata        ascii   ACBKMinfree\n202  0x0003d818 0x0803d818 11  12   .rodata        ascii   setHALparam\n203  0x0003d82f 0x0803d82f 12  13   .rodata        ascii   HgetHALparam\n204  0x0003d878 0x0803d878 11  12   .rodata        ascii   DMABcnRespT\n205  0x0003d88f 0x0803d88f 15  16   .rodata        ascii   HGetDMABcnRespT\n206  0x0003d8a8 0x0803d8a8 10  11   .rodata        ascii   SWBcnRespT\n207  0x0003d8bf 0x0803d8bf 14  15   .rodata        ascii   HGetSWBcnRespT\n208  0x0003d8d8 0x0803d8d8 8   9    .rodata        ascii   AddSWBbo\n209  0x0003d8ef 0x0803d8ef 13  14   .rodata        ascii   HGetAddSWBAbo\n210  0x0003d908 0x0803d908 6   7    .rodata        ascii   6MBAck\n211  0x0003d91f 0x0803d91f 10  11   .rodata        ascii   HGet5MBAck\n212  0x0003d938 0x0803d938 11  12   .rodata        ascii   CWMIgnExCCA\n213  0x0003d94f 0x0803d94f 15  16   .rodata        ascii   HGetCWMIgnExCCA\n214  0x0003d968 0x0803d968 11  12   .rodata        ascii   CCADetLevel\n215  0x0003d97f 0x0803d97f 15  16   .rodata        ascii   HGetCCADetLevel\n216  0x0003d998 0x0803d998 12  13   .rodata        ascii   CCADetMargin\n217  0x0003d9af 0x0803d9af 16  17   .rodata        ascii   HGetCCADetMargin\n218  0x0003d9c8 0x0803d9c8 9   10   .rodata        ascii   ForceBias\n219  0x0003d9df 0x0803d9df 13  14   .rodata        ascii   HGetForceBias\n220  0x0003d9f8 0x0803d9f8 11  12   .rodata        ascii   ForBiasAuto\n221  0x0003da0f 0x0803da0f 15  16   .rodata        ascii   HGetForBiasAuto\n222  0x0003da28 0x0803da28 11  12   .rodata        ascii   PCIEPwrSvEn\n223  0x0003da3f 0x0803da3f 15  16   .rodata        ascii   HGetPCIEPwrSvEn\n224  0x0003da58 0x0803da58 11  12   .rodata        ascii   PCIEL1SKPEn\n225  0x0003da6f 0x0803da6f 15  16   .rodata        ascii   HGetPCIEL1SKPEn\n226  0x0003da88 0x0803da88 10  11   .rodata        ascii   PCIEClkReq\n227  0x0003da9f 0x0803da9f 14  15   .rodata        ascii   HGetPCIEClkReq\n228  0x0003dab8 0x0803dab8 8   9    .rodata        ascii   PCIEWAEN\n229  0x0003dacf 0x0803dacf 12  13   .rodata        ascii   HGetPCIEWAEN\n230  0x0003dae8 0x0803dae8 10  11   .rodata        ascii   PCIEDETACH\n231  0x0003daff 0x0803daff 14  15   .rodata        ascii   HGetPCIEDETACH\n232  0x0003db18 0x0803db18 10  11   .rodata        ascii   PCIEPwRset\n233  0x0003db2f 0x0803db2f 14  15   .rodata        ascii   HGetPCIEPwRset\n234  0x0003db48 0x0803db48 11  12   .rodata        ascii   PCIERestore\n235  0x0003db5f 0x0803db5f 15  16   .rodata        ascii   HGetPCIERestore\n236  0x0003db78 0x0803db78 5   6    .rodata        ascii   HTEna\n237  0x0003db8f 0x0803db8f 9   10   .rodata        ascii   HGetHTEna\n238  0x0003dba8 0x0803dba8 9   10   .rodata        ascii   DisTurboG\n239  0x0003dbbf 0x0803dbbf 13  14   .rodata        ascii   HGetDisTurboG\n240  0x0003dbd8 0x0803dbd8 10  11   .rodata        ascii   OFDMTrgLow\n241  0x0003dbef 0x0803dbef 14  15   .rodata        ascii   HGetOFDMTrgLow\n242  0x0003dc08 0x0803dc08 9   10   .rodata        ascii   OFDMTrgHi\n243  0x0003dc1f 0x0803dc1f 13  14   .rodata        ascii   HGetOFDMTrgHi\n244  0x0003dc38 0x0803dc38 8   9    .rodata        ascii   CCKTrgHi\n245  0x0003dc4f 0x0803dc4f 12  13   .rodata        ascii   HGetCCKTrgHi\n246  0x0003dc68 0x0803dc68 9   10   .rodata        ascii   CCKTrgLow\n247  0x0003dc7f 0x0803dc7f 13  14   .rodata        ascii   HGetCCKTrgLow\n248  0x0003dc98 0x0803dc98 6   7    .rodata        ascii   ANIEna\n249  0x0003dcaf 0x0803dcaf 10  11   .rodata        ascii   HGetANIEna\n250  0x0003dcc8 0x0803dcc8 8   9    .rodata        ascii   CCAThEna\n251  0x0003dcdf 0x0803dcdf 12  13   .rodata        ascii   HGetCCAThEna\n252  0x0003dcf8 0x0803dcf8 11  12   .rodata        ascii   NoiseImmLvl\n253  0x0003dd0f 0x0803dd0f 15  16   .rodata        ascii   HGetNoiseImmLvl\n254  0x0003dd28 0x0803dd28 11  12   .rodata        ascii   OFDMWeakDet\n255  0x0003dd3f 0x0803dd3f 15  16   .rodata        ascii   HGetOFDMWeakDet\n256  0x0003dd58 0x0803dd58 10  11   .rodata        ascii   CCKWeakThr\n257  0x0003dd6f 0x0803dd6f 14  15   .rodata        ascii   HGetCCKWeakThr\n258  0x0003dd88 0x0803dd88 10  11   .rodata        ascii   SpurImmLvl\n259  0x0003dd9f 0x0803dd9f 14  15   .rodata        ascii   HGetSpurImmLvl\n260  0x0003ddb8 0x0803ddb8 10  11   .rodata        ascii   FIRStepLvl\n261  0x0003ddcf 0x0803ddcf 14  15   .rodata        ascii   HGetFIRStepLvl\n262  0x0003dde8 0x0803dde8 9   10   .rodata        ascii   RSSIThrHi\n263  0x0003ddff 0x0803ddff 13  14   .rodata        ascii   HGetRSSIThrHi\n264  0x0003de18 0x0803de18 10  11   .rodata        ascii   RSSIThrLow\n265  0x0003de2f 0x0803de2f 14  15   .rodata        ascii   HGetRSSIThrLow\n266  0x0003de48 0x0803de48 8   9    .rodata        ascii   DivtyCtl\n267  0x0003de5f 0x0803de5f 12  13   .rodata        ascii   HGetDivtyCtl\n268  0x0003de78 0x0803de78 7   8    .rodata        ascii   AntSwap\n269  0x0003de8f 0x0803de8f 11  12   .rodata        ascii   HGetAntSwap\n270  0x0003dea8 0x0803dea8 8   9    .rodata        ascii   DisPACal\n271  0x0003debf 0x0803debf 12  13   .rodata        ascii   HGetDisPACal\n272  0x0003ded8 0x0803ded8 6   7    .rodata        ascii   HALDbg\n273  0x0003deef 0x0803deef 10  11   .rodata        ascii   HGetHALDbg\n274  0x0003df08 0x0803df08 12  13   .rodata        ascii   RegRead_base\n275  0x0003df1f 0x0803df1f 12  13   .rodata        ascii   HGetRegReads\n276  0x0003df38 0x0803df38 8   9    .rodata        ascii   keycache\n277  0x0003df4f 0x0803df4f 13  14   .rodata        ascii   Hget_keycache\n278  0x0003df68 0x0803df68 7   8    .rodata        ascii   TxBFCTL\n279  0x0003df7f 0x0803df7f 11  12   .rodata        ascii   HGetTxBFCTL\n280  0x0003df98 0x0803df98 12  13   .rodata        ascii   printBBDebug\n281  0x0003dfaf 0x0803dfaf 15  16   .rodata        ascii   Hg_printBBDebug\n282  0x0003dfc8 0x0803dfc8 11  12   .rodata        ascii   txchainmask\n283  0x0003dfdf 0x0803dfdf 16  17   .rodata        ascii   Hget_txchainmask\n284  0x0003dff8 0x0803dff8 11  12   .rodata        ascii   rxchainmask\n285  0x0003e00f 0x0803e00f 16  17   .rodata        ascii   Hget_rxchainmask\n286  0x0003e028 0x0803e028 11  12   .rodata        ascii   txchmaskleg\n287  0x0003e03f 0x0803e03f 16  17   .rodata        ascii   Hget_txchmaskleg\n288  0x0003e058 0x0803e058 11  12   .rodata        ascii   rxchmaskleg\n289  0x0003e06f 0x0803e06f 16  17   .rodata        ascii   Hget_rxchmaskleg\n290  0x0003e088 0x0803e088 12  13   .rodata        ascii   chainmasksel\n291  0x0003e09f 0x0803e09f 17  18   .rodata        ascii   Hget_chainmasksel\n292  0x0003e0b8 0x0803e0b8 5   6    .rodata        ascii   AMPDU\n293  0x0003e0cf 0x0803e0cf 9   10   .rodata        ascii   HgetAMPDU\n294  0x0003e0e8 0x0803e0e8 8   9    .rodata        ascii   AMPDULim\n295  0x0003e0ff 0x0803e0ff 12  13   .rodata        ascii   HgetAMPDULim\n296  0x0003e118 0x0803e118 11  12   .rodata        ascii   AMPDUFrames\n297  0x0003e12f 0x0803e12f 15  16   .rodata        ascii   HgetAMPDUFrames\n298  0x0003e148 0x0803e148 12  13   .rodata        ascii   AMPDURxBsize\n299  0x0003e15f 0x0803e15f 16  17   .rodata        ascii   HgetAMPDURxBsize\n300  0x0003e178 0x0803e178 4   5    .rodata        ascii   LDPC\n301  0x0003e18f 0x0803e18f 8   9    .rodata        ascii   HgetLDPC\n302  0x0003e1a8 0x0803e1a8 5   6    .rodata        ascii   burst\n303  0x0003e1bf 0x0803e1bf 10  11   .rodata        ascii   Hget_burst\n304  0x0003e1d8 0x0803e1d8 9   10   .rodata        ascii   burst_dur\n305  0x0003e1ef 0x0803e1ef 14  15   .rodata        ascii   Hget_burst_dur\n306  0x0003e208 0x0803e208 8   9    .rodata        ascii   AggrProt\n307  0x0003e21f 0x0803e21f 12  13   .rodata        ascii   HgetAggrProt\n308  0x0003e238 0x0803e238 11  12   .rodata        ascii   AggrProtDur\n309  0x0003e24f 0x0803e24f 15  16   .rodata        ascii   HgetAggrProtDur\n310  0x0003e268 0x0803e268 11  12   .rodata        ascii   AggrProtMax\n311  0x0003e27f 0x0803e27f 15  16   .rodata        ascii   HgetAggrProtMax\n312  0x0003e298 0x0803e298 10  11   .rodata        ascii   TXPowLim2G\n313  0x0003e2af 0x0803e2af 14  15   .rodata        ascii   HgetTxPowLim2G\n314  0x0003e2c8 0x0803e2c8 10  11   .rodata        ascii   TXPowLim5G\n315  0x0003e2df 0x0803e2df 14  15   .rodata        ascii   HgetTxPowLim5G\n316  0x0003e2f8 0x0803e2f8 8   9    .rodata        ascii   TXPwrOvr\n317  0x0003e30f 0x0803e30f 12  13   .rodata        ascii   HgetTXPwrOvr\n318  0x0003e328 0x0803e328 9   10   .rodata        ascii   DisASPMWk\n319  0x0003e33f 0x0803e33f 13  14   .rodata        ascii   HgetDisASPMWk\n320  0x0003e358 0x0803e358 7   8    .rodata        ascii   EnaASPM\n321  0x0003e36f 0x0803e36f 11  12   .rodata        ascii   HgetEnaASPM\n322  0x0003e388 0x0803e388 10  11   .rodata        ascii   BcnNoReset\n323  0x0003e39f 0x0803e39f 14  15   .rodata        ascii   HgetBcnNoReset\n324  0x0003e3b8 0x0803e3b8 8   9    .rodata        ascii   CABlevel\n325  0x0003e3cf 0x0803e3cf 12  13   .rodata        ascii   HgetCABlevel\n326  0x0003e3e8 0x0803e3e8 8   9    .rodata        ascii   ATHDebug\n327  0x0003e3ff 0x0803e3ff 12  13   .rodata        ascii   HgetATHDebug\n328  0x0003e418 0x0803e418 7   8    .rodata        ascii   tpscale\n329  0x0003e42f 0x0803e42f 12  13   .rodata        ascii   Hget_tpscale\n330  0x0003e447 0x0803e447 13  14   .rodata        ascii   Hget_rxq_info\n331  0x0003e460 0x0803e460 10  11   .rodata        ascii   acktimeout\n332  0x0003e477 0x0803e477 15  16   .rodata        ascii   Hget_acktimeout\n333  0x0003e490 0x0803e490 11  12   .rodata        ascii   rximt_first\n334  0x0003e4a7 0x0803e4a7 16  17   .rodata        ascii   Hget_rximt_first\n335  0x0003e4c0 0x0803e4c0 10  11   .rodata        ascii   rximt_last\n336  0x0003e4d7 0x0803e4d7 15  16   .rodata        ascii   Hget_rximt_last\n337  0x0003e4f0 0x0803e4f0 11  12   .rodata        ascii   tximt_first\n338  0x0003e507 0x0803e507 16  17   .rodata        ascii   Hget_tximt_first\n339  0x0003e520 0x0803e520 10  11   .rodata        ascii   tximt_last\n340  0x0003e537 0x0803e537 15  16   .rodata        ascii   Hget_tximt_last\n341  0x0003e550 0x0803e550 5   6    .rodata        ascii   AMSDU\n342  0x0003e567 0x0803e567 9   10   .rodata        ascii   HgetAMSDU\n343  0x0003e580 0x0803e580 8   9    .rodata        ascii   retrydur\n344  0x0003e597 0x0803e597 13  14   .rodata        ascii   Hget_retrydur\n345  0x0003e5b0 0x0803e5b0 11  12   .rodata        ascii   hbrPER_high\n346  0x0003e5c7 0x0803e5c7 16  17   .rodata        ascii   Hget_hbrPER_high\n347  0x0003e5e0 0x0803e5e0 10  11   .rodata        ascii   hbrPER_low\n348  0x0003e5f7 0x0803e5f7 15  16   .rodata        ascii   Hget_hbrPER_low\n349  0x0003e610 0x0803e610 6   7    .rodata        ascii   txstbc\n350  0x0003e627 0x0803e627 11  12   .rodata        ascii   Hget_txstbc\n351  0x0003e640 0x0803e640 6   7    .rodata        ascii   rxstbc\n352  0x0003e657 0x0803e657 11  12   .rodata        ascii   Hget_rxstbc\n353  0x0003e670 0x0803e670 8   9    .rodata        ascii   immunity\n354  0x0003e687 0x0803e687 13  14   .rodata        ascii   Hget_immunity\n355  0x0003e6a0 0x0803e6a0 12  13   .rodata        ascii   limit_legacy\n356  0x0003e6b7 0x0803e6b7 15  16   .rodata        ascii   Hg_limit_legacy\n357  0x0003e6cf 0x0803e6cf 14  15   .rodata        ascii   Hget_ledcustom\n358  0x0003e6e8 0x0803e6e8 13  14   .rodata        ascii   set_ledcustom\n359  0x0003e6ff 0x0803e6ff 12  13   .rodata        ascii   Hget_swapled\n360  0x0003e718 0x0803e718 11  12   .rodata        ascii   set_swapled\n361  0x0003e72f 0x0803e72f 16  17   .rodata        ascii   Hget_buff_thresh\n362  0x0003e748 0x0803e748 15  16   .rodata        ascii   set_buff_thresh\n363  0x0003e75f 0x0803e75f 15  16   .rodata        ascii   Hget_dcs_intrth\n364  0x0003e778 0x0803e778 14  15   .rodata        ascii   set_dcs_intrth\n365  0x0003e78f 0x0803e78f 14  15   .rodata        ascii   Hget_dcs_errth\n366  0x0003e7a8 0x0803e7a8 13  14   .rodata        ascii   set_dcs_errth\n367  0x0003e7bf 0x0803e7bf 15  16   .rodata        ascii   Hg_dcs_phyerrth\n368  0x0003e7d8 0x0803e7d8 14  15   .rodata        ascii   s_dcs_phyerrth\n369  0x0003e7ef 0x0803e7ef 14  15   .rodata        ascii   Hget_cvtimeout\n370  0x0003e808 0x0803e808 13  14   .rodata        ascii   set_cvtimeout\n371  0x0003e820 0x0803e820 12  13   .rodata        ascii   set_bcnburst\n372  0x0003e837 0x0803e837 13  14   .rodata        ascii   Hget_bcnburst\n373  0x0003e850 0x0803e850 12  13   .rodata        ascii   setCountryID\n374  0x0003e867 0x0803e867 13  14   .rodata        ascii   HgetCountryID\n375  0x0003e880 0x0803e880 12  13   .rodata        ascii   setRegdomain\n376  0x0003e897 0x0803e897 13  14   .rodata        ascii   HgetRegdomain\n377  0x0003e8b0 0x0803e8b0 8   9    .rodata        ascii   setCH144\n378  0x0003e8c7 0x0803e8c7 9   10   .rodata        ascii   HgetCH144\n379  0x0003e8e0 0x0803e8e0 13  14   .rodata        ascii   enable_macreq\n380  0x0003e8f8 0x0803e8f8 9   10   .rodata        ascii   setHwaddr\n381  0x0003e90f 0x0803e90f 10  11   .rodata        ascii    getHwaddr\n382  0x0003e928 0x0803e928 10  11   .rodata        ascii   setCountry\n383  0x0003e93f 0x0803e93f 11  12   .rodata        ascii    getCountry\n384  0x0003e958 0x0803e958 9   10   .rodata        ascii   amemPrint\n385  0x0003e96f 0x0803e96f 16  17   .rodata        ascii   Hg_PhyRestartWar\n386  0x0003e988 0x0803e988 15  16   .rodata        ascii   s_PhyRestartWar\n387  0x0003e9a0 0x0803e9a0 10  11   .rodata        ascii   dyntxchain\n388  0x0003e9b7 0x0803e9b7 15  16   .rodata        ascii   Hget_dyntxchain\n389  0x0003e9d0 0x0803e9d0 8   9    .rodata        ascii   disp_tpc\n390  0x0003e9e7 0x0803e9e7 16  17   .rodata        ascii   HgetBlkReportFld\n391  0x0003ea00 0x0803ea00 15  16   .rodata        ascii   setBlkReportFld\n392  0x0003ea17 0x0803ea17 16  17   .rodata        ascii   HgetDropSTAQuery\n393  0x0003ea30 0x0803ea30 15  16   .rodata        ascii   setDropSTAQuery\n394  0x0003ea48 0x0803ea48 15  16   .rodata        ascii   set_dscp_ovride\n395  0x0003ea5f 0x0803ea5f 16  17   .rodata        ascii   Hget_dscp_ovride\n396  0x0003ea78 0x0803ea78 14  15   .rodata        ascii   reset_dscp_map\n397  0x0003ea8f 0x0803ea8f 15  16   .rodata        ascii   Hg_dscp_tid_map\n398  0x0003eaa8 0x0803eaa8 14  15   .rodata        ascii   s_dscp_tid_map\n399  0x0003eabf 0x0803eabf 15  16   .rodata        ascii   HgIgmpDscpOvrid\n400  0x0003ead8 0x0803ead8 14  15   .rodata        ascii   sIgmpDscpOvrid\n401  0x0003eaef 0x0803eaef 16  17   .rodata        ascii   HgIgmpDscpTidMap\n402  0x0003eb08 0x0803eb08 15  16   .rodata        ascii   sIgmpDscpTidMap\n403  0x0003eb1f 0x0803eb1f 15  16   .rodata        ascii   HgHmmcDscpOvrid\n404  0x0003eb38 0x0803eb38 14  15   .rodata        ascii   sHmmcDscpOvrid\n405  0x0003eb4f 0x0803eb4f 16  17   .rodata        ascii   HgHmmcDscpTidMap\n406  0x0003eb68 0x0803eb68 15  16   .rodata        ascii   sHmmcDscpTidMap\n407  0x0003eb80 0x0803eb80 10  11   .rodata        ascii   dcs_enable\n408  0x0003eb97 0x0803eb97 15  16   .rodata        ascii   Hget_dcs_enable\n409  0x0003ebb0 0x0803ebb0 11  12   .rodata        ascii   set_fw_hang\n410  0x0003ebc8 0x0803ebc8 15  16   .rodata        ascii   set_fw_recovery\n411  0x0003ebdf 0x0803ebdf 16  17   .rodata        ascii   Hget_fw_recovery\n412  0x0003ebf7 0x0803ebf7 14  15   .rodata        ascii   Hget_total_PER\n413  0x0003ec10 0x0803ec10 10  11   .rodata        ascii   setctsrate\n414  0x0003ec27 0x0803ec27 12  13   .rodata        ascii   Hget_ctsrate\n415  0x0003ec40 0x0803ec40 10  11   .rodata        ascii   antgain_2g\n416  0x0003ec57 0x0803ec57 15  16   .rodata        ascii   Hget_antgain_2g\n417  0x0003ec70 0x0803ec70 10  11   .rodata        ascii   antgain_5g\n418  0x0003ec87 0x0803ec87 15  16   .rodata        ascii   Hget_antgain_5g\n419  0x0003eca0 0x0803eca0 12  13   .rodata        ascii   disablestats\n420  0x0003ecb7 0x0803ecb7 13  14   .rodata        ascii   Hget_disstats\n421  0x0003ecd0 0x0803ecd0 11  12   .rodata        ascii   get_if_path\n422  0x0003ece8 0x0803ece8 8   9    .rodata        ascii   aldstats\n423  0x0003ed00 0x0803ed00 12  13   .rodata        ascii   allowpromisc\n424  0x0003ed17 0x0803ed17 16  17   .rodata        ascii   Hgetallowpromisc\n425  0x0003ed30 0x0803ed30 12  13   .rodata        ascii   acs_bkscanen\n426  0x0003ed47 0x0803ed47 15  16   .rodata        ascii   Hg_acs_bkscanen\n427  0x0003ed60 0x0803ed60 13  14   .rodata        ascii   acs_scanintvl\n428  0x0003ed77 0x0803ed77 15  16   .rodata        ascii   Hg_acsscanintvl\n429  0x0003ed90 0x0803ed90 11  12   .rodata        ascii   acs_rssivar\n430  0x0003eda7 0x0803eda7 16  17   .rodata        ascii   Hget_acs_rssivar\n431  0x0003edc0 0x0803edc0 13  14   .rodata        ascii   acs_chloadvar\n432  0x0003edd7 0x0803edd7 15  16   .rodata        ascii   Hg_acschloadvar\n433  0x0003edf0 0x0803edf0 11  12   .rodata        ascii   acs_lmtobss\n434  0x0003ee07 0x0803ee07 15  16   .rodata        ascii   Hget_acslmtobss\n435  0x0003ee20 0x0803ee20 13  14   .rodata        ascii   acs_ctrlflags\n436  0x0003ee37 0x0803ee37 15  16   .rodata        ascii   Hg_acsctrlflags\n437  0x0003ee50 0x0803ee50 12  13   .rodata        ascii   acs_dbgtrace\n438  0x0003ee67 0x0803ee67 15  16   .rodata        ascii   Hg_acs_dbgtrace\n439  0x0003ee7f 0x0803ee7f 15  16   .rodata        ascii   Hget_radio_type\n440  0x0003ee98 0x0803ee98 15  16   .rodata        ascii   set_enable_rate\n441  0x0003eeaf 0x0803eeaf 16  17   .rodata        ascii   Hget_enable_rate\n442  0x0003eec8 0x0803eec8 14  15   .rodata        ascii   set_en_sel_rts\n443  0x0003eedf 0x0803eedf 15  16   .rodata        ascii   Hget_en_sel_rts\n444  0x0003eef8 0x0803eef8 12  13   .rodata        ascii   set_sa_param\n445  0x0003ef0f 0x0803ef0f 13  14   .rodata        ascii   Hget_sa_param\n446  0x0003ef28 0x0803ef28 14  15   .rodata        ascii   blockdfschlist\n447  0x0003ef3f 0x0803ef3f 15  16   .rodata        ascii   Hg_blkdfschlist\n448  0x0003ef58 0x0803ef58 14  15   .rodata        ascii   atfstrictsched\n449  0x0003ef6f 0x0803ef6f 16  17   .rodata        ascii   Hgatfstrictsched\n450  0x0003ef88 0x0803ef88 12  13   .rodata        ascii   staDFSEnable\n451  0x0003ef9f 0x0803ef9f 32  33   .rodata        ascii   Hget_staDFSEnableath_iw_getparam\n452  0x0003efc0 0x0803efc0 15  16   .rodata        ascii   ath_iw_setparam\n453  0x0003f000 0x0803f000 15  16   .rodata        ascii   ath_rxbuf_alloc\n454  0x0003f010 0x0803f010 22  23   .rodata        ascii   ath_adhoc_netlink_init\n455  0x0003f450 0x0803f450 49  50   .rodata.str1.4 ascii   %s: unable to update h/w beacon queue parameters\\n\n456  0x0003f484 0x0803f484 38  39   .rodata.str1.4 ascii   %s: nexttbtt %u intval %u flags 0x%x \\n\n457  0x0003f4ac 0x0803f4ac 16  17   .rodata.str1.4 ascii   %s: m %p len %u\\n\n458  0x0003f4c0 0x0803f4c0 21  22   .rodata.str1.4 ascii   too many beacon vaps\n459  0x0003f4d8 0x0803f4d8 7   8    .rodata.str1.4 ascii   stagger\n460  0x0003f4e0 0x0803f4e0 5   6    .rodata.str1.4 ascii   burst\n461  0x0003f4e8 0x0803f4e8 38  39   .rodata.str1.4 ascii   for vap up reason if_id can not be any\n462  0x0003f510 0x0803f510 40  41   .rodata.str1.4 ascii   for vap down reason if_id can not be any\n463  0x0003f53c 0x0803f53c 39  40   .rodata.str1.4 ascii   if_id does not match in the beacon slot\n464  0x0003f564 0x0803f564 29  30   .rodata.str1.4 ascii   %s: move VAP %d from slot 0 \\n\n465  0x0003f584 0x0803f584 30  31   .rodata.str1.4 ascii   %s: insert STA Vap in slot 0 \\n\n466  0x0003f5a4 0x0803f5a4 26  27   .rodata.str1.4 ascii   beacon buf can not be null\n467  0x0003f5c0 0x0803f5c0 27  28   .rodata.str1.4 ascii   beacon wbuf can not be null\n468  0x0003f5dc 0x0803f5dc 68  69   .rodata.str1.4 ascii   %s: %s beacons, bslot %d intval %u tsfadjust %llu tsfadjust_le %llu\\n\n469  0x0003f624 0x0803f624 23  24   .rodata.str1.4 ascii   %s: avp=%p av_bcbuf=%p\\n\n470  0x0003f63c 0x0803f63c 60  61   .rodata.str1.4 ascii   %s: Moving frames from fmsq_id %d (counter_id %d) to mcastq\\n\n471  0x0003f67c 0x0803f67c 32  33   .rodata.str1.4 ascii   %s: flush previous cabq traffic\\n\n472  0x0003f6a0 0x0803f6a0 54  55   .rodata.str1.4 ascii   %s[%d]  Unable to stop CABQ. Now Stopping all Queues \\n\n473  0x0003f6d8 0x0803f6d8 52  53   .rodata.str1.4 ascii   Oops! burstbcn_cabq not empty but axq_link is NULL?\\n\n474  0x0003f710 0x0803f710 24  25   .rodata.str1.4 ascii    %s: link(%p)=%llx (%p)\\n\n475  0x0003f72c 0x0803f72c 53  54   .rodata.str1.4 ascii   can not configure IBSS vap when other vaps are active\n476  0x0003f764 0x0803f764 42  43   .rodata.str1.4 ascii   %s:IBSS nexttbtt %u intval %u flags 0x%x \\n\n477  0x0003f790 0x0803f790 23  24   .rodata.str1.4 ascii   %s: TXDP%u = %llx (%p)\\n\n478  0x0003f7a8 0x0803f7a8 20  21   .rodata.str1.4 ascii   %s: cannot get wbuf\\n\n479  0x0003f7c0 0x0803f7c0 34  35   .rodata.str1.4 ascii   %s: missed %u consecutive beacons\\n\n480  0x0003f7e4 0x0803f7e4 54  55   .rodata.str1.4 ascii   %s: busy times: rx_clear=%d, rx_frame=%d, tx_frame=%d\\n\n481  0x0003f81c 0x0803f81c 32  33   .rodata.str1.4 ascii   %s: unable to obtain busy times\\n\n482  0x0003f840 0x0803f840 31  32   .rodata.str1.4 ascii   %s: beacon is officially stuck\\n\n483  0x0003f860 0x0803f860 26  27   .rodata.str1.4 ascii   Busy environment detected\\n\n484  0x0003f87c 0x0803f87c 22  23   .rodata.str1.4 ascii   Interference detected\\n\n485  0x0003f894 0x0803f894 38  39   .rodata.str1.4 ascii   rx_clear=%d, rx_frame=%d, tx_frame=%d\\n\n486  0x0003f8bc 0x0803f8bc 39  40   .rodata.str1.4 ascii   %s: resume beacon xmit after %u misses\\n\n487  0x0003f8e4 0x0803f8e4 51  52   .rodata.str1.4 ascii   %s: slot %d [tsf %llu tsftu %u intval %u] if_id %d\\n\n488  0x0003f918 0x0803f918 34  35   .rodata.str1.4 ascii   %s: beacon queue %u did not stop?\\n\n489  0x0003f93c 0x0803f93c 48  49   .rodata.str1.4 ascii   <7>%s: stuck beacon; resetting (bmiss count %u)\\n\n490  0x0003f970 0x0803f970 48  49   .rodata.str1.4 ascii   %s: Detected interference, sending eacs message\\n\n491  0x0003f9a4 0x0803f9a4 7   8    .rodata.str1.4 ascii   UNKNOWN\n492  0x0003f9ac 0x0803f9ac 10  11   .rodata.str1.4 ascii   Not locked\n493  0x0003f9bc 0x0803f9bc 44  45   .rodata.str1.4 ascii   %s: reason %s if_id %d opmode %s  nslots %d\\n\n494  0x0003f9ec 0x0803f9ec 130 131  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_beacon.c\n495  0x0003fa70 0x0803fa70 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n496  0x0003fa90 0x0803fa90 46  47   .rodata.str1.4 ascii   %s: no beacon vaps ignore reason %d if_id %d \\n\n497  0x0003fac0 0x0803fac0 34  35   .rodata.str1.4 ascii   %s: reason %s if_id %d opmode %s \\n\n498  0x0003fae4 0x0803fae4 8   9    .rodata.str1.4 ascii   VAP_DOWN\n499  0x0003faf4 0x0803faf4 46  47   .rodata.str1.4 ascii   %s:allocating slot 0 to STA Vap with if_id %d\\n\n500  0x0003fb24 0x0803fb24 56  57   .rodata.str1.4 ascii   %s:(STA+STA case) primary STA vap with if_id %d exists \\n\n501  0x0003fb60 0x0803fb60 44  45   .rodata.str1.4 ascii   the first slot does not have a valid vap id\n502  0x0003fb90 0x0803fb90 45  46   .rodata.str1.4 ascii   the first slot does not point to a valid vap\n503  0x0003fbc0 0x0803fbc0 29  30   .rodata.str1.4 ascii    beacon tsf stamp 0x%x:0x%x \\n\n504  0x0003fbe0 0x0803fbe0 128 129  .rodata.str1.4 ascii   %s: tsf %llu tsf:tu %u intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u cfp:period %u maxdur %u next %u timoffset %u\\n\n505  0x0003fc64 0x0803fc64 30  31   .rodata.str1.4 ascii   %s: AP nexttbtt %d intval %d \\n\n506  0x0003fc84 0x0803fc84 32  33   .rodata.str1.4 ascii   %s: # beacon vaps %d nslots %d \\n\n507  0x0003fca8 0x0803fca8 30  31   .rodata.str1.4 ascii   slot %d vapid %d vap mode %s \\n\n508  0x0003fccc 0x0803fccc 61  62   .rodata.str1.4 ascii   chip op mode is AP, ignore beacon config request from sta vap\n509  0x0003fd0c 0x0803fd0c 6   7    .rodata.str1.4 ascii   VAP_UP\n510  0x0003fd14 0x0803fd14 5   6    .rodata.str1.4 ascii   RESET\n511  0x0003fd1c 0x0803fd1c 13  14   .rodata.str1.4 ascii   OPMODE_SWITCH\n512  0x0003fd2c 0x0803fd2c 4   5    .rodata.str1.4 ascii   IBSS\n513  0x0003fd34 0x0803fd34 6   7    .rodata.str1.4 ascii   HOSTAP\n514  0x0003fd3c 0x0803fd3c 7   8    .rodata.str1.4 ascii   MONITOR\n515  0x0003fd44 0x0803fd44 7   8    .rodata.str1.4 ascii   RAW_ADC\n516  0x0003fd4c 0x0803fd4c 47  48   .rodata.str1.4 ascii   %s: %s DMA: %u buffers %u desc/buf %d desc_len\\n\n517  0x0003fd7c 0x0803fd7c 31  32   .rodata.str1.4 ascii   %s: ath_desc not DWORD aligned\\n\n518  0x0003fd9c 0x0803fd9c 37  38   .rodata.str1.4 ascii   %s: %s DMA map: %p (%u) -> %llx (%u)\\n\n519  0x0003fdc4 0x0803fdc4 11  12   .rodata.str1.4 ascii   uapsd_qnull\n520  0x0003fdd0 0x0803fdd0 53  54   .rodata.str1.4 ascii   failed to allocate UAPSD QoS NULL tx descriptors: %d\\n\n521  0x0003fe08 0x0803fe08 39  40   .rodata.str1.4 ascii   failed to allocate UAPSD QoS NULL wbuf\\n\n522  0x0003fe30 0x0803fe30 14  15   .rodata.str1.4 ascii   %s: depth %d \\n\n523  0x0003fe40 0x0803fe40 34  35   .rodata.str1.4 ascii   %s: Error: bf_node is null. bf=%p\\n\n524  0x0003fe64 0x0803fe64 30  31   .rodata.str1.4 ascii   %s: ath_node is null in bf %p\\n\n525  0x0003fe84 0x0803fe84 27  28   .rodata.str1.4 ascii   bf_lastfrm != bf->bf_lastbf\n526  0x0003fea0 0x0803fea0 14  15   .rodata.str1.4 ascii   bf_q NOT EMPTY\n527  0x0003feb0 0x0803feb0 10  11   .rodata.str1.4 ascii   bf_q EMPTY\n528  0x0003febc 0x0803febc 10  11   .rodata.str1.4 ascii   Not locked\n529  0x0003fecc 0x0803fecc 43  44   .rodata.str1.4 ascii   ath_tx_uapsd_draintxq: ERR head %d tail %d\\n\n530  0x0003fef8 0x0803fef8 21  22   .rodata.str1.4 ascii   bf->bf_lastbf is NULL\n531  0x0003ff10 0x0803ff10 129 130  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_uapsd.c\n532  0x0003ff94 0x0803ff94 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n533  0x0003ffb4 0x0803ffb4 38  39   .rodata.str1.4 ascii   %s: HW queue size %d SW queue size %d\\n\n534  0x0003ffdc 0x0803ffdc 25  26   .rodata.str1.4 ascii   %s: bf %p ds %p depth %d\\n\n535  0x0003fff8 0x0803fff8 36  37   .rodata.str1.4 ascii   %s: qosnull frame sent to sc_uapsdq\\n\n536  0x00040020 0x08040020 32  33   .rodata.str1.4 ascii   %s: qosnul buffers unavailable \\n\n537  0x00040044 0x08040044 53  54   .rodata.str1.4 ascii   ath_uapsd_sendqosnull: HW Q Full - Not expected here\\n\n538  0x0004007c 0x0804007c 55  56   .rodata.str1.4 ascii   %s: %d swr eligible frames sent to sc_uapsdq actual %d\\n\n539  0x000400b4 0x080400b4 57  58   .rodata.str1.4 ascii   ath_process_uapsd_trigger: HW Q Full - Not expected here\\n\n540  0x000400f0 0x080400f0 36  37   .rodata.str1.4 ascii   %s: HW queued %d SW queue depth %d \\n\n541  0x00040118 0x08040118 47  48   .rodata.str1.4 ascii   %s : staging queued %d completed %d qosnull %d\\n\n542  0x00040148 0x08040148 26  27   .rodata.str1.4 ascii   %s: requeued %d depth %d \\n\n543  0x00040164 0x08040164 43  44   .rodata.str1.4 ascii   Error: ATH_VAP_INFO module is not included\\n\n544  0x00040190 0x08040190 44  45   .rodata.str1.4 ascii   %s[%d] sc->sc_config.txchainmask %d mask %d\\n\n545  0x000401c0 0x080401c0 44  45   .rodata.str1.4 ascii   %s[%d] sc->sc_config.rxchainmask %d mask %d\\n\n546  0x000401f0 0x080401f0 72  73   .rodata.str1.4 ascii   %s: an_fixedrate_enable = %d, an_fixedrix = %d, an_fixedratecode = 0x%x\\n\n547  0x0004023c 0x0804023c 21  22   .rodata.str1.4 ascii   UNKNOWN param %s %d \\n\n548  0x00040254 0x08040254 31  32   .rodata.str1.4 ascii   Smart antenna is not supported\\n\n549  0x0004027c 0x0804027c 45  46   .rodata.str1.4 ascii   \\n========= Rate Control Table Config========\\n\n550  0x000402ac 0x080402ac 23  24   .rodata.str1.4 ascii   AC\\tPER\\tProbe Interval\\n\\n\n551  0x000402c4 0x080402c4 14  15   .rodata.str1.4 ascii   BE&BK\\t%d\\t\\t%d \\n\n552  0x000402d4 0x080402d4 14  15   .rodata.str1.4 ascii   VI&VO\\t%d\\t\\t%d \\n\n553  0x000402e4 0x080402e4 45  46   .rodata.str1.4 ascii   \\n========= Access Category Config===========\\n\n554  0x00040314 0x08040314 60  61   .rodata.str1.4 ascii   AC\\tRTS \\tAggr Scaling\\tMin Rate(Kbps)\\tHBR \\tPER LO \\tRXTIMEOUT\\n\\n\n555  0x00040354 0x08040354 24  25   .rodata.str1.4 ascii   BE\\t%s\\t\\t%d\\t%6d\\t\\t%s\\t%d\\t%d\\n\n556  0x00040370 0x08040370 24  25   .rodata.str1.4 ascii   BK\\t%s\\t\\t%d\\t%6d\\t\\t%s\\t%d\\t%d\\n\n557  0x0004038c 0x0804038c 24  25   .rodata.str1.4 ascii   VI\\t%s\\t\\t%d\\t%6d\\t\\t%s\\t%d\\t%d\\n\n558  0x000403a8 0x080403a8 24  25   .rodata.str1.4 ascii   VO\\t%s\\t\\t%d\\t%6d\\t\\t%s\\t%d\\t%d\\n\n559  0x000403c4 0x080403c4 10  11   .rodata.str1.4 ascii   Not locked\n560  0x000403d4 0x080403d4 128 129  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_main.c\n561  0x00040458 0x08040458 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n562  0x00040478 0x08040478 107 108  .rodata.str1.4 ascii   %s: unable to reset hardware; hal status %u,\\nsc_opmode=%d, sc_curchan: chan=%d, Flags=0x%x, sc_scanning=%d\\n\n563  0x000404e4 0x080404e4 55  56   .rodata.str1.4 ascii   %s: Warning - Not in Awake state. Explicitly waking up\\n\n564  0x0004051c 0x0804051c 44  45   .rodata.str1.4 ascii   %s: unable to reset hardware; hal status %u\\n\n565  0x0004054c 0x0804054c 54  55   .rodata.str1.4 ascii   %s[%d] tx chainmask mismatch actual %d sc_chainmak %d\\n\n566  0x00040584 0x08040584 54  55   .rodata.str1.4 ascii   %s[%d] rx chainmask mismatch actual %d sc_chainmak %d\\n\n567  0x000405bc 0x080405bc 37  38   .rodata.str1.4 ascii   %s: unable to allocate channel table\\n\n568  0x000405e4 0x080405e4 31  32   .rodata.str1.4 ascii   no h/w rate set for phy mode %u\n569  0x00040604 0x08040604 30  31   .rodata.str1.4 ascii   %s: Invalid interface id = %u\\n\n570  0x00040624 0x08040624 51  52   .rodata.str1.4 ascii   %s: cannot map channel to mode; freq %u flags 0x%x\\n\n571  0x00040658 0x08040658 56  57   .rodata.str1.4 ascii   Primary txchainmask 0x%02x, optional txchainmask 0x%02x\\n\n572  0x00040694 0x08040694 55  56   .rodata.str1.4 ascii   Cannot enable Green power save when not in HOSTAP mode\\n\n573  0x000406cc 0x080406cc 20  21   .rodata.str1.4 ascii   get_dfsdomain failed\n574  0x000406e4 0x080406e4 20  21   .rodata.str1.4 ascii   get_regdomain failed\n575  0x000406fc 0x080406fc 58  59   .rodata.str1.4 ascii   %s SPECTRAL attach failed, HW may not be spectral capable\\n\n576  0x00040738 0x08040738 32  33   .rodata.str1.4 ascii   SPECTRAL :----- module attached\\n\n577  0x0004075c 0x0804075c 81  82   .rodata.str1.4 ascii   %s: unable to collect channel list from hal; regdomain likely %u country code %u\\n\n578  0x000407b0 0x080407b0 27  28   .rodata.str1.4 ascii    %s: ret %d, regdomain %d \\n\n579  0x000407cc 0x080407cc 36  37   .rodata.str1.4 ascii   %s: rs_phyer=0x%x not a radar error\\n\n580  0x000407f4 0x080407f4 17  18   .rodata.str1.4 ascii   %s: Hardware Key\\n\n581  0x00040808 0x08040808 27  28   .rodata.str1.4 ascii   %s: if_id = %d, pause = %d\\n\n582  0x00040824 0x08040824 15  16   .rodata.str1.4 ascii   %s: ancaps %#x\\n\n583  0x00040834 0x08040834 26  27   .rodata.str1.4 ascii   %s[%d] Not FCC DOMAIN: %d\\n\n584  0x00040850 0x08040850 22  23   .rodata.str1.4 ascii   %s[%d] DFS DOMAIN: %d\\n\n585  0x00040868 0x08040868 51  52   .rodata.str1.4 ascii   %s: fixed rate=0x%x is over 24 Mb. Default DIFS OK\\n\n586  0x0004089c 0x0804089c 54  55   .rodata.str1.4 ascii   %s: fixed rate=0x%x is at or below 24 Mb. Adjust DIFS\\n\n587  0x000408d4 0x080408d4 32  33   .rodata.str1.4 ascii   %s: DFS_FCC_DOMAIN, adjust DIFS\\n\n588  0x000408f8 0x080408f8 25  26   .rodata.str1.4 ascii   %s: use DFS enhancements\\n\n589  0x00040914 0x08040914 21  22   .rodata.str1.4 ascii   %s[%d] SHOULD ABORT \\n\n590  0x0004092c 0x0804092c 20  21   .rodata.str1.4 ascii   %s[%d] dfsdomain %d\\n\n591  0x00040944 0x08040944 42  43   .rodata.str1.4 ascii   %s: Tx Antenna Switch. Do internal reset.\\n\n592  0x00040970 0x08040970 11  12   .rodata.str1.4 ascii   %s: key %u\\n\n593  0x0004097c 0x0804097c 17  18   .rodata.str1.4 ascii   %s: out of space\\n\n594  0x00040990 0x08040990 20  21   .rodata.str1.4 ascii   %s: key pair %u ,%u\\n\n595  0x000409a8 0x080409a8 22  23   .rodata.str1.4 ascii   %s: out of pair space\\n\n596  0x000409c0 0x080409c0 16  17   .rodata.str1.4 ascii   key cache !split\n597  0x000409d4 0x080409d4 38  39   .rodata.str1.4 ascii   %d.%03d | %s: RX filter 0x%x aid 0x%x\\n\n598  0x000409fc 0x080409fc 35  36   .rodata.str1.4 ascii   %d.%03d | %s: RX filter 0x%x aid 0\\n\n599  0x00040a20 0x08040a20 32  33   .rodata.str1.4 ascii   %s: switch opmode from %d to %d\\n\n600  0x00040a44 0x08040a44 24  25   .rodata.str1.4 ascii   %s called when invalid.\\n\n601  0x00040a60 0x08040a60 19  20   .rodata.str1.4 ascii   %s: Got fatal intr\\n\n602  0x00040a74 0x08040a74 19  20   .rodata.str1.4 ascii   %s: Got RXORN intr\\n\n603  0x00040a88 0x08040a88 19  20   .rodata.str1.4 ascii   %s: Got RXEOL intr\\n\n604  0x00040a9c 0x08040a9c 71  72   .rodata.str1.4 ascii   %s[%d] ---- Athbuf FreeQ Not Empty - Calling AllocRxbufs for FreeList \\n\n605  0x00040ae4 0x08040ae4 8   9    .rodata.str1.4 ascii    GTT %d\\n\n606  0x00040af0 0x08040af0 21  22   .rodata.str1.4 ascii   %s: Consecutive GTTs\\n\n607  0x00040b08 0x08040b08 45  46   .rodata.str1.4 ascii   %s: --- TX Hang detected resetting chip --- \\n\n608  0x00040b38 0x08040b38 28  29   .rodata.str1.4 ascii   %s: status 0x%x  Mask: 0x%x\\n\n609  0x00040b58 0x08040b58 34  35   .rodata.str1.4 ascii   %s: recv interrupts when invalid.\\n\n610  0x00040b7c 0x08040b7c 36  37   .rodata.str1.4 ascii   %s: HAL_INT_TSFOOR - syncing beacon\\n\n611  0x00040ba4 0x08040ba4 22  23   .rodata.str1.4 ascii   %s: Scheduling BH/DPC\\n\n612  0x00040bbc 0x08040bbc 21  22   .rodata.str1.4 ascii   %s: Not My Interrupt\\n\n613  0x00040bd4 0x08040bd4 10  11   .rodata.str1.4 ascii   %s: an %p\\n\n614  0x00040be0 0x08040be0 27  28   .rodata.str1.4 ascii   %s: Exit DFS_WAIT state %d\\n\n615  0x00040bfc 0x08040bfc 28  29   .rodata.str1.4 ascii   %s: invalid interface id %u\\n\n616  0x00040c1c 0x08040c1c 51  52   .rodata.str1.4 ascii   %s: Rx beacon_cabq_use_count stuck. Investigate!!!\\n\n617  0x00040c50 0x08040c50 27  28   .rodata.str1.4 ascii   %s : Draining FMS queue %d\\n\n618  0x00040c6c 0x08040c6c 64  65   .rodata.str1.4 ascii   %s: RX filter 0x%x bssid %02x:%02x:%02x:%02x:%02x:%02x aid 0x%x\\n\n619  0x00040cb0 0x08040cb0 32  33   .rodata.str1.4 ascii   %s: enter. dev=0x%p, if_id=0x%x\\n\n620  0x00040cd4 0x08040cd4 10  11   .rodata.str1.4 ascii   %s: exit.\\n\n621  0x00040ce0 0x08040ce0 18  19   .rodata.str1.4 ascii   Unknown hal_opmode\n622  0x00040cf4 0x08040cf4 91  92   .rodata.str1.4 ascii   %s : enter. dev=0x%p, if_id=0x%x, if_data=0x%p, opmode=%s, iv_opmode=%s, nostabeacons=0x%x\\n\n623  0x00040d50 0x08040d50 20  21   .rodata.str1.4 ascii   %s: Unknown type %d\\n\n624  0x00040d68 0x08040d68 20  21   .rodata.str1.4 ascii   %s: invalid mode %u\\n\n625  0x00040d80 0x08040d80 41  42   .rodata.str1.4 ascii   \\n %s ******** Hardware Q-%d is stuck !!!!\n626  0x00040dac 0x08040dac 41  42   .rodata.str1.4 ascii   \\n %s ******** Hardware RX Q is stuck !!!!\n627  0x00040dd8 0x08040dd8 36  37   .rodata.str1.4 ascii   \\n %s resetting hardware for Q stuck\n628  0x00040e00 0x08040e00 37  38   .rodata.str1.4 ascii   \\n %s resetting hardware for Rx stuck\n629  0x00040e28 0x08040e28 20  21   .rodata.str1.4 ascii   \\n %s overrun is hit\\n\n630  0x00040e40 0x08040e40 36  37   .rodata.str1.4 ascii   DCS: dcrx %u dctx %u rxt %u wtxt %u\\n\n631  0x00040e68 0x08040e68 33  34   .rodata.str1.4 ascii   DCS:%s timestamp Counter wrap!!!\\n\n632  0x00040e8c 0x08040e8c 12  13   .rodata.str1.4 ascii   DCS: %d %u \\n\n633  0x00040e9c 0x08040e9c 23  24   .rodata.str1.4 ascii   DCS:%s Counter wrap!!!\\n\n634  0x00040eb4 0x08040eb4 42  43   .rodata.str1.4 ascii   DCS: totcu %u txcu %u rxcu %u %u txerr %u\\n\n635  0x00040ee0 0x08040ee0 46  47   .rodata.str1.4 ascii   DCS: unusable_cu %d wasted_cu %u thp %u ts %u\\n\n636  0x00040f10 0x08040f10 32  33   .rodata.str1.4 ascii   DCS: err %d %u %u %u %u time %u\\n\n637  0x00040f34 0x08040f34 23  24   .rodata.str1.4 ascii   DCS: %s: INTR DETECTED\\n\n638  0x00040f4c 0x08040f4c 23  24   .rodata.str1.4 ascii   DCS: %s: Trigger EACS \\n\n639  0x00040f64 0x08040f64 40  41   .rodata.str1.4 ascii   Interference Detected, Changing Channel\\n\n640  0x00040f90 0x08040f90 62  63   .rodata.str1.4 ascii   ICM is active, sending message to change channel with flag %d\\n\n641  0x00040fd0 0x08040fd0 44  45   .rodata.str1.4 ascii   %s: RFgain out of bounds, resetting device.\\n\n642  0x00041000 0x08041000 35  36   .rodata.str1.4 ascii   %s[%d]: disable paprd by green tx.\\n\n643  0x00041024 0x08041024 33  34   .rodata.str1.4 ascii   %s[%d]: ath_paprd_cal retval %d \\n\n644  0x00041048 0x08041048 41  42   .rodata.str1.4 ascii   %s[%d]: ath_apply_paprd_table retval %d \\n\n645  0x00041074 0x08041074 47  48   .rodata.str1.4 ascii   %s[%d]: paprd_enable %d paprd_done %d Apply %d\\n\n646  0x000410a4 0x080410a4 43  44   .rodata.str1.4 ascii   %d.%03d | %s: channel %u/%x noise_floor=%d\\n\n647  0x000410d0 0x080410d0 50  51   .rodata.str1.4 ascii   %d.%03d | %s: calibration of channel %u/%x failed\\n\n648  0x00041104 0x08041104 64  65   .rodata.str1.4 ascii   %s: Found CW interference. Sending message to application layer\\n\n649  0x00041148 0x08041148 49  50   .rodata.str1.4 ascii   Too much interference, Trying to change channels\\n\n650  0x0004117c 0x0804117c 28  29   .rodata.str1.4 ascii   %s: flush is not protected.\\n\n651  0x0004119c 0x0804119c 71  72   .rodata.str1.4 ascii   %s: sc_inuse count(%d) stuck after waiting for %d msec. Investigate!!!\\n\n652  0x000411e4 0x080411e4 55  56   .rodata.str1.4 ascii   %s: ** spectral_scan_enabled during chan chg - restart\\n\n653  0x0004121c 0x0804121c 66  67   .rodata.str1.4 ascii   %s: spectral_scan__enable failed, HW may not be spectral capable \\n\n654  0x00041260 0x08041260 31  32   .rodata.str1.4 ascii   %s: unable to start recv logic\\n\n655  0x00041280 0x08041280 37  38   .rodata.str1.4 ascii   %s: Unable to stop TxDMA. Reset HAL!\\n\n656  0x000412a8 0x080412a8 64  65   .rodata.str1.4 ascii   %s: Unable to stop TxDMA Even after Reset, ignore and continue \\n\n657  0x000412ec 0x080412ec 33  34   .rodata.str1.4 ascii   %s: unable to restart recv logic\\n\n658  0x00041310 0x08041310 29  30   .rodata.str1.4 ascii   %s: set proxy sta mode to %d\\n\n659  0x00041330 0x08041330 41  42   .rodata.str1.4 ascii   %s: %u (%u MHz) 0x%x -> %u (%u MHz) 0x%x\\n\n660  0x0004135c 0x0804135c 64  65   .rodata.str1.4 ascii   %s: unable to reset channel %u (%uMhz) flags 0x%x hal status %u\\n\n661  0x000413a0 0x080413a0 52  53   .rodata.str1.4 ascii   %s: unable to change channel %u (%uMhz) flags 0x%x \\n\n662  0x000413d8 0x080413d8 65  66   .rodata.str1.4 ascii   %s: unable to reset hardware; hal status %u (freq %u flags 0x%x)\\n\n663  0x0004141c 0x0804141c 17  18   .rodata.str1.4 ascii   <7>STARTED RECV \\n\n664  0x00041430 0x08041430 15  16   .rodata.str1.4 ascii   %s: invalid %u\\n\n665  0x00041440 0x08041440 36  37   .rodata.str1.4 ascii   %s[%d] : ah_set_interrupts was NULL\\n\n666  0x00041468 0x08041468 21  22   .rodata.str1.4 ascii   %s[%d] : ah was NULL\\n\n667  0x00041480 0x08041480 12  13   .rodata.str1.4 ascii   %s: mode %d\\n\n668  0x00041490 0x08041490 36  37   .rodata.str1.4 ascii   %s: invalid type %d for GPIO pin %d\\n\n669  0x000414b8 0x080414b8 37  38   .rodata.str1.4 ascii   %s: Invalid GPIO Mask required: 0x%x\\n\n670  0x000414e0 0x080414e0 38  39   .rodata.str1.4 ascii   %s: Unable to allocate device object.\\n\n671  0x0004150c 0x0804150c 15  16   .rodata.str1.4 ascii   %s: devid 0x%x\\n\n672  0x0004151c 0x0804151c 45  46   .rodata.str1.4 ascii   %s: unable to attach hardware; HAL status %u\\n\n673  0x0004154c 0x0804154c 29  30   .rodata.str1.4 ascii   %hhx:%hhx:%hhx:%hhx:%hhx:%hhx\n674  0x0004156c 0x0804156c 51  52   .rodata.str1.4 ascii   %s: Warning, using only %u entries in %u key cache\\n\n675  0x000415a0 0x080415a0 53  54   .rodata.str1.4 ascii   %s[%d]: Failed to get channel information! error[%d]\\n\n676  0x000415d8 0x080415d8 41  42   .rodata.str1.4 ascii   %s: unable to setup a beacon xmit queue!\\n\n677  0x00041604 0x08041604 36  37   .rodata.str1.4 ascii   %s: unable to setup CAB xmit queue!\\n\n678  0x0004162c 0x0804162c 35  36   .rodata.str1.4 ascii   %s[%d]: Failed to set Tx h/w queue\\n\n679  0x00041650 0x08041650 28  29   .rodata.str1.4 ascii   %s[%d]: Rate attach failed!\\n\n680  0x00041670 0x08041670 20  21   .rodata.str1.4 ascii   %s TX99 init failed\\n\n681  0x00041688 0x08041688 33  34   .rodata.str1.4 ascii   %s [%d]: Green AP attach failed!\\n\n682  0x000416b0 0x080416b0 49  50   .rodata.str1.4 ascii   skipping lmac node %p cleanup due to tx activity\\n\n683  0x000416e4 0x080416e4 4   5    .rodata.str1.4 ascii   xmit\n684  0x000416ec 0x080416ec 15  16   .rodata.str1.4 ascii   xmit descriptor\n685  0x000416fc 0x080416fc 4   5    .rodata.str1.4 ascii   recv\n686  0x00041704 0x08041704 15  16   .rodata.str1.4 ascii   recv descriptor\n687  0x00041714 0x08041714 4   5    .rodata.str1.4 ascii   rate\n688  0x0004171c 0x0804171c 5   6    .rodata.str1.4 ascii   reset\n689  0x00041724 0x08041724 6   7    .rodata.str1.4 ascii   beacon\n690  0x0004172c 0x0804172c 8   9    .rodata.str1.4 ascii   watchdog\n691  0x00041738 0x08041738 4   5    .rodata.str1.4 ascii   scan\n692  0x00041740 0x08041740 8   9    .rodata.str1.4 ascii   green ap\n693  0x0004174c 0x0804174c 7   8    .rodata.str1.4 ascii   HTC wmi\n694  0x00041754 0x08041754 4   5    .rodata.str1.4 ascii   intr\n695  0x0004175c 0x0804175c 7   8    .rodata.str1.4 ascii   tx intr\n696  0x00041764 0x08041764 7   8    .rodata.str1.4 ascii   rx intr\n697  0x0004176c 0x0804176c 11  12   .rodata.str1.4 ascii   beacon proc\n698  0x00041778 0x08041778 9   10   .rodata.str1.4 ascii   calibrate\n699  0x00041784 0x08041784 8   9    .rodata.str1.4 ascii   keycache\n700  0x00041790 0x08041790 5   6    .rodata.str1.4 ascii   state\n701  0x00041798 0x08041798 4   5    .rodata.str1.4 ascii   node\n702  0x000417a4 0x080417a4 5   6    .rodata.str1.4 ascii   UAPSD\n703  0x000417ac 0x080417ac 4   5    .rodata.str1.4 ascii   DOTH\n704  0x000417bc 0x080417bc 9   10   .rodata.str1.4 ascii   powersave\n705  0x000417c8 0x080417c8 7   8    .rodata.str1.4 ascii   SWretry\n706  0x000417d0 0x080417d0 11  12   .rodata.str1.4 ascii   aggr memory\n707  0x000417dc 0x080417dc 7   8    .rodata.str1.4 ascii   BT coex\n708  0x000417e4 0x080417e4 5   6    .rodata.str1.4 ascii   fatal\n709  0x000417ec 0x080417ec 10  11   .rodata.str1.4 ascii   HAL_M_IBSS\n710  0x000417f8 0x080417f8 9   10   .rodata.str1.4 ascii   HAL_M_STA\n711  0x00041804 0x08041804 12  13   .rodata.str1.4 ascii   HAL_M_HOSTAP\n712  0x00041814 0x08041814 13  14   .rodata.str1.4 ascii   HAL_M_MONITOR\n713  0x00041824 0x08041824 44  45   .rodata.str1.4 ascii   %s: unable to reset hardware; hal status %u\\n\n714  0x00041854 0x08041854 31  32   .rodata.str1.4 ascii   %s: unable to start recv logic\\n\n715  0x00041874 0x08041874 29  30   .rodata.str1.4 ascii   %s: cachelsz %u rxbufsize %u\\n\n716  0x00041898 0x08041898 38  39   .rodata.str1.4 ascii   failed to allocate rx descriptors: %d\\n\n717  0x000418c0 0x080418c0 40  41   .rodata.str1.4 ascii   %s: RX filter 0x%x, MC filter %08x:%08x\\n\n718  0x000418ec 0x080418ec 70  71   .rodata.str1.4 ascii   %s: Warning: Multiple Rx starts or stops; count=%d. Ignored this one!\\n\n719  0x00041934 0x08041934 59  60   .rodata.str1.4 ascii   %s[%d]: Could not map mbuf into physical memory. Retrying.\\n\n720  0x00041970 0x08041970 54  55   .rodata.str1.4 ascii   %s[%d] --- Could not allocate Mbuf - try again later \\n\n721  0x000419a8 0x080419a8 49  50   .rodata.str1.4 ascii   ---- %s[%d] ---- Fed back %d buffers to HW Q ---\\n\n722  0x000419dc 0x080419dc 35  36   .rodata.str1.4 ascii   %s: ath_hal_set_proxysta failed %d\\n\n723  0x00041a00 0x08041a00 29  30   .rodata.str1.4 ascii   %02x:%02x:%02x:%02x:%02x:%02x\n724  0x00041a20 0x08041a20 60  61   .rodata.str1.4 ascii   %s decrypt error. STA (%s)  keyix (%d) rx_status flags (%d)\\n\n725  0x00041a60 0x08041a60 54  55   .rodata.str1.4 ascii   %s: Check hw key for STA (%s). Key might be corrupted\\n\n726  0x00041a98 0x08041a98 53  54   .rodata.str1.4 ascii   %s: Key plumbed again for STA (%s). Key is corrupted\\n\n727  0x00041ad0 0x08041ad0 58  59   .rodata.str1.4 ascii   Get the V/CV packet (%x) prepare to send the action frame\\n\n728  0x00041b0c 0x08041b0c 40  41   .rodata.str1.4 ascii   Not to be the desired V/CV Data 0x%02x \\n\n729  0x00041b38 0x08041b38 35  36   .rodata.str1.4 ascii   %s rxs->rs_datalen(%d) buf_len(%d)\\n\n730  0x00041b5c 0x08041b5c 43  44   .rodata.str1.4 ascii   ==>%s:sc->V_CV_node to be NULL do nothing \\n\n731  0x00041b88 0x08041b88 79  80   .rodata.str1.4 ascii   ==>%s:To be H but the last pkt not as expected sc->Last_Rx_type(%x) is_agg(%x)\\n\n732  0x00041bd8 0x08041bd8 36  37   .rodata.str1.4 ascii   %s Delay Report rxs->rs_datalen(%d)\\n\n733  0x00041c00 0x08041c00 60  61   .rodata.str1.4 ascii   %s to be rs_more packet (%d) wh1->i_htc[2] (%02x) aggr (%x)\\n\n734  0x00041c40 0x08041c40 30  31   .rodata.str1.4 ascii   Rx rssi0 %d rssi1 %d rssi2 %d\\n\n735  0x00041c60 0x08041c60 10  11   .rodata.str1.4 ascii   Not locked\n736  0x00041c74 0x08041c74 13  14   .rodata.str1.4 ascii   no mpdu (%s)\\n\n737  0x00041c84 0x08041c84 128 129  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_recv.c\n738  0x00041d08 0x08041d08 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n739  0x00041d28 0x08041d28 61  62   .rodata.str1.4 ascii   %s: Incorrect frame length %d due to rx ds status corruption\\n\n740  0x00041d68 0x08041d68 45  46   .rodata.str1.4 ascii   Reset rx chain mask. Do internal reset. (%s)\\n\n741  0x00041d98 0x08041d98 28  29   .rodata.str1.4 ascii   %s: flush is not protected.\\n\n742  0x00041db8 0x08041db8 50  51   .rodata.str1.4 ascii   %s[%d]:drop baw_head %d, baw_tail %d, seq_next %d\\n\n743  0x00041dec 0x08041dec 10  11   .rodata.str1.4 ascii   Not locked\n744  0x00041dfc 0x08041dfc 61  62   .rodata.str1.4 ascii   %s[%d] rxtid timer active = %d, baw_head = %d, baw_tail = %d\\n\n745  0x00041e3c 0x08041e3c 131 132  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_recv_ht.c\n746  0x00041ec0 0x08041ec0 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n747  0x00041ee0 0x08041ee0 32  33   .rodata.str1.4 ascii   %s: req: %d user: %d -> baw: %d\\n\n748  0x00041f04 0x08041f04 34  35   .rodata.str1.4 ascii   %s: Allcating rxbuffer for TID %d\\n\n749  0x00041f28 0x08041f28 49  50   .rodata.str1.4 ascii   %s: Unable to allocate RX buffer, refusing ADDBA\\n\n750  0x00041f5c 0x08041f5c 18  19   .rodata.str1.4 ascii   %s: Allocated @%p\\n\n751  0x00041f70 0x08041f70 77  78   .rodata.str1.4 ascii   %s[%d]: DROPPING old sequence: tid %d, baw_head %d, baw_tail %d, seq_next %d\\n\n752  0x00041fc0 0x08041fc0 157 158  .rodata.str1.4 ascii   %s[%d]: dst[%02x:%02x:%02x:%02x:%02x:%02x] src[%02x:%02x:%02x:%02x:%02x:%02x] seq[%d], BAR RX frame tid %d, baw_head %d, baw_tail %d, seq_next %d, cindex %d\\n\n753  0x00042060 0x08042060 29  30   .rodata.str1.4 ascii   %s[%d]: DROPPING bad version\\n\n754  0x00042080 0x08042080 34  35   .rodata.str1.4 ascii   %s[%d]: DROPPING rx decrypt error\\n\n755  0x000420a4 0x080420a4 148 149  .rodata.str1.4 ascii   %s[%d]: dst[%02x:%02x:%02x:%02x:%02x:%02x] src[%02x:%02x:%02x:%02x:%02x:%02x] seq[%d], DROPPING frame tid %d, baw_head %d, baw_tail %d, seq_next %d\\n\n756  0x0004213c 0x0804213c 94  95   .rodata.str1.4 ascii   %s[%d]: DROPPING frame tid %d, baw_head %d, baw_tail %d, seq_next %d, index(%d) > %d, seq[%d]\\n\n757  0x0004219c 0x0804219c 158 159  .rodata.str1.4 ascii   %s[%d]: dst[%02x:%02x:%02x:%02x:%02x:%02x] src[%02x:%02x:%02x:%02x:%02x:%02x] seq[%d], DROPPING frame tid %d, baw_head %d, baw_tail %d, seq_next %d cindex %d\\n\n758  0x0004223c 0x0804223c 74  75   .rodata.str1.4 ascii   %s[%d]:Dup frame tid %d, baw_head %d, baw_tail %d, seq_next %d, cindex %d\\n\n759  0x00042288 0x08042288 35  36   .rodata.str1.4 ascii   %s: Deallocating TID %d rxbuff @%p\\n\n760  0x000422ac 0x080422ac 47  48   .rodata.str1.4 ascii   tid[%d]->rxbuf[%d] != NULL (baw head %d tail %d\n761  0x000422dc 0x080422dc 40  41   .rodata.str1.4 ascii   %s: Timer is not active!! Investigate!!\\n\n762  0x00042308 0x08042308 30  31   .rodata.str1.4 ascii   %s: tx queue [%u] %x, link %p\\n\n763  0x0004232c 0x0804232c 38  39   .rodata.str1.4 ascii   failed to allocate tx descriptors: %d\\n\n764  0x00042354 0x08042354 6   7    .rodata.str1.4 ascii   beacon\n765  0x0004235c 0x0804235c 42  43   .rodata.str1.4 ascii   failed to allocate beacon descripotrs: %d\\n\n766  0x0004238c 0x0804238c 39  40   .rodata.str1.4 ascii   failed to allocate tim descripotrs: %d\\n\n767  0x000423b4 0x080423b4 41  42   .rodata.str1.4 ascii   failed to allocate UAPSD descripotrs: %d\\n\n768  0x000423e0 0x080423e0 45  46   .rodata.str1.4 ascii   failed to allocate tx status descriptors: %d\\n\n769  0x00042410 0x08042410 34  35   .rodata.str1.4 ascii   hal qnum %u out of range, max %u!\\n\n770  0x00042434 0x08042434 33  34   .rodata.str1.4 ascii   HAL AC %u out of range, max %zu!\\n\n771  0x00042458 0x08042458 43  44   .rodata.str1.4 ascii   unable to setup xmit queue for BE traffic!\\n\n772  0x00042484 0x08042484 38  39   .rodata.str1.4 ascii   %s: unable to setup UAPSD xmit queue!\\n\n773  0x000424ac 0x080424ac 38  39   .rodata.str1.4 ascii   %s: unable to setup PAPRD xmit queue!\\n\n774  0x000424d4 0x080424d4 41  42   .rodata.str1.4 ascii   %s: unable to setup WIFIPOS  xmit queue!\\n\n775  0x00042500 0x08042500 45  46   .rodata.str1.4 ascii   %s[%d]: unable to setup WIFIPOS  xmit queue!\\n\n776  0x00042530 0x08042530 44  45   .rodata.str1.4 ascii   %s: unable to setup WIFIPOS HC  xmit queue!\\n\n777  0x00042560 0x08042560 40  41   .rodata.str1.4 ascii   %s: unable to update hardware queue %u!\\n\n778  0x0004258c 0x0804258c 19  20   .rodata.str1.4 ascii   %s: txq depth = %d\\n\n779  0x000425a0 0x080425a0 27  28   .rodata.str1.4 ascii   %s: link[%u](%p)=%llx (%p)\\n\n780  0x000425bc 0x080425bc 10  11   .rodata.str1.4 ascii   Not locked\n781  0x000425cc 0x080425cc 4   5    .rodata.str1.4 ascii   AGGR\n782  0x000425d4 0x080425d4 5   6    .rodata.str1.4 ascii   !AGGR\n783  0x000425dc 0x080425dc 128 129  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_xmit.c\n784  0x00042660 0x08042660 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n785  0x00042680 0x08042680 60  61   .rodata.str1.4 ascii   %s: Queuing frm with SeqNo%dto SxQ: SxQdepth %d pendfrms %d\\n\n786  0x000426c0 0x080426c0 47  48   .rodata.str1.4 ascii   %s: Queuing frm with SeqCtrl 0x%02X%02X to HwQ\\n\n787  0x000426f0 0x080426f0 22  23   .rodata.str1.4 ascii   [%d] TXQ MAX DEPTH!!!\\n\n788  0x00042708 0x08042708 29  30   .rodata.str1.4 ascii   %02x:%02x:%02x:%02x:%02x:%02x\n789  0x00042728 0x08042728 77  78   .rodata.str1.4 ascii   %s: CLR DEST MASK dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d\\n\n790  0x00042778 0x08042778 78  79   .rodata.str1.4 ascii   %s: FRMS INC dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d bf %p\\n\n791  0x000427c8 0x080427c8 81  82   .rodata.str1.4 ascii   %s: FRMS INC %s dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d bf %p\\n\n792  0x0004281c 0x0804281c 15  16   .rodata.str1.4 ascii   txq_concat err\\n\n793  0x0004282c 0x0804282c 31  32   .rodata.str1.4 ascii   %s: TXDP[%u] = %llx == %u (%p)\\n\n794  0x0004284c 0x0804284c 30  31   .rodata.str1.4 ascii   %s: in reset, dump tx packet.\\n\n795  0x0004286c 0x0804286c 25  26   .rodata.str1.4 ascii   %s: TXDP[%u] = %llx (%p)\\n\n796  0x00042888 0x08042888 28  29   .rodata.str1.4 ascii   %s: link[%u] (%p)=%llx (%p)\\n\n797  0x000428a8 0x080428a8 22  23   .rodata.str1.4 ascii   no rate table, mode %u\n798  0x000428c0 0x080428c0 107 108  .rodata.str1.4 ascii   %s: NULL wbuf: lastbf %p lastfrm %p next %p flags %x status %x desc %p framelen %d seq %d tid %d keytype %x\n799  0x0004292c 0x0804292c 37  38   .rodata.str1.4 ascii   ath_tx_draintxq: ERR head %d tail %d\\n\n800  0x00042954 0x08042954 13  14   .rodata.str1.4 ascii   txq_move err\\n\n801  0x00042964 0x08042964 37  38   .rodata.str1.4 ascii   %s: Unable to stop TxDMA. Reset HAL!\\n\n802  0x0004298c 0x0804298c 44  45   .rodata.str1.4 ascii   %s: unable to reset hardware; hal status %u\\n\n803  0x000429bc 0x080429bc 18  19   .rodata.str1.4 ascii   %s: all tx queues\\n\n804  0x000429d0 0x080429d0 20  21   .rodata.str1.4 ascii   %s: beacon queue %x\\n\n805  0x000429e8 0x080429e8 10  11   .rodata.str1.4 ascii   an == null\n806  0x000429f4 0x080429f4 13  14   .rodata.str1.4 ascii   cix not setup\n807  0x00042a04 0x08042a04 40  41   .rodata.str1.4 ascii   %s no more ath bufs. num phys frags %d \\n\n808  0x00042a30 0x08042a30 37  38   .rodata.str1.4 ascii   %s:txq_pause in progress flag is set\\n\n809  0x00042a58 0x08042a58 20  21   .rodata.str1.4 ascii   %s: clear dest mask\\n\n810  0x00042a70 0x08042a70 44  45   .rodata.str1.4 ascii   %s: Adding multicast frames to FMS queue %d\\n\n811  0x00042aa0 0x08042aa0 63  64   .rodata.str1.4 ascii   %s: dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d\\n\n812  0x00042ae4 0x08042ae4 30  31   .rodata.str1.4 ascii   %s: tx queue %d (%x), link %p\\n\n813  0x00042b04 0x08042b04 23  24   .rodata.str1.4 ascii   %s: reaping U-APSD txq\\n\n814  0x00042b1c 0x08042b1c 50  51   .rodata.str1.4 ascii   %s:%d identified bad tid status (buf:desc  %d:%d)\\n\n815  0x00042b50 0x08042b50 64  65   .rodata.str1.4 ascii   %s: SeqNo%d --> rate %02X, swretry %d retrycnt %d totaltries %d\\n\n816  0x00042b94 0x08042b94 28  29   .rodata.str1.4 ascii   %s: SeqNo%d --> status %08X\\n\n817  0x00042bb4 0x08042bb4 57  58   .rodata.str1.4 ascii   Txq Id\\taxq_depth\\taxq_fifo\\ttid_bufq\\tpaused_tid\\tbar_paused\\n\n818  0x00042bf0 0x08042bf0 31  32   .rodata.str1.4 ascii   txq[%d]\\t%d\\t\\t%d\\t\\t%d\\t\\t0x%x\\t\\t0x%x\\n\n819  0x00042c10 0x08042c10 10  11   .rodata.str1.4 ascii   Total: %d\\n\n820  0x00042c1c 0x08042c1c 71  72   .rodata.str1.4 ascii   ath_tx_pause_tid: tid->tidno = %d, tid->paused (after increment) = %d \\n\n821  0x00042c64 0x08042c64 10  11   .rodata.str1.4 ascii   Not locked\n822  0x00042c74 0x08042c74 74  75   .rodata.str1.4 ascii   %s: HWQ %d in filtering status but still more frame needed to be filtered\\n\n823  0x00042cc0 0x08042cc0 131 132  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_xmit_ht.c\n824  0x00042d44 0x08042d44 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n825  0x00042d64 0x08042d64 46  47   .rodata.str1.4 ascii   ath_tx_sched_normal: txqadd failed for single\\n\n826  0x00042d94 0x08042d94 111 112  .rodata.str1.4 ascii   %s: Recovering from error condition: Flushing TID queue until head                        is within the window\\n\n827  0x00042e04 0x08042e04 74  75   .rodata.str1.4 ascii   %s: TID[%d] seq_start:%d seq_next:%d Head:%d Tail:%d BAW size:%d seqno:%d\\n\n828  0x00042e50 0x08042e50 44  45   .rodata.str1.4 ascii   ath_tx_sched_aggr: txqadd failed for single\\n\n829  0x00042e80 0x08042e80 47  48   .rodata.str1.4 ascii   ath_tx_sched_aggr: txqadd failed for aggregate\\n\n830  0x00042eb0 0x08042eb0 53  54   .rodata.str1.4 ascii   %s: Scanning : Addba Timer Expired, but rescheduled \\n\n831  0x00042ee8 0x08042ee8 31  32   .rodata.str1.4 ascii   %s:forming aggregate for burst\\n\n832  0x00042f08 0x08042f08 50  51   .rodata.str1.4 ascii   %s baw closed seqstart %d baw_size %d bf_seqno %d\\n\n833  0x00042f3c 0x08042f3c 23  24   .rodata.str1.4 ascii   %s WAR kick in send bar\n834  0x00042f54 0x08042f54 56  57   .rodata.str1.4 ascii   %s AGGR_8K_LIMITED %d frames  al %d bpad %d al_delta %d\\n\n835  0x00042f90 0x08042f90 29  30   .rodata.str1.4 ascii   %02x:%02x:%02x:%02x:%02x:%02x\n836  0x00042fb0 0x08042fb0 72  73   .rodata.str1.4 ascii   %s: AGGR NOW dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d\\n\n837  0x00042ffc 0x08042ffc 26  27   .rodata.str1.4 ascii   %s Queuing both the aggrs\\n\n838  0x00043018 0x08043018 82  83   .rodata.str1.4 ascii   --- %s[%d] --- HW Q Full, Could not add Aggr to HW -- Not being Freed !! LEAK !! \\n\n839  0x0004306c 0x0804306c 20  21   .rodata.str1.4 ascii   %s: BA bit not set.\\n\n840  0x00043084 0x08043084 44  45   .rodata.str1.4 ascii   %s: AMPDU XRETRY swr_num_eligible_frms = %d\\n\n841  0x000430b4 0x080430b4 42  43   .rodata.str1.4 ascii   %s: AMPDU FILT swr_num_eligible_frms = %d\\n\n842  0x000430e0 0x080430e0 36  37   .rodata.str1.4 ascii   %s drop tx frame tid %d bf_seqno %d\\n\n843  0x00043108 0x08043108 28  29   .rodata.str1.4 ascii   %s:txq pause is in progress\\n\n844  0x00043128 0x08043128 47  48   .rodata.str1.4 ascii   Error: enable bursting before setting duration\\n\n845  0x00043158 0x08043158 26  27   .rodata.str1.4 ascii   Disabling DCS for 11G mode\n846  0x00043174 0x08043174 84  85   .rodata.str1.4 ascii   \\tDCS for CW interference mitigation:   %d\\n\\tDCS for WLAN interference mitigation: %d\\n\n847  0x000431cc 0x080431cc 35  36   .rodata.str1.4 ascii   ATH_PARAM_RTS_CTS_RATE not support\\n\n848  0x000431f0 0x080431f0 15  16   .rodata.str1.4 ascii   sc nodebug %d \\n\n849  0x00043200 0x08043200 22  23   .rodata.str1.4 ascii   Buff Warning Level=%d\\n\n850  0x00043218 0x08043218 48  49   .rodata.str1.4 ascii   ERR: Buff Thresh(in %) should be >=%d and <=100\\n\n851  0x0004324c 0x0804324c 23  24   .rodata.str1.4 ascii   sc aldstatsenabled %d \\n\n852  0x00043264 0x08043264 26  27   .rodata.str1.4 ascii   Enable Rate limit first \\r\\n\n853  0x00043280 0x08043280 15  16   .rodata.str1.4 ascii   LP details ---\\n\n854  0x00043290 0x08043290 87  88   .rodata.str1.4 ascii   rxfifo =%p, rxfifodepth = %d, rxfifohwsize =%d, rxfifoheadindex=%d, rxfifotailindex=%d\\n\n855  0x000432e8 0x080432e8 15  16   .rodata.str1.4 ascii   HP details ---\\n\n856  0x000432f8 0x080432f8 16  17   .rodata.str1.4 ascii   sc_imask = 0x%x\\n\n857  0x0004330c 0x0804330c 49  50   .rodata.str1.4 ascii   sc_rxbuf num of elements = %d, bf=%p, bf_mpdu=%p\\n\n858  0x00043340 0x08043340 30  31   .rodata.str1.4 ascii   %s[%d] PANIC wbuf %p Index %d\\n\n859  0x00043360 0x08043360 24  25   .rodata.str1.4 ascii   PANIC depth non-zero %d\\n\n860  0x0004337c 0x0804337c 23  24   .rodata.str1.4 ascii   %s[%d]: Out of buffers\\n\n861  0x00043394 0x08043394 29  30   .rodata.str1.4 ascii   %s: size = %d rxfifodepth=%d\\n\n862  0x000433b4 0x080433b4 36  37   .rodata.str1.4 ascii   PANIC depth more than size %d sz %d\\n\n863  0x000433dc 0x080433dc 29  30   .rodata.str1.4 ascii   %s: cachelsz %u rxbufsize %u\\n\n864  0x000433fc 0x080433fc 26  27   .rodata.str1.4 ascii   [%s] Unexpected NULL wbuf\\n\n865  0x00043418 0x08043418 59  60   .rodata.str1.4 ascii   %s[%d]: Could not map mbuf into physical memory. Retrying.\\n\n866  0x00043454 0x08043454 54  55   .rodata.str1.4 ascii   %s[%d] --- Could not allocate Mbuf - try again later \\n\n867  0x0004348c 0x0804348c 49  50   .rodata.str1.4 ascii   ---- %s[%d] ---- Fed back %d buffers to HW Q ---\\n\n868  0x000434c0 0x080434c0 40  41   .rodata.str1.4 ascii   %s[%d]: RxFifoHeadHP %d RxFifoTailHP %d\\n\n869  0x000434ec 0x080434ec 40  41   .rodata.str1.4 ascii   %s[%d]: RxFifoHeadLP %d RxFifoTailLP %d\\n\n870  0x00043518 0x08043518 35  36   .rodata.str1.4 ascii   %s: Marking first DP 0x%x for drop\\n\n871  0x0004353c 0x0804353c 36  37   .rodata.str1.4 ascii   %s: Marking second DP 0x%x for drop\\n\n872  0x00043564 0x08043564 27  28   .rodata.str1.4 ascii   ath_rx_intr: depth 0 PANIC\\n\n873  0x00043580 0x08043580 53  54   .rodata.str1.4 ascii   %s :Store the CSI_1 of is_h Datalen(%d),h vaild (%d)\\n\n874  0x000435b8 0x080435b8 10  11   .rodata.str1.4 ascii   Not locked\n875  0x000435cc 0x080435cc 133 134  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_edma_recv.c\n876  0x00043654 0x08043654 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n877  0x00043674 0x08043674 13  14   .rodata.str1.4 ascii   no mpdu (%s)\\n\n878  0x00043684 0x08043684 21  22   .rodata.str1.4 ascii   %s: Dropping DP 0x%x\\n\n879  0x0004369c 0x0804369c 45  46   .rodata.str1.4 ascii   Reset rx chain mask. Do internal reset. (%s)\\n\n880  0x000436cc 0x080436cc 10  11   .rodata.str1.4 ascii   Not locked\n881  0x000436dc 0x080436dc 7   8    .rodata.str1.4 ascii   IS FILT\n882  0x000436e4 0x080436e4 8   9    .rodata.str1.4 ascii   NOT FILT\n883  0x000436f0 0x080436f0 9   10   .rodata.str1.4 ascii   IS XRETRY\n884  0x000436fc 0x080436fc 10  11   .rodata.str1.4 ascii   NOT XRETRY\n885  0x00043708 0x08043708 133 134  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_edma_xmit.c\n886  0x00043790 0x08043790 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n887  0x000437b0 0x080437b0 28  29   .rodata.str1.4 ascii   %s: error processing status\\n\n888  0x000437d0 0x080437d0 25  26   .rodata.str1.4 ascii   %s: TXQ[%d] tailindex %d\\n\n889  0x000437ec 0x080437ec 13  14   .rodata.str1.4 ascii   txq_move err\\n\n890  0x000437fc 0x080437fc 86  87   .rodata.str1.4 ascii   %s: SeqCtrl0x%02X%02X --> status %08X rate %02X, swretry %d retrycnt %d totaltries %d\\n\n891  0x00043854 0x08043854 32  33   .rodata.str1.4 ascii   %s, %s, type=0x%x, subtype=0x%x\\n\n892  0x00043878 0x08043878 28  29   .rodata.str1.4 ascii   %s:vap_pause is in progress\\n\n893  0x0004389c 0x0804389c 29  30   .rodata.str1.4 ascii   %s[%d]: PAPRD Not ENABLED %d\\n\n894  0x000438bc 0x080438bc 30  31   .rodata.str1.4 ascii   %s[%d]: PAPRD Not complete %d\\n\n895  0x000438dc 0x080438dc 31  32   .rodata.str1.4 ascii   %s[%d]: paprd_done %d write %d\\n\n896  0x000438fc 0x080438fc 31  32   .rodata.str1.4 ascii   %s PAPRD disabled in Registry \\n\n897  0x0004391c 0x0804391c 31  32   .rodata.str1.4 ascii   %s sc %p PAPRD disabled in HAL\\n\n898  0x0004393c 0x0804393c 23  24   .rodata.str1.4 ascii   %s sc %p PAPRD Enabled\\n\n899  0x00043954 0x08043954 5   6    .rodata.str1.4 ascii   paprd\n900  0x0004395c 0x0804395c 47  48   .rodata.str1.4 ascii   %s failed to allocate PAPRD tx descriptors: %d\\n\n901  0x0004398c 0x0804398c 33  34   .rodata.str1.4 ascii   %s failed to allocate PAPRD wbuf\\n\n902  0x000439b0 0x080439b0 36  37   .rodata.str1.4 ascii   %s * allocated paprd pointer at %p \\n\n903  0x000439d8 0x080439d8 10  11   .rodata.str1.4 ascii   Not locked\n904  0x000439e8 0x080439e8 129 130  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_paprd.c\n905  0x00043a6c 0x08043a6c 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n906  0x00043a8c 0x08043a8c 25  26   .rodata.str1.4 ascii   %s[%d]: ABORT PAPRD CAL \\n\n907  0x00043aa8 0x08043aa8 47  48   .rodata.str1.4 ascii   %s[%d]:  PAPRD CAL retry(%d times) on chain %d\\n\n908  0x00043ad8 0x08043ad8 60  61   .rodata.str1.4 ascii   %s[%d]: ath_hal_paprd_create_curve return re-Train, loop %d\\n\n909  0x00043b18 0x08043b18 26  27   .rodata.str1.4 ascii   %s[%d]: failed count %d!!\\n\n910  0x00043b34 0x08043b34 82  83   .rodata.str1.4 ascii   %s[%d]: ath_hal_paprd_create_curve return failed, retval %d, loop %d failcount %d\\n\n911  0x00043b88 0x08043b88 65  66   .rodata.str1.4 ascii   %s[%d]: ath_hal_paprd_create_curve return ok, retval %d, loop %d\\n\n912  0x00043bcc 0x08043bcc 58  59   .rodata.str1.4 ascii   %s paprd buffer seems NULL, last free has some bug bf %p \\n\n913  0x00043c08 0x08043c08 96  97   .rodata.str1.4 ascii   ==== %s[%d] bf %p bf->bf_frmlen %d wbuf_get_len(%d), bf->flags %x que num %d  bf->bf_buf_len %d\\n\n914  0x00043c6c 0x08043c6c 41  42   .rodata.str1.4 ascii   ++++====%s[%d]: ath_tx_txqaddbuf failed \\n\n915  0x00043c98 0x08043c98 35  36   .rodata.str1.4 ascii   %s[%d]: PAPRD enable %d channel %d\\n\n916  0x00043cbc 0x08043cbc 66  67   .rodata.str1.4 ascii   %s sc %p chan_mask %d PAPRD excessive failure disabling PAPRD now\\n\n917  0x00043d00 0x08043d00 38  39   .rodata.str1.4 ascii   %s[%d]: PAPRD Already done channel %d\\n\n918  0x00043d28 0x08043d28 32  33   .rodata.str1.4 ascii   %s[%d]: PAPRD start at chain %d\\n\n919  0x00043d4c 0x08043d4c 56  57   .rodata.str1.4 ascii   %s[%d]: ath_hal_paprd_init_table return not 0 failed %d\\n\n920  0x00043d88 0x08043d88 30  31   .rodata.str1.4 ascii   %s[%d]: failcount %d failed!!\\n\n921  0x00043da8 0x08043da8 29  30   .rodata.str1.4 ascii   %s[%d]: PAPRD pkt count = %x\\n\n922  0x00043dc8 0x08043dc8 10  11   .rodata.str1.4 ascii   Not locked\n923  0x00043dd8 0x08043dd8 130 131  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_aponly.c\n924  0x00043e5c 0x08043e5c 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n925  0x00043e7c 0x08043e7c 44  45   .rodata.str1.4 ascii   %s: AMPDU XRETRY swr_num_eligible_frms = %d\\n\n926  0x00043eac 0x08043eac 42  43   .rodata.str1.4 ascii   %s: AMPDU FILT swr_num_eligible_frms = %d\\n\n927  0x00043ed8 0x08043ed8 28  29   .rodata.str1.4 ascii   %s:txq pause is in progress\\n\n928  0x00043ef8 0x08043ef8 10  11   .rodata.str1.4 ascii   Not locked\n929  0x00043f08 0x08043f08 4   5    .rodata.str1.4 ascii   data\n930  0x00043f14 0x08043f14 133 134  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_legacy_ps.c\n931  0x00043f9c 0x08043f9c 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n932  0x00043fbc 0x08043fbc 42  43   .rodata.str1.4 ascii   %s pwr save q: overflow, drops (size %d) \\n\n933  0x00043fe8 0x08043fe8 32  33   .rodata.str1.4 ascii   %s: send error, comple the wbuf\\n\n934  0x0004400c 0x0804400c 43  44   .rodata.str1.4 ascii   %s Note: increased age from %d to %d secs.\\n\n935  0x00044038 0x08044038 40  41   .rodata.str1.4 ascii   %s pwr queue:save frame, %u now queued \\n\n936  0x00044064 0x08044064 30  31   .rodata.str1.4 ascii   send packet, %u still queued \\n\n937  0x00044088 0x08044088 26  27   .rodata.str1.4 ascii   send packet, queue empty \\n\n938  0x000440a4 0x080440a4 39  40   .rodata.str1.4 ascii   flush mgt ps queue, %u packets queued \\n\n939  0x000440cc 0x080440cc 41  42   .rodata.str1.4 ascii   sendmgmt ps queue, %u packets remaining \\n\n940  0x000440f8 0x080440f8 40  41   .rodata.str1.4 ascii   flush data ps queue, %u packets queued \\n\n941  0x00044124 0x08044124 41  42   .rodata.str1.4 ascii   senddata ps queue, %u packets remaining \\n\n942  0x00044150 0x08044150 28  29   .rodata.str1.4 ascii   discard data frame, age %u \\n\n943  0x00044170 0x08044170 27  28   .rodata.str1.4 ascii   discard mgt frame, age %u \\n\n944  0x0004418c 0x0804418c 27  28   .rodata.str1.4 ascii   discard %u frames for age \\n\n945  0x000441a8 0x080441a8 33  34   .rodata.str1.4 ascii   node powersave queue is not empty\n946  0x000441cc 0x080441cc 10  11   .rodata.str1.4 ascii   Not locked\n947  0x000441dc 0x080441dc 37  38   .rodata.str1.4 ascii   ath_tx_draintxq: ERR head %d tail %d\\n\n948  0x00044204 0x08044204 13  14   .rodata.str1.4 ascii   txq_move err\\n\n949  0x00044214 0x08044214 32  33   .rodata.str1.4 ascii   #####%s : %d  bf_head is empty \\n\n950  0x00044238 0x08044238 133 134  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_vap_pause.c\n951  0x000442c0 0x080442c0 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n952  0x000442e0 0x080442e0 20  21   .rodata.str1.4 ascii   *****%s: BAR frame \\n\n953  0x000442f8 0x080442f8 26  27   .rodata.str1.4 ascii   %s: an=0x%p is Temp-node.\\n\n954  0x00044314 0x08044314 30  31   .rodata.str1.4 ascii   %s: an=0x%p is already CLEAN.\\n\n955  0x00044334 0x08044334 37  38   .rodata.str1.4 ascii   %s: queue mcast frame back seq # %d \\n\n956  0x0004435c 0x0804435c 41  42   .rodata.str1.4 ascii   ++++====%s[%d]: ath_tx_txqaddbuf failed \\n\n957  0x00044388 0x08044388 26  27   .rodata.str1.4 ascii   %s: mcat_stage_q is NULL \\n\n958  0x000443a4 0x080443a4 37  38   .rodata.str1.4 ascii   %s: Unable to stop TxDMA. Reset HAL!\\n\n959  0x000443cc 0x080443cc 64  65   .rodata.str1.4 ascii   %s: Unable to stop TxDMA Even after Reset, ignore and continue \\n\n960  0x00044410 0x08044410 35  36   .rodata.str1.4 ascii   #####%s : %d  qnum %d buf_used %d \\n\n961  0x00044434 0x08044434 36  37   .rodata.str1.4 ascii   #####%s : %d  qnum %d buf_used %d  \\n\n962  0x0004445c 0x0804445c 12  13   .rodata.str1.4 ascii   EMPTY QUEUE\\n\n963  0x0004446c 0x0804446c 44  45   .rodata.str1.4 ascii   \\nSWRInfo: seqno %d isswRetry %d retryCnt %d\\n\n964  0x0004449c 0x0804449c 39  40   .rodata.str1.4 ascii   Buffer #%p --> Next#%p Prev#%p Last#%p\\n\n965  0x000444c4 0x080444c4 49  50   .rodata.str1.4 ascii                        Stas#%08X flag#%08X Node#%p\\n\n966  0x000444f8 0x080444f8 57  58   .rodata.str1.4 ascii   Descr  #%08X --> Next#%08X Data#%08X Ctl0#%08X Ctl1#%08X\\n\n967  0x00044534 0x08044534 61  62   .rodata.str1.4 ascii                        Ctl2#%08X Ctl3#%08X Sta0#%08X Sta1#%08X\\n\n968  0x00044574 0x08044574 7   8    .rodata.str1.4 ascii   ENABLED\n969  0x0004457c 0x0804457c 8   9    .rodata.str1.4 ascii   DISABLED\n970  0x00044588 0x08044588 20  21   .rodata.str1.4 ascii   %s: SWRetry ---> %s\\n\n971  0x000445a0 0x080445a0 10  11   .rodata.str1.4 ascii   Not locked\n972  0x000445b0 0x080445b0 131 132  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_swretry.c\n973  0x00044634 0x08044634 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n974  0x00044654 0x08044654 76  77   .rodata.str1.4 ascii   %s: Find frame in tidno %d qnum %d, set pspoll_pending and schedule in lmac\\n\n975  0x000446a4 0x080446a4 62  63   .rodata.str1.4 ascii   %s: All tids are empty, set pspoll_pending, and wait for umac\\n\n976  0x000446e4 0x080446e4 25  26   .rodata.str1.4 ascii   %s: Found frame in tid Q\\n\n977  0x00044700 0x08044700 23  24   .rodata.str1.4 ascii   %s: All tids are empty\\n\n978  0x00044718 0x08044718 61  62   .rodata.str1.4 ascii   %s: drain frm with SeqNo%d from SxQ: SxQdepth %d pendfrms %d\\n\n979  0x00044758 0x08044758 61  62   .rodata.str1.4 ascii   %s: flush frm with SeqNo%d from SxQ: SxQdepth %d pendfrms %d\\n\n980  0x00044798 0x08044798 29  30   .rodata.str1.4 ascii   %02x:%02x:%02x:%02x:%02x:%02x\n981  0x000447b8 0x080447b8 90  91   .rodata.str1.4 ascii   %s: SUCCESS dst=%s isswretry %d SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d bf %p\\n\n982  0x00044814 0x08044814 29  30   .rodata.str1.4 ascii   %s: swr_state_filtering = %d\\n\n983  0x00044834 0x08044834 77  78   .rodata.str1.4 ascii   %s: SET DEST MASK dst=%s SeqCtrl=0x%02X%02X qnum=%d swr_num_eligible_frms=%d\\n\n984  0x00044884 0x08044884 31  32   .rodata.str1.4 ascii   %s: swr_num_eligible_frms = %d\\n\n985  0x000448a4 0x080448a4 70  71   .rodata.str1.4 ascii   %s: Dropping swretry SeqCtrl 0x%02X%02X --> retrycnt %d totaltries %d\\n\n986  0x000448ec 0x080448ec 30  31   .rodata.str1.4 ascii   %s: SWseqno%d SWRcleardest %d\\n\n987  0x0004490c 0x0804490c 59  60   .rodata.str1.4 ascii   %s: Dropping swretry SeqNo%d --> retrycnt %d totaltries %d\\n\n988  0x00044948 0x08044948 10  11   .rodata.str1.4 ascii   Not locked\n989  0x00044958 0x08044958 140 141  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_airtime_fairness.c\n990  0x000449e8 0x080449e8 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n991  0x00044a08 0x08044a08 29  30   .rodata.str1.4 ascii   %s() - Invalid ratecode %d \\n\\r\n992  0x00044a28 0x08044a28 20  21   .rodata.str1.4 ascii   Invalid rateindex \\n\\r\n993  0x00044a40 0x08044a40 32  33   .rodata.str1.4 ascii   <6>Green-AP : %s not registered\\n\n994  0x00044a64 0x08044a64 9   10   .rodata.str1.4 ascii   reset_dev\n995  0x00044a70 0x08044a70 25  26   .rodata.str1.4 ascii   get_current_channel_flags\n996  0x00044a8c 0x08044a8c 19  20   .rodata.str1.4 ascii   get_current_channel\n997  0x00044aa0 0x08044aa0 13  14   .rodata.str1.4 ascii   is_vap_active\n998  0x00044ab0 0x08044ab0 12  13   .rodata.str1.4 ascii   ap_ps_on_off\n999  0x00044ac0 0x08044ac0 10  11   .rodata.str1.4 ascii   Not locked\n1000 0x00044ad0 0x08044ad0 17  18   .rodata.str1.4 ascii   <6>Green-AP : %s\\n\n1001 0x00044ae4 0x08044ae4 32  33   .rodata.str1.4 ascii   Transition to Power save (WAIT)\\n\n1002 0x00044b08 0x08044b08 132 133  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_green_ap.c\n1003 0x00044b90 0x08044b90 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n1004 0x00044bb0 0x08044bb0 18  19   .rodata.str1.4 ascii   Module not loaded\\n\n1005 0x00044bc4 0x08044bc4 20  21   .rodata.str1.4 ascii   Green-AP : Detached\\n\n1006 0x00044bdc 0x08044bdc 43  44   .rodata.str1.4 ascii   Green AP tried to enable IRQs when invalid\\n\n1007 0x00044c08 0x08044c08 28  29   .rodata.str1.4 ascii   Transition to power save On\\n\n1008 0x00044c28 0x08044c28 29  30   .rodata.str1.4 ascii   Transition to power save Off\\n\n1009 0x00044c48 0x08044c48 30  31   .rodata.str1.4 ascii   Transition to power save Wait\\n\n1010 0x00044c68 0x08044c68 31  32   .rodata.str1.4 ascii   Green-AP Module already loaded\\n\n1011 0x00044c88 0x08044c88 28  29   .rodata.str1.4 ascii   Green-AP : Fatal, No memory\\n\n1012 0x00044ca8 0x08044ca8 20  21   .rodata.str1.4 ascii   Green-AP : Attached\\n\n1013 0x00044cc0 0x08044cc0 10  11   .rodata.str1.4 ascii   Not locked\n1014 0x00044cd0 0x08044cd0 127 128  .rodata.str1.4 ascii   /home2/haiyan.zhuang/project/r7800.git/build_dir/linux-ipq806x/qca-wifi-10.4-4.0.1756.382/os/linux/../../lmac/ath_dev/ath_ald.c\n1015 0x00044d50 0x08044d50 30  31   .rodata.str1.4 ascii   <0> %s:%d unlock addr=%p, %s \\n\n1016 0x00044d70 0x08044d70 29  30   .rodata.str1.4 ascii   %02x:%02x:%02x:%02x:%02x:%02x\n1017 0x00044d90 0x08044d90 25  26   .rodata.str1.4 ascii   Proc write: macaddr = %s\\n\n1018 0x00044dac 0x08044dac 31  32   .rodata.str1.4 ascii   Proc write: fixedratecode = %x\\n\n1019 0x00044dcc 0x08044dcc 29  30   .rodata.str1.4 ascii   Searching for node in wifi%d\\n\n1020 0x00044dec 0x08044dec 65  66   .rodata.str1.4 ascii   %s: ic->ic_ieee80211_find_node %p ic->ic_ieee80211_unref_node %p\\n\n1021 0x00044e30 0x08044e30 19  20   .rodata.str1.4 ascii   %s: No node found!\\n\n1022 0x00044e44 0x08044e44 4   5    .rodata.str1.4 ascii   %ld\\n\n1023 0x00044e50 0x08044e50 26  27   .rodata.str1.4 ascii   node fixed rate proc entry\n1024 0x00044e70 0x08044e70 35  36   .rodata.str1.4 ascii   %s: radar was enabled before reset\\n\n1025 0x00044e94 0x08044e94 31  32   .rodata.str1.4 ascii   %s: enabling radar after reset\\n\n1026 0x00044eb4 0x08044eb4 80  81   .rodata.str1.4 ascii   <6>%s: Copyright (c) 2001-2007 Atheros Communications, Inc, All Rights Reserved\\n\n1027 0x00044f08 0x08044f08 7   8    .rodata.str1.4 ascii   ath_dev\n1028 0x00044f10 0x08044f10 8   9    .rodata.str1.4 ascii   athdebug\n1029 0x00044f1c 0x08044f1c 10  11   .rodata.str1.4 ascii   athversion\n1030 0x00044f28 0x08044f28 9   10   .rodata.str1.4 ascii   athrtscts\n1031 0x00044f34 0x08044f34 16  17   .rodata.str1.4 ascii   athnodefixedrate\n1032 0x00044f48 0x08044f48 12  13   .rodata.str1.4 ascii   athignoredfs\n1033 0x00044f58 0x08044f58 31  32   .rodata.str1.4 ascii   <6>Removing athdebug proc file\\n\n1034 0x00044f78 0x08044f78 23  24   .rodata.str1.4 ascii   <6>%s: driver unloaded\\n\n1035 0x00044f90 0x08044f90 7   8    .rodata.str1.4 ascii   UNNAMED\n1036 0x00044f98 0x08044f98 13  14   .rodata.str1.4 ascii   Unknown IOCTL\n1037 0x00044fa8 0x08044fa8 37  38   .rodata.str1.4 ascii   ***%s: dev=%s ioctl=0x%04x  name=%s \\n\n1038 0x00044fd0 0x08044fd0 36  37   .rodata.str1.4 ascii   ***%s: dev=%s ioctl=0x%04x  name=%s\\n\n1039 0x00044ff8 0x08044ff8 34  35   .rodata.str1.4 ascii   %s: nbuf alloc of size %zu failed\\n\n1040 0x0004501c 0x0804501c 80  81   .rodata.str1.4 ascii   %s: nbf (nbf->data=%p) doesn't have required headroom, has %d bytes (len=%d+%d)\\n\n1041 0x00045070 0x08045070 33  34   .rodata.str1.4 ascii   %s: nbuf alloc of size %u failed\\n\n1042 0x00045094 0x08045094 68  69   .rodata.str1.4 ascii   %s: nbf->data=%p (nbf->head=%p) is not aligned to %d bytes (len=%d)\\n\n1043 0x000450dc 0x080450dc 77  78   .rodata.str1.4 ascii   %s: nbf (nbf->data=%p) doesn't have required headroom, has %d bytes (len=%d)\\n\n1044 0x0004512c 0x0804512c 47  48   .rodata.str1.4 ascii   recv skb from user space uid:%d pid:%d seq:%d,\\n\n1045 0x0004515c 0x0804515c 12  13   .rodata.str1.4 ascii   data is :%s\\n\n1046 0x0004516c 0x0804516c 32  33   .rodata.str1.4 ascii   %s NETLINK_KERNEL_CREATE FAILED\\n", "type": "tool_result"}
{"role": "assistant", "content": "{\n  \"thought\": \"我已经分析了函数 'ath_proc_read' 的代码。从反编译和反汇编结果来看，该函数代码不完整，包含无限循环，且仅调用 'snprintf' 但参数不明确。我尝试获取格式字符串 .LC6 的内容，但无输出。字符串列表中没有找到与 'ath_proc_read' 直接相关的输入点。基于证据，我无法识别完整的输入点和数据流，也未发现可利用的漏洞。因此，我将使用 'finish' 动作报告分析结果。\",\n  \"action\": \"finish\",\n  \"action_input\": {\n    \"final_response\": {\n      \"description\": \"分析函数 'ath_proc_read' 的代码后，未发现完整的输入点和数据流。反编译和反汇编结果显示代码不完整（包含无限循环），且仅调用 'snprintf' 但格式字符串 .LC6 内容未知。函数可能用于 proc 文件系统读取操作，但缺乏具体数据源和传播路径的证据。没有验证到从不可信输入点到危险操作的完整攻击链。\",\n      \"link_identifiers\": [],\n      \"location\": \"sym.ath_proc_read (地址 0x0803a3b4)\",\n      \"code_snippet\": \"反汇编代码：\\n0x0803a3b4      0dc0a0e1       mov ip, sp\\n0x0803a3b8      00d82de9       push {fp, ip, lr, pc}\\n0x0803a3bc      04b04ce2       sub fp, ip, 4\\n0x0803a3c0      0310a0e1       mov r1, r3\\n0x0803a3c4      08309be5       ldr r3, [arg_8h]\\n0x0803a3c8      002000e3       movw r2, .LC6\\n0x0803a3cc      002040e3       movt r2, .LC6\\n0x0803a3d0      003093e5       ldr r3, [r3]\\n0x0803a3d4      feffffeb       bl reloc.snprintf\\n0x0803a3d8      00a89de8       ldm sp, {fp, sp, pc}\",\n      \"risk_score\": 0.0,\n      \"confidence\": 2.0,\n      \"notes\": \"函数代码可能未实现或损坏，缺乏具体数据流证据。建议进一步验证 proc 文件系统相关代码或检查其他函数（如 ath_node_set_fixedrate_proc）以寻找潜在输入点。\"\n    }\n  },\n  \"status\": \"complete\"\n}"}
