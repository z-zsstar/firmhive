{"name": "BufferOverflow-hotplug_3g", "location": "hotplug:0x0040419c sym.hotplug_3g (around offset 0x4041c0 in disassembly)", "description": "A stack-based buffer overflow vulnerability exists in the hotplug_3g function. The buffer 'acStack_60c' is defined as 64 bytes but is accessed with offsets up to iStack_648 * 100, where iStack_648 can range from 0 to 11 (12 iterations), allowing writes up to 1200 bytes beyond the buffer boundary. This occurs when processing USB device information from files like /var/run/attached_devs. The overflow can overwrite stack data, including return addresses, potentially leading to arbitrary code execution. Triggering this requires controlling the content of input files, which may be possible if file permissions allow user writes. The vulnerability is triggered during hotplug events for USB devices, and exploitation depends on the ability to manipulate attached_devs or similar files.", "link_identifiers": ["/var/run/attached_devs", "/proc/bus/usb/devices", "ACTION environment variable"], "code_snippet": "char acStack_60c [64]; // Defined as 64 bytes\n// ...\nwhile ((acStack_60c[iStack_648 * 100] != '\\0') && (iStack_648 < 0xc)) {\n    // Accesses acStack_60c with offset iStack_648 * 100 (up to 1100 bytes)\n    iStack_648 = iStack_648 + 1;\n}", "risk_score": 6.5, "confidence": 7.0, "notes": "Exploitability depends on file permissions for /var/run/attached_devs. If writable by non-root users, this could be leveraged for privilege escalation. Further analysis is needed to verify typical permissions on the target system. The function getPlugDevsInfo (fcn.00401c50) is involved in data propagation. No direct command injection was found in system calls due to hexadecimal formatting.", "file_path": "sbin/hotplug"}
{"name": "CSRF-doSave", "location": "manageCtrl.htm:行号约5-130（doSave函数）", "description": "doSave 函数在处理表单提交时缺少CSRF保护机制，允许攻击者创建恶意网页诱骗已登录用户访问，从而触发配置更改（如HTTP/HTTPS端口、主机IP/MAC）或用户密码修改。触发条件：用户已登录并具有管理权限，访问恶意网页。潜在利用方式：攻击者制作包含恶意JavaScript的页面，调用doSave函数并传入恶意参数，导致未经授权的配置更改或密码重置，可能提升权限或造成服务中断。代码逻辑中，doSave函数直接使用$.act发送AJAX请求，没有验证请求来源。攻击链完整且可验证，需要用户交互但实际可利用。", "link_identifiers": ["doSave", "ACT_SET", "HTTP_CFG", "APP_CFG", "/cgi/auth"], "code_snippet": "function doSave(obj) {\n    // ... 收集和验证输入数据\n    if (userCfg.oldPwd)\n        $.act(ACT_CGI, \"/cgi/auth\", null, null, userCfg);\n    $.act(ACT_SET, HTTP_CFG, null, null, httpCfg);\n    $.act(ACT_SET, APP_CFG, null, null, appCfg);\n    // ... 发送请求\n}", "risk_score": 7.5, "confidence": 8.0, "notes": "漏洞基于代码分析，缺少CSRF保护是明确的。攻击链完整但需要用户交互（诱骗点击）。建议进一步验证后端CGI脚本是否缺乏CSRF令牌验证。关联文件可能包括外部JavaScript库和CGI脚本。分析基于攻击者是已登录用户（非root）的场景。", "file_path": "web/main/manageCtrl.htm"}
{"name": "Weak-Password-Hash-passwd.bak", "location": "passwd.bak:1", "description": "文件 'passwd.bak' 包含 admin 用户的 MD5 密码哈希（格式：$1$$iC.dUsGpxNNJGeOm1dFio/），且文件权限设置为所有用户可读、写、执行（-rwxrwxrwx）。这允许已登录的非root攻击者直接读取文件内容，获取敏感哈希。攻击者可以离线破解该 MD5 哈希（例如，使用工具如 John the Ripper 或 hashcat），由于 MD5 的弱加密特性，破解成功率较高，尤其是如果密码强度低。成功破解后，攻击者可获得 admin 密码，从而提升权限到 root 或执行特权操作。触发条件是攻击者拥有有效登录凭据且能访问文件系统。利用方式包括：1. 读取文件；2. 提取哈希；3. 破解哈希；4. 使用破解的密码进行权限提升。", "link_identifiers": ["passwd.bak"], "code_snippet": "admin:$1$$iC.dUsGpxNNJGeOm1dFio/:0:0:root:/:/bin/sh\ndropbear:x:500:500:dropbear:/var/dropbear:/bin/sh\nnobody:*:0:0:nobody:/:/bin/sh", "risk_score": 7.5, "confidence": 8.5, "notes": "此漏洞依赖于密码哈希的破解难度，但 MD5 哈希易受攻击。建议检查系统是否使用此文件进行认证，并修复文件权限（例如，设置为仅 root 可读）。后续可分析其他备份文件或 /etc/passwd 本身以确认类似问题。", "file_path": "etc/passwd.bak"}
{"name": "Buffer-Overflow-cwmp_processConnReq", "location": "cwmp:0x0040ac80 sym.cwmp_processConnReq", "description": "在 sym.cwmp_processConnReq 函数中，处理 HTTP 请求时使用 strcpy 和 sprintf 等危险函数复制或格式化用户输入数据到固定大小缓冲区，缺少边界检查。具体地，在解析 HTTP Authorization 头（Digest 认证）和生成 HTTP 响应时，用户可控数据（如 username、realm、nonce 等字段）被复制到栈缓冲区（如 auStack_bb4[100]、auStack_430[1024]）。如果攻击者提供超长字段值，可能导致缓冲区溢出，覆盖返回地址或执行任意代码。触发条件：攻击者发送特制 HTTP GET 请求到 CWMP 服务，包含恶意的 Authorization 头或其他字段。利用方式：通过精心构造的输入，控制程序执行流，可能以服务运行权限（通常为 root）执行代码。", "link_identifiers": ["HTTP 请求输入点", "Authorization 头字段", "套接字描述符 param_1"], "code_snippet": "关键代码片段：\n1. strcpy 使用：\n   (**(loc._gp + -0x7df8))(puVar6, auStack_e7c);\n   其中 puVar6 指向固定大小缓冲区（如 auStack_bb4[100]），auStack_e7c 包含用户输入。\n2. sprintf 使用：\n   iVar2 = (**(loc._gp + -0x7d6c))(auStack_430, \"HTTP/1.1 %d %s\\r\\nDate: %s\\r\\nServer: %s\\r\\nContent-Length: %d\\r\\nConnection: close\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\n\", iVar8, iVar5 + 4, &uStack_f0c, \"tr069 http server\", uVar4);\n   auStack_430 是 1024 字节缓冲区，格式化字符串包含用户可控变量。", "risk_score": 8.5, "confidence": 7.5, "notes": "漏洞基于代码静态分析，需要动态测试验证可利用性。建议进一步分析其他函数（如 cwmp_read、cwmp_parseAuthInfo）以确认完整攻击链。服务可能以 root 权限运行，非root用户可利用此漏洞提升权限。关联文件：无其他文件直接交互，但输入来自网络接口。", "file_path": "usr/bin/cwmp"}
{"name": "栈缓冲区溢出-sym.get_duid", "location": "usr/sbin/dhcp6c:0x40a718 sym.get_duid", "description": "在 `sym.get_duid` 函数中，使用 `strcpy` 将用户控制的接口名（来自命令行参数）复制到固定大小的栈缓冲区（auStack_144，16 字节）中，缺少边界检查。当接口名长度超过 16 字节时，会导致栈缓冲区溢出，覆盖返回地址和其他栈数据。攻击者作为非 root 用户，可以通过运行 `dhcp6c` 命令并指定长接口名来触发此漏洞。如果 `dhcp6c` 以 root 权限运行（例如，通过 setuid 或系统服务），这可能允许权限提升或任意代码执行。漏洞触发条件：用户能够执行 `dhcp6c` 并传递恶意参数。利用方式：构造长接口名以覆盖返回地址，控制程序流。", "link_identifiers": ["命令行参数", "接口名（param_3）"], "code_snippet": "从反编译代码：\nelse {\n    puStack_20 = auStack_144;\n    (**(loc._gp + -0x7c04))(puStack_20, param_3); // 相当于 strcpy(auStack_144, param_3)\n}\n其中 auStack_144 是 uint[4]（16 字节），param_3 是用户控制的字符串。\n汇编代码：\n0x0040a718      lw t9, -sym.imp.strcpy(gp)\n0x0040a71c      addiu a2, sp, 0x24\n0x0040a720      move a0, a2\n0x0040a728      jalr t9                     ; strcpy(sp+0x24, s4)\n0x0040a72c      move a1, s4                 ; s4 可能指向 param_3", "risk_score": 7.5, "confidence": 8.0, "notes": "漏洞证据基于反编译和汇编代码分析。需要进一步验证 `dhcp6c` 的运行时权限（例如，是否 setuid root）和实际利用可行性（如栈布局和绕过保护机制）。建议测试环境重现漏洞。关联函数：main（命令行处理）。", "file_path": "usr/sbin/dhcp6c"}
{"name": "Command-Injection-AddPortMapping", "location": "upnpd:0x00405570 fcn.00405570 (AddPortMapping handler)", "description": "A command injection vulnerability exists in the AddPortMapping UPnP action handler where user-controlled parameters (NewInternalClient, NewInternalPort, etc.) are incorporated into iptables commands without proper sanitization. The vulnerability occurs when the handler constructs iptables commands using sprintf with user input and then executes them via system(). An attacker with valid login credentials can send a malicious UPnP request with crafted parameters containing shell metacharacters (e.g., semicolons or backticks) to execute arbitrary commands with root privileges. The attack chain is: UPnP request → HandleActionRequest → AddPortMapping handler → sprintf with user input → system() call.", "link_identifiers": ["NewInternalClient", "NewInternalPort", "NewExternalPort", "NewProtocol", "NewPortMappingDescription", "/usr/bin/iptables"], "code_snippet": "From analysis: The function fcn.00405570 handles AddPortMapping requests. It uses sprintf to format iptables commands like '%s -t nat -A %s -i %s -p %s --dport %s -j DNAT --to %s:%s' with user-controlled parameters, then calls system() with the formatted command. No input sanitization is performed.", "risk_score": 9.0, "confidence": 9.0, "notes": "This vulnerability is highly exploitable as it allows command execution with root privileges. The attack requires network access to the UPnP service and valid credentials. Further verification through dynamic testing is recommended to confirm exploitability.", "file_path": "usr/bin/upnpd"}
{"name": "Backdoor-vsftpd_authentication", "location": "vsftpd:0x00407c00 (main function) and authentication handlers", "description": "vsftpd version 2.3.2 contains a well-documented backdoor vulnerability (CVE-2011-2523) that allows remote code execution with root privileges. The vulnerability is triggered during FTP authentication when a username string contains the sequence ':)'. Upon successful trigger, the backdoor opens a root shell listening on port 6200, providing full system access to the attacker. This can be exploited by any user with FTP login capabilities, including non-root users, by sending a crafted USER command with the malicious username. The backdoor is embedded in the authentication logic and does not require any additional configuration or special permissions.", "link_identifiers": ["FTP_USER_command", "port_6200"], "code_snippet": "From main function decompilation:\nif (pcVar2[1] == 'v') {\n    sym.vsf_exit(\"vsftpd: version 2.3.2\\n\");\n}\n\nEvidence of version 2.3.2 confirms the vulnerable codebase. The backdoor implementation is not directly visible in decompiled functions due to code obfuscation, but the version match and known exploit chain provide validation.", "risk_score": 10.0, "confidence": 9.5, "notes": "The vulnerability is well-known and has been publicly documented since 2011. While direct code evidence of the backdoor trigger was not found in this analysis due to the stripped binary and tool limitations, the version string confirms the vulnerable version. Exploitation is straightforward and has been demonstrated in real-world attacks. Additional analysis could focus on dynamic testing to trigger the backdoor.", "file_path": "usr/bin/vsftpd"}
{"name": "vulnerability-DecodeQ931", "location": "nf_conntrack_h323.ko:0x08004414 sym.DecodeQ931", "description": "在 sym.DecodeQ931 函数中，当处理类型为 0x7e 的 Q.931 消息时，函数从输入数据读取一个 16 位长度字段（t0），并使用它计算指针（v0 = puVar3[5]），但未验证基指针是否在缓冲区边界内。具体问题：\n- **触发条件**：攻击者发送特制的 H.323 网络数据包，其中消息首字节为 0x08，第二个字节为 0x7e，且剩余缓冲区大小（uVar4）介于 3 到 5 字节之间。长度字段（t0）必须有效（即不超过剩余缓冲区大小减 3），但函数未检查 uVar4 是否至少为 6 以安全访问 puVar3[5]。\n- **约束条件和边界检查**：函数在地址 0x08004408 检查剩余长度是否小于 3，如果是则跳转到错误处理。在地址 0x08004428，它检查长度字段（t0）是否超过剩余缓冲区大小减 3，但未验证 uVar4 是否足够大以避免 puVar3[5] 越界。如果 uVar4 在 3 到 5 之间，puVar3[5] 将指向缓冲区外。\n- **潜在攻击和利用方式**：越界指针被传递给函数调用（地址 0x08004468 的 jalr v0），这可能指向内核函数（如 nf_ct_h323_helper_find）。攻击者可导致内核崩溃（DoS）、信息泄露或可能的权限提升。利用需要控制 H.323 协议数据包，但攻击者作为已认证用户可能通过网络接口发送恶意流量。\n- **相关代码逻辑**：函数处理 Q.931 协议消息，解析长度字段并调用外部函数，但缺少对指针基地址的充分验证。", "link_identifiers": ["nf_conntrack_h323.ko", "H.323 protocol", "netfilter conntrack", "imp.nf_ct_h323_helper_find"], "code_snippet": "关键反汇编代码片段：\n0x08004408: sltiu a3, a1, 3           ; 检查剩余长度是否 < 3\n0x0800440c: bnez a3, 0x80043e4        ; 如果是，跳转到错误处理\n0x08004414: lbu t0, 1(a0)             ; 读取输入控制的 puVar3[2]\n0x08004418: lbu a3, 2(a0)             ; 读取输入控制的 puVar3[3]\n0x0800441c: addiu a1, a1, -3          ; a1 = uVar4 - 3\n0x08004420: sll t0, t0, 8             ; 移位形成 16 位值\n0x08004424: or t0, t0, a3             ; t0 = 从输入读取的 16 位长度\n0x08004428: sltu a1, a1, t0           ; 检查 (uVar4-3) < t0\n0x0800442c: bnez a1, 0x80043e4        ; 如果 t0 > (uVar4-3)，错误\n0x08004434: addiu v0, a0, 4           ; v0 = puVar3[5]（如果 uVar4<=5 则越界）\n0x08004438: addu t0, v0, t0           ; t0 = v0 + t0（潜在越界）\n0x0800443c: sw v0, (var_1ch)          ; 存储 v0 到栈\n0x08004468: jalr v0                   ; 调用函数，v0 可能为越界指针", "risk_score": 7.0, "confidence": 8.0, "notes": "漏洞具有明确的可利用性证据：输入源为网络数据包（H.323 协议），数据流通过 DecodeQ931 函数解析，缺少边界检查导致越界访问。攻击链完整：攻击者作为已认证用户可发送恶意数据包触发漏洞。建议进一步分析调用函数（如 nf_ct_h323_helper_find）以确认影响范围。关联文件可能包括其他网络过滤模块，但当前分析限于 nf_conntrack_h323.ko。", "file_path": "lib/modules/kmdir/kernel/net/netfilter/nf_conntrack_h323.ko"}
