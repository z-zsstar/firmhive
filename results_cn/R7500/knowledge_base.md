# R7500 (18 个发现)

---

### StackBufferOverflow-fcn.00009c88

- **文件/目录路径：** `bin/ookla`
- **位置：** `ookla:0x9c88 fcn.00009c88`
- **风险评分：** 9.0
- **置信度：** 9.0
- **描述：** 在函数 fcn.00009c88 中，存在栈缓冲区溢出漏洞。漏洞触发于 memcpy 操作，其中复制长度由 strlen(源缓冲区) - 0x11 计算。如果源缓冲区（来自 param_1 + 0x820）的字符串长度小于 0x11（17 字节），则长度计算下溢，变为很大的无符号值（例如，strlen=0 时长度为 0xFFFFFFFF），导致 memcpy 复制过量数据到目标栈缓冲区。目标缓冲区位于栈帧低位，溢出可覆盖保存的返回地址（LR），允许攻击者控制程序流。触发条件：攻击者提供 param_1 输入，使 param_1 + 0x820 指向短字符串（长度 < 17）。param_1 源自命令行参数处理（通过 fcn.00014680 中的 getopt_long），用户可通过运行 ookla 二进制并传递特制参数控制数据。约束条件：源缓冲区长度必须小于 17 字节以触发下溢；目标缓冲区大小固定，溢出可覆盖关键栈数据。潜在攻击方式：攻击者构造短字符串输入，触发溢出后覆盖返回地址，实现任意代码执行。由于攻击者拥有有效登录凭据（非 root 用户），可本地运行二进制并提升权限。相关代码逻辑：漏洞源于输入处理缺乏边界检查，直接使用 strlen 计算结果作为 memcpy 长度。
- **代码片段：**
  ```
  iVar1 = sym.imp.strlen(piVar7 + 0 + -0x400);
  sym.imp.memcpy(piVar7 + 0 + -0x500, piVar7 + 0 + -0x400, iVar1 + -0x11);
  ```
- **关键词：** param_1
- **备注：** 漏洞独立可利用，无需依赖其他组件。建议进一步追踪 param_1 的最终来源以确认所有输入向量。

---
### Command-Injection-internet_con

- **文件/目录路径：** `etc/scripts/ntgr_sw_api/ntgr_sw_api.sh`
- **位置：** `ntgr_sw_api.sh:internet_con function (eval line)`
- **风险评分：** 9.0
- **置信度：** 9.0
- **描述：** 在 'internet_con' 函数中发现命令注入漏洞。攻击者可通过以下步骤利用：1) 使用 'nvram set' 设置 'swapi_persistent_conn' NVRAM 变量为恶意字符串（如 "'; malicious_command; '"）；2) 调用 'internet_con' 函数（例如 './ntgr_sw_api.sh internet_con dummy app value'）。当 'eval tvalue=\'$($CONFIG get $SWAPI_PERSISTENT_CONN)\' 执行时，恶意命令会被执行。漏洞触发条件：攻击者能调用脚本并设置 NVRAM 变量；脚本可能以 root 权限运行，导致权限提升。利用方式简单，只需两个步骤。
- **代码片段：**
  ```
  eval tvalue=\'$($CONFIG get $SWAPI_PERSISTENT_CONN)\'\nif [ "x$(printf "$tvalue" | grep "$2\\ [01]")" != "x" ]; then\n    $CONFIG set $SWAPI_PERSISTENT_CONN="$(printf "$tvalue"|sed "s/$2\\ [01]/$2\\ $3/")"\nelse\n    $CONFIG set $SWAPI_PERSISTENT_CONN="${tvalue:+${tvalue};}$2 $3"\nfi
  ```
- **关键词：** swapi_persistent_conn, internet_con, nvram
- **备注：** 假设脚本以 root 权限运行（常见于系统配置脚本）。攻击链完整且可验证。建议检查脚本的调用上下文（如 Web 接口或 IPC）以确认可利用性。其他函数（如 'nvram set'）可能存在次要问题，但未发现完整攻击链。

---
### Command-Injection-start

- **文件/目录路径：** `usr/sbin/green_download.sh`
- **位置：** `green_download.sh:~132 start() function (精确行号可能因文件版本而异，但位于 start 函数末尾)`
- **风险评分：** 9.0
- **置信度：** 9.0
- **描述：** 在 'green_download.sh' 文件的 start 函数中，存在命令注入漏洞。当脚本启动 greendownload 进程时，它使用命令替换 $(/bin/config get ...) 和变量扩展来构建命令行参数。如果攻击者能够控制以下 NVRAM 配置变量：wan_ifname、green_download_max_uprate、green_download_max_downrate、green_download_max_tasks_run 或 green_download_max_tasks_all，并在其中注入 shell 元字符（如 ;、&、| 等），则可以在脚本以 root 权限运行时执行任意命令。

触发条件：
- 攻击者拥有有效登录凭据（非 root 用户）并能通过 Web 接口、API 或其他方式设置上述 NVRAM 配置变量。
- 攻击者触发绿色下载服务的启动或重启（例如通过启用该功能或更改设置）。
- 脚本以 root 权限运行（作为系统服务的一部分）。

潜在攻击方式：
- 攻击者将 wan_ifname 设置为 'eth0; malicious_command'，当脚本执行时，会先运行 greendownload -i eth0，然后执行 malicious_command。
- 类似地，其他配置变量也可用于注入命令。

漏洞利用链完整且可验证：攻击者控制输入（配置变量）→ 数据流经脚本未经验证 → 触发危险操作（命令执行）。
- **代码片段：**
  ```
  greendownload -i $(/bin/config get wan_ifname) -w $work_dir -s $statfifo_work_dir -u $green_dl_uprate -d $green_dl_downrate -r $green_dl_max_tasks_run -a $green_dl_max_tasks_all
  ```
- **关键词：** wan_ifname, green_download_max_uprate, green_download_max_downrate, green_download_max_tasks_run, green_download_max_tasks_all
- **备注：** 此漏洞需要攻击者能设置 NVRAM 配置变量并触发服务重启。建议检查其他组件（如 Web 接口）是否允许用户设置这些变量。此外，应分析 greendownload 二进制是否还有其他漏洞。符号链接攻击和路径遍历在 stop 函数中可能存在，但命令注入是更直接的可利用漏洞。

---
### CommandInjection-ppp.sh-print_ip_up

- **文件/目录路径：** `lib/network/ppp.sh`
- **位置：** `ppp.sh, in the print_ip_up function, specifically in the route del commands for staticdns1 and staticdns2`
- **风险评分：** 8.5
- **置信度：** 9.0
- **描述：** Command injection vulnerability in the PPP ip-up script generated by ppp.sh. The ip-up script, which runs with root privileges when a PPP connection is established, uses user-controlled configuration values (wan_ether_dns1 and wan_ether_dns2) in shell commands without proper sanitization. This allows command injection via shell metacharacters (e.g., semicolons). Trigger conditions include: (1) attacker sets wan_ether_dns1 or wan_ether_dns2 to a malicious string containing commands, (2) DNS assignment is enabled for the PPP protocol (e.g., wan_pptp_dns_assign=1 for PPTP), and (3) a PPP connection is established. Potential exploitation involves injecting commands to gain root access.
- **代码片段：**
  ```
  staticdns1="\$(config get wan_ether_dns1)"
  staticdns2="\$(config get wan_ether_dns2)"
  ...
  if [ "x\$staticdns1" != "x" ]; then
      /sbin/route del \$staticdns1
  elif [ "x\$staticdns2" != "x" ]; then
      /sbin/route del \$staticdns2
  fi
  ```
- **关键词：** wan_ether_dns1, wan_ether_dns2, wan_pptp_dns_assign, wan_l2tp_dns_assign, wan_pppoe_dns_assign, wan_proto, /etc/ppp/ip-up, /tmp/resolv.conf
- **备注：** This finding assumes the attacker can set NVRAM configuration values through an authenticated interface (e.g., web UI). The vulnerability is introduced when ppp.sh generates the ip-up script. Further analysis could verify the accessibility of config set commands by non-root users and explore other potential injection points.

---
### Kernel-Write-ufsd_ioctl

- **文件/目录路径：** `lib/ufsd/ufsd.ko`
- **位置：** `ufsd.ko:0x08005a28 ufsd_ioctl`
- **风险评分：** 8.5
- **置信度：** 9.0
- **描述：** 在 'ufsd_ioctl' 函数中，处理 ioctl 命令 0x80206659 (0x6659 | 0x80200000) 时，缺少对用户指针 param_3 的验证。函数直接写入 param_3 的偏移位置 (*(param_3 + 8) 和 *(param_3 + 0xc))，而没有检查 param_3 是否指向有效的用户空间地址或进行边界检查。攻击者作为已认证的非root用户，可以通过访问设备文件（如 /dev/ufsd）并发送特定 ioctl 命令，控制 param_3 指向内核地址，导致内核任意写入。写入的值是从内核结构读取的（uVar3 和 uVar7），但攻击者可能通过覆盖内核数据实现权限提升。触发条件：攻击者拥有设备文件访问权限和有效登录凭据。利用方式：构造恶意 ioctl 调用，指定 param_3 为目标内核地址，触发写入操作。
- **代码片段：**
  ```
  从反编译代码中提取的关键部分：
  if (param_2 != (0x6659 | 0x80200000)) {
      // ...
  } else {
      // ...
      if (param_3 != 0xfffffff8) {
          // ...
          *(param_3 + 8) = uVar3;
          *(param_3 + 0xc) = uVar7;
      }
      // ...
  }
  ```
- **关键词：** param_3, ioctl command 0x80206659, /dev/ufsd 设备文件
- **备注：** 此漏洞基于反编译代码分析，证据确凿。攻击链完整：攻击者控制 param_3 指针，ioctl 写入可能导致权限提升。建议进一步验证设备文件权限和内核地址映射。关联函数包括 func_0x08005a78 和 func_0x08005adc，但当前焦点在 ufsd_ioctl。

---
### command-injection-vlan_create_br_and_vif

- **文件/目录路径：** `lib/cfgmgr/opmode.sh`
- **位置：** `opmode.sh: function vlan_create_br_and_vif and vlan_create_brs_and_vifs`
- **风险评分：** 8.5
- **置信度：** 8.0
- **描述：** 在 'opmode.sh' 文件中发现命令注入漏洞。攻击者可以通过控制 NVRAM 变量 vlan_tag_1 到 vlan_tag_10 的值，在脚本执行时注入任意命令。具体来说，当脚本处理这些变量时，使用 'set - $(echo $tv)' 进行拆分，并将拆分后的字段（如 vid）直接用于命令执行（例如 'vconfig add $RawEth $1'）。如果 vid 字段包含 shell 元字符（如分号或管道符），将导致命令注入。触发条件包括：攻击者拥有有效登录凭据（非 root 用户），能通过 Web 界面或 API 设置 NVRAM 变量；脚本以 root 权限运行（常见于设备启动或配置更改时）。利用方式：设置 vlan_tag_i 为恶意值（如 '1 Internet 1; touch /tmp/pwned; 0 0 0'），当脚本运行时，注入的命令将以 root 权限执行。
- **代码片段：**
  ```
  for i in 1 2 3 4 5 6 7 8 9 10; do
      tv=$($CONFIG get vlan_tag_$i)
      [ -n "$tv" ] || continue
      set - $(echo $tv)
      # $1: enable, $2: name, $3: vid, $4: pri, $5:wports, $6:wlports
      [ "$1" = "1" ] || continue
      if [ "$2" = "Internet" ]; then 
          i_vid=$3
          i_pri=$4
      else
          used_wports=$(($used_wports | $5))
          vlan_create_br_and_vif $3 $4   # $3 (vid) is passed without validation
          sw_configvlan "vlan" "add" "br" $3 $5 $4
      fi
  done
  
  vlan_create_br_and_vif() # $1: vid, $2: pri
  {
      local brx="br$1"
      ...
      if [ -n "$RawEth" ]; then
          vconfig add $RawEth $1 && ifconfig $RawEth.$1 up   # Command injection if $1 contains malicious characters
          brctl addif $brx $RawEth.$1
          vlan_set_vif_pri $RawEth.$1 $2
      else
          ...
      fi
      ...
  }
  ```
- **关键词：** vlan_tag_1, vlan_tag_2, vlan_tag_3, vlan_tag_4, vlan_tag_5, vlan_tag_6, vlan_tag_7, vlan_tag_8, vlan_tag_9, vlan_tag_10
- **备注：** 此漏洞的利用依赖于脚本以 root 权限运行，且攻击者能触发脚本执行（例如通过更改设备配置）。建议验证 NVRAM 输入值，确保仅包含数字或安全字符。需要进一步分析其他文件（如 cfgmgr.sh）以确认完整攻击链和缓解措施。

---
### Path-Traversal-hostapd_functions

- **文件/目录路径：** `lib/wifi/hostapd.sh`
- **位置：** `hostapd.sh: hostapd_set_bss_options function and hostapd_setup_vif function`
- **风险评分：** 8.5
- **置信度：** 8.0
- **描述：** 路径遍历漏洞允许任意文件删除和覆盖。攻击者可通过修改无线配置中的 'phy' 或 'ifname' 参数，注入路径遍历序列（如 '../../etc/passwd'）。当脚本执行时，会使用这些参数构建文件路径，例如在 `rm /var/run/hostapd-$phy/$ifname` 和文件创建操作中。触发条件：攻击者拥有有效登录凭据（非root），能通过配置接口（如 Web 界面或 API）修改无线设置，并触发脚本执行（例如重启网络服务）。利用方式：注入恶意路径可删除系统关键文件（如 `/etc/passwd`）或覆盖配置文件，导致拒绝服务或潜在特权升级。代码逻辑直接使用输入变量而无过滤，缺少边界检查。
- **代码片段：**
  ```
  在 hostapd_set_bss_options 函数中：
  [ -f /var/run/hostapd-$phy/$ifname ] && rm /var/run/hostapd-$phy/$ifname
  ctrl_interface=/var/run/hostapd-$phy
  
  在 hostapd_setup_vif 函数中：
  cat > /var/run/hostapd-$ifname.conf <<EOF
  ...
  EOF
  hostapd -P /var/run/wifi-$ifname.pid -B /var/run/hostapd-$ifname.conf -e $entropy_file
  其中 entropy_file=/var/run/entropy-$ifname.bin
  ```
- **关键词：** phy, ifname, /var/run/hostapd-$phy/$ifname, /var/run/hostapd-$ifname.conf, /var/run/entropy-$ifname.bin
- **备注：** 漏洞依赖于配置系统允许设置恶意值；建议验证配置接口是否过滤输入。关联文件：可能涉及 UCI 配置文件（如 /etc/config/wireless）。后续分析方向：检查配置管理组件（如 Web 界面）是否对输入进行验证，并测试实际利用可行性。

---
### Command-Injection-read_conf_file_for_athr_hostapd

- **文件/目录路径：** `etc/hotplug.d/wps/00-wps`
- **位置：** `00-wps:read_conf_file_for_athr_hostapd 函数（具体行号未提供，但位于脚本中后部）`
- **风险评分：** 8.5
- **置信度：** 8.0
- **描述：** 在 read_conf_file_for_athr_hostapd 函数中，tmp_ssid 的赋值使用反引号命令替换（`cat $FILE |grep -nr '^ssid' |cut -d = -f 2-`），其中 $FILE 变量从环境变量获取且未充分验证。如果 $FILE 包含分号等命令分隔符（例如 '/tmp/evil; touch /tmp/pwned; #'），则可能注入并执行任意命令。触发条件包括：$ACTION=SET_CONFIG、$PROG_SRC=athr-hostapd、$SUPPLICANT_MODE≠1，且 $FILE 指向攻击者控制的恶意路径。攻击者作为非 root 用户，可通过创建恶意文件并触发 WPS 事件（如通过网络请求）来利用此漏洞，可能导致以 root 权限执行命令，实现权限提升。
- **代码片段：**
  ```
  read_conf_file_for_athr_hostapd() {
      sed -e 's/=/ /' -e '/^\#/d' -e '/^$/d' $FILE > ${FILE}.$$
      while read -r arg val; do
  	case "$arg" in
  	    ssid)
  		/* here the origin code will lead to bug 35280,[WPS]The SSID shows wrong when i set ssid contain spaces 
  		 * by Wired external registrar in Win7 ,so i repeace the ssid vaule as follows */
  		#tmp_ssid="$val"
  		tmp_ssid="\`cat $FILE |grep -nr '^ssid' |cut -d = -f 2-\`"
  		;;
  	    wpa|wpa_key_mgmt|wpa_pairwise|wps_state)
                  eval tmp_$arg="$val"
                  ;;
  	    wpa_passphrase)
                  # Handle special chars, "\" -> "\\\\", "\`" -> "\\`", """ -> "\""
                  # Note that the method to handle "\`" differs from the one of SSID above.
                  # This is weird but exactly done by Wireless Settings web page in WNDR3700.
  		tmp_wpa_passphrase="$(echo "$val"|sed -e 's/\\/\\\\/g' -e 's/\`/\\\`/g' -e 's/"/\\"/g')"
  		;;
  	    wpa_psk)
  		tmp_wpa_psk="$(echo $val|sed -e 's/\\/\\\\/g' -e 's/\`/\\\`/g' -e 's/"/\\"/g')"
  		;;
  	esac
      done < ${FILE}.$$
      rm -f ${FILE}.$$
      if [ "x$tmp_wpa_passphrase" = "x" ]; then
         tmp_wpa_passphrase="$tmp_wpa_psk"
      fi
  }
  ```
- **关键词：** $FILE, $ACTION, $PROG_SRC, $SUPPLICANT_MODE, /bin/config
- **备注：** 漏洞可利用性依赖于脚本以高权限（如 root）运行，这可能通过 hotplug 机制实现。攻击链完整：攻击者控制 $FILE 路径并触发 WPS 事件。建议验证 hotplug 上下文和权限模型。其他函数（如 set_config）使用输入过滤，但此点未过滤命令注入。关联文件：可能通过网络服务（如 hostapd）触发事件。

---
### Command-Injection-RMT_invite.cgi

- **文件/目录路径：** `www/cgi-bin/RMT_invite.cgi`
- **位置：** `RMT_invite.cgi:3 (eval statement) and proccgi (binary, imported functions: getenv, strcpy, strtok)`
- **风险评分：** 8.5
- **置信度：** 7.5
- **描述：** 命令注入漏洞存在于 'RMT_invite.cgi' 通过 'proccgi' 二进制文件。攻击者可以发送恶意 CGI 参数（如 FORM_submit_flag、FORM_TXT_remote_login 等），这些参数被 'proccgi' 处理并输出为 shell 变量赋值格式（例如 'FORM_param="value"'）。由于 'RMT_invite.cgi' 使用 eval 执行 'proccgi' 的输出，缺乏输入验证和过滤，攻击者可以注入命令分隔符（如分号、反引号或换行符）来执行任意命令。触发条件：攻击者发送特制 HTTP 请求到 CGI 端点，利用已登录用户权限。潜在利用方式包括执行系统命令、提升权限或设备完全妥协。约束条件：攻击者需有有效登录凭据，但无需 root 权限。
- **代码片段：**
  ```
  From RMT_invite.cgi:
  #!/bin/sh
  . /www/cgi-bin/func.sh
  eval "\`/www/cgi-bin/proccgi $*\`"
  
  From proccgi analysis (strings output):
  Embedded script: eval executing proccgi output
  Output format: FORM_%s="value"
  Imported functions: getenv, strcpy, strtok indicating input processing without bounds checking
  ```
- **关键词：** QUERY_STRING, CONTENT_LENGTH, REQUEST_METHOD, PATH_INFO, FORM_submit_flag, FORM_TXT_remote_login, FORM_TXT_remote_passwd, /www/cgi-bin/proccgi, /www/cgi-bin/func.sh, /www/cgi-bin/RMT_invite.cgi
- **备注：** 漏洞依赖于 'proccgi' 输出未过滤的数据，且 'RMT_invite.cgi' 直接使用 eval，创建了可 exploitation 的链。建议进行动态测试以确认命令执行。关联文件包括 'func.sh'，但未分析。后续应检查其他 CGI 脚本是否类似使用 'proccgi'。

---
### Config-Injection-cmd_ftp

- **文件/目录路径：** `lib/dnicmd/cmd_ftp`
- **位置：** `cmd_ftp: 函数 'scan_sharefoler_in_this_disk' 和 'print_onesharefolder_config'`
- **风险评分：** 7.5
- **置信度：** 8.5
- **描述：** 在 'cmd_ftp' 脚本中，共享名从 NVRAM 变量 'shared_usb_folder' 获取，并直接插入到 proftpd 配置文件中，缺少输入验证和转义。攻击者可以通过设置恶意共享名（包含换行符和 proftpd 配置指令）注入任意配置。例如，共享名可包含 '</Directory><Limit ALL>AllowAll</Limit>' 等指令，破坏配置文件结构并添加未授权的权限规则。触发条件：攻击者修改 NVRAM 变量后，脚本重新生成配置文件（如通过服务重启）。利用方式：攻击者使用有效凭据通过 Web 界面修改共享名，导致 proftpd 加载恶意配置，允许未授权文件访问或权限提升。
- **代码片段：**
  ```
  在 'scan_sharefoler_in_this_disk' 函数中：
  sharename=\`echo "$sharefolder_item" | awk -F* '{print $1}' | sed 's/ //g'\`
  ...
  print_onesharefolder_config "$sharename" "$access" "$j"
  
  在 'print_onesharefolder_config' 函数中：
  cat <<EOF >>$proftpd_tmpfile
  	<Directory /tmp/ftpadmin/shares/$1>
  	AllowOverwrite    on
  		<Limit DIRS>
  			DenyAll
  EOF
  ...
  cat <<EOF >> $proftpd_tmpfile
  	</Directory>
  EOF
  ```
- **关键词：** shared_usb_folder（NVRAM 变量）, /tmp/proftpd.conf（配置文件路径）, /bin/config（配置工具）
- **备注：** 此漏洞依赖于攻击者能修改 NVRAM 变量，可能通过 Web 界面实现。需要进一步验证 Web 界面是否对共享名输入进行了过滤。建议检查其他组件（如 Web 服务器）如何处理共享名输入。漏洞可能允许非 root 用户通过 FTP 获得未授权文件访问。

---
### CommandInjection-sw_configvlan_vid

- **文件/目录路径：** `lib/cfgmgr/enet.sh`
- **位置：** `enet.sh: sw_tmpconf_add_vlan function and sw_tmpconf_generate_swconf function`
- **风险评分：** 7.5
- **置信度：** 8.0
- **描述：** The 'vid' parameter in the 'sw_configvlan_vlan' function is used unsafely when writing to temporary files that are later sourced using the '.' command. This allows command injection if 'vid' contains malicious shell code. When the temporary file is sourced during 'sw_tmpconf_generate_swconf', any embedded commands in 'vid' are executed in the shell context, potentially leading to arbitrary command execution with root privileges. The vulnerability requires the attacker to control the 'vid' parameter passed to 'sw_configvlan' with opmode 'vlan' and action 'add'.
- **代码片段：**
  ```
  sw_tmpconf_add_vlan() # $1: vlanindex, $2: vid, $3: ports
  {
  	cat <<EOF > "$swconf.tmp$1"
  vid="$2"
  ports="$3"
  EOF
  }
  
  sw_tmpconf_generate_swconf() # $1: vlanindex
  {
  	local vid ports i=1
  
  	sw_printconf_add_switch
  	while [ $i -le $1 ]; do
  		. "$swconf.tmp$i"   # This sources the file, executing any commands
  		sw_printconf_add_vlan "switch0" "$i" "$vid" "$ports"
  		i=$(($i + 1))
  	done
  }
  ```
- **关键词：** vid parameter in sw_configvlan_vlan add, temporary files /tmp/sw.conf.tmp*, sourcing via . command
- **备注：** This vulnerability is exploitable if an attacker can control the 'vid' parameter through a configuration interface (e.g., web UI or API) that invokes this script. The script is likely run as root, so command execution would be with elevated privileges. Further analysis is needed to identify the calling context and parameter sources.

---
### CommandInjection-sw_configvlan_pri

- **文件/目录路径：** `lib/cfgmgr/enet.sh`
- **位置：** `enet.sh: sw_print_ssdk_cmds_set_ports_pri function and sw_configvlan_vlan function`
- **风险评分：** 7.5
- **置信度：** 8.0
- **描述：** The 'pri' parameter in the 'sw_configvlan_vlan' function is used unsafely in generated command files that are executed via 'sh'. This allows command injection if 'pri' contains malicious shell code. The 'pri' value is directly embedded into commands written to '$ssdk_cmds_file', and when 'qt sh $ssdk_cmds_file' is executed, any injected commands are run with root privileges. The vulnerability requires the attacker to control the 'pri' parameter passed to 'sw_configvlan' with opmode 'vlan' and action 'add'.
- **代码片段：**
  ```
  sw_print_ssdk_cmds_set_ports_pri() # $1: ports, $2: pri
  {
  	local p
  
  	for p in $ports; do
  		echo $p | grep -q "t" && continue
  
  		cat <<EOF
  $ssdk_sh qos ptDefaultCpri set $p $2
  EOF
  	done
  }
  
  # In sw_configvlan_vlan add:
  sw_print_ssdk_cmds_set_ports_pri "$ports" "$pri" >> $ssdk_cmds_file
  # Later executed with:
  qt sh $ssdk_cmds_file
  ```
- **关键词：** pri parameter in sw_configvlan_vlan add, command file /tmp/ssdk.sh, execution via qt sh
- **备注：** This vulnerability is exploitable if an attacker can control the 'pri' parameter through a configuration interface. The use of 'sh' to execute the command file makes it susceptible to injection. Further investigation is required to determine how 'sw_configvlan' is invoked and whether user input flows into these parameters.

---
### Module-Injection-load_qcawifi

- **文件/目录路径：** `lib/wifi/33-qca-wifi`
- **位置：** `qcawifi.sh: load_qcawifi 函数（具体行号未知，但代码片段来自脚本中的循环部分）`
- **风险评分：** 7.5
- **置信度：** 8.0
- **描述：** 文件 '33-qca-wifi' 包含 Wi-Fi 内核模块列表，权限为 -rwxrwxrwx，允许非 root 用户读写。脚本 'qcawifi.sh' 在函数 load_qcawifi 中读取此文件并使用 'insmod' 加载模块。由于 'insmod' 通常需要 root 权限，如果 'qcawifi.sh' 以 root 运行（常见于嵌入式系统），攻击者可通过修改 '33-qca-wifi' 注入恶意模块条目，导致任意代码执行和权限提升。触发条件包括系统启动、Wi-Fi 重新配置或相关服务重启时执行 'qcawifi.sh'。攻击者需拥有有效登录凭据（非 root）并能够修改文件，然后等待或触发模块加载过程。
- **代码片段：**
  ```
  for mod in $(cat /lib/wifi/33-qca-wifi*); do
      case ${mod} in
          umac) [ -d /sys/module/${mod} ] || insmod ${mod} ${umac_args};;
          *) [ -d /sys/module/${mod} ] || insmod ${mod};;
      esac
  done
  ```
- **关键词：** 文件路径: /lib/wifi/33-qca-wifi, 脚本路径: /lib/wifi/qcawifi.sh, 函数: load_qcawifi, 命令: insmod
- **备注：** 攻击链基于文件可写性和脚本使用 'insmod'，但需要验证 'qcawifi.sh' 是否以 root 权限执行。建议检查系统服务或初始化脚本（如 /etc/init.d/）如何调用此脚本。此外，应确认非 root 用户能否触发模块加载（例如通过网络接口或 CLI）。如果 'qcawifi.sh' 不以高权限运行，风险可能降低。关联文件包括当前目录中的其他脚本（如 hostapd.sh），但未发现直接引用。

---
### buffer-overflow-fcn.0000c038

- **文件/目录路径：** `sbin/net-util`
- **位置：** `net-util:0xc038 in function fcn.0000c038`
- **风险评分：** 7.5
- **置信度：** 8.0
- **描述：** A buffer overflow vulnerability exists in the function fcn.0000c038, which is called from commands like 'detwanv6' and 'daemonv6'. The function uses strcpy to copy the user-provided interface name (from command-line arguments) into a fixed-size stack buffer without any bounds checking. This allows an attacker to overflow the buffer by supplying a long string, potentially overwriting the return address and achieving arbitrary code execution. The vulnerability is triggered when net-util is executed with commands that require an interface name, such as 'net-util detwanv6 <interface>'. As a non-root user with login credentials, the attacker can control the input and craft a payload to exploit this.
- **代码片段：**
  ```
  sym.imp.strcpy(puVar6 + -7, param_1);  // param_1 is user-controlled command-line argument
  ```
- **关键词：** command-line arguments for 'detwanv6' or 'daemonv6' commands, interface name parameter
- **备注：** The risk score assumes that the binary may run with elevated privileges in some contexts (e.g., if called from root processes), but if not, the impact is limited to the user's privileges. Further analysis is needed to determine if net-util is setuid or called from privileged services. The buffer size is approximately 32 bytes, but exact layout requires deeper stack analysis. Exploitation might require bypassing protections, but firmware often lacks ASLR or canaries.

---
### Command-Injection-wx-config

- **文件/目录路径：** `usr/lib/wx/config/arm-openwrt-linux-base-unicode-release-2.8`
- **位置：** `arm-openwrt-linux-base-unicode-release-2.8:约行640-650（委托执行点）`
- **风险评分：** 7.5
- **置信度：** 8.0
- **描述：** 在 wx-config 脚本中发现命令注入漏洞，允许攻击者通过操纵 --exec-prefix 选项和配置掩码执行任意命令。触发条件：攻击者调用脚本时指定 --exec-prefix 指向其可控目录，并在该目录下创建包含 shell 元字符（如分号）的恶意文件名，使 configmask 匹配该文件。当脚本委托执行时，由于未对变量进行引号转义，shell 会解析文件名中的元字符作为命令分隔符，导致命令注入。利用方式：攻击者可放置文件名如 'malicious; echo hacked;' 的文件，并通过选项使 configmask 匹配，从而执行注入的命令。此漏洞需要攻击者具有对目标目录的写权限，但作为非 root 用户，他们可能控制主目录或临时目录。
- **代码片段：**
  ```
  # 委托执行代码片段
  if [ $_numdelegates -eq 1 ]; then
      $wxconfdir/\`find_eligible_delegates $configmask\` $*
      exit
  fi
  
  # 或使用 best_delegate
  if [ -n "$best_delegate" ]; then
      $wxconfdir/$best_delegate $*
      exit
  fi
  ```
- **关键词：** input_option_exec_prefix, input_option_prefix, wxconfdir, configmask, best_delegate
- **备注：** 漏洞依赖于攻击者能控制 --exec-prefix 目录和文件名。建议对变量使用引号（如 "$wxconfdir/$best_delegate"）以防止命令注入。后续可检查其他类似委托点或实用程序执行路径。关联函数：find_eligible_delegates, get_mask。

---
### Command-Injection-wireless_event

- **文件/目录路径：** `lib/wifi/wireless_event`
- **位置：** `wireless_event:7`
- **风险评分：** 7.0
- **置信度：** 8.0
- **描述：** 脚本在处理 CHANNEL 环境变量时存在命令注入漏洞。当 ACTION 为 'RADARDETECT' 时，脚本使用 `echo $CHANNEL` 在命令替换中（for 循环），由于变量未引用，如果 CHANNEL 包含反引号包围的命令（如 `malicious_command`），这些命令会在命令替换阶段被执行。攻击者可通过设置 CHANNEL 为恶意值（如 `rm -rf /` 或 `id`）来执行任意命令。触发条件包括：控制 ACTION 和 CHANNEL 环境变量，并确保脚本被触发（例如，通过无线事件机制）。潜在利用方式包括权限提升（如果脚本以 root 权限运行）或系统破坏。漏洞源于缺少输入验证和 sanitization。
- **代码片段：**
  ```
  for chan in \`echo $CHANNEL | sed 's/,/ /g'\`; do
  ```
- **关键词：** ACTION, CHANNEL, /usr/sbin/radardetect, /usr/sbin/radardetect_cli
- **备注：** 漏洞可直接从代码中验证，但完整攻击链需要确认脚本的触发机制和执行特权（例如，是否由 root 执行）。建议后续分析脚本的调用上下文（如通过 IPC 或事件系统）和 /usr/sbin/radardetect_cli 的行为以评估实际影响。关联文件可能包括调用此脚本的进程或配置。

---
### BufferOverflow-config_set

- **文件/目录路径：** `bin/config`
- **位置：** `config:0x00008760 fcn.000086cc`
- **风险评分：** 6.5
- **置信度：** 8.0
- **描述：** The 'config' binary contains a buffer overflow vulnerability in the 'set' command handler due to the use of strcpy without bounds checking. User input from the command-line argument (argv[1]) is copied directly to a stack buffer, which can be overflowed with a long input. This could potentially overwrite the return address and lead to arbitrary code execution if the stack is executable or if ROP gadgets are available. The vulnerability is triggered when a non-root user runs 'config set <long string>' with a string longer than the stack buffer size. The stack buffer is allocated with a total size of 0x60204 bytes, but the exact vulnerable buffer might be smaller, and the overflow can occur if the input exceeds the available space.
- **代码片段：**
  ```
  0x0000875c      0d00a0e1       mov r0, sp                  ; char *dest
  0x00008760      a0ffffeb       bl sym.imp.strcpy           ; char *strcpy(char *dest, const char *src)
  ```
- **关键词：** argv[1] for 'set' command, config_set function
- **备注：** The binary has permissions -rwxrwxrwx, allowing any user to execute it. Exploitability depends on the system configuration, such as stack protections and ASLR. Further analysis is needed to verify the exact buffer size and develop a reliable exploit. This finding should be prioritized for manual testing in the target environment.

---
### buffer-overflow-fcn.00000830

- **文件/目录路径：** `usr/lib/uams/uams_guest.so`
- **位置：** `uams_guest.so:0xa28 function fcn.00000830`
- **风险评分：** 6.0
- **置信度：** 7.0
- **描述：** A buffer overflow vulnerability exists in 'uams_guest.so' due to the use of strcpy with user-controlled username input without bounds checking. The vulnerability is triggered during guest authentication when the NoAuthUAM processes a username from the network. The strcpy function copies the username from a source buffer ([sp, 0x10]) to a destination buffer ([sp, 0x14]) without validating the length, allowing an attacker to overflow the stack buffer. This could corrupt adjacent stack memory, including saved registers and return addresses, potentially leading to arbitrary code execution. The attack requires the attacker to have valid login credentials and to send a crafted long username in an AFP authentication request. Constraints include the success of uam_afpserver_option call, but no length checks are evident. Exploitation could result in privilege escalation if the process runs with elevated privileges.
- **代码片段：**
  ```
  0x00000a20      10109de5       ldr r1, [sp, 0x10]
  0x00000a24      14009de5       ldr r0, [sp, 0x14]
  0x00000a28      d4feffeb       bl sym.imp.strcpy           ; char *strcpy(char *dest, const char *src)
  ```
- **关键词：** uam_afpserver_option, getpwnam, username input from network AFP authentication
- **备注：** The vulnerability is potentially exploitable but requires further analysis to confirm the exact buffer sizes and stack layout. Additional investigation into the calling context and process privileges is recommended to assess the full impact. The function fcn.00000830 is likely the login function for NoAuthUAM, based on strings like 'login noauth'. No other obvious vulnerabilities were found in this file.

---
