{"name": "Weak-Hash-Exposure-passwd.bak", "location": "passwd.bak:1", "description": "在 'passwd.bak' 文件中发现 admin 用户的密码哈希暴露，且该用户具有 UID 0（root 权限）。哈希使用弱 MD5 加密（以 $1$ 开头），易受离线暴力破解攻击。攻击者（已登录的非 root 用户）可通过以下步骤利用：1. 读取 'passwd.bak' 文件（假设文件权限不当，允许非 root 用户读取）；2. 提取 admin 的密码哈希 '$1$$iC.dUsGpxNNJGeOm1dFio/'；3. 使用工具如 John the Ripper 或 Hashcat 进行离线破解；4. 获得 admin 密码后，通过 su 或登录提升至 root 权限。触发条件包括文件可读性和哈希可破解性（取决于密码强度）。约束在于需要文件访问权限和破解时间，但 MD5 的弱加密降低了难度。潜在攻击包括权限提升和系统完全控制。", "link_identifiers": ["passwd.bak"], "code_snippet": "admin:$1$$iC.dUsGpxNNJGeOm1dFio/:0:0:root:/:/bin/sh\nnobody:*:0:0:nobody:/:/bin/sh", "risk_score": 8.0, "confidence": 9.0, "notes": "证据来自文件内容直接分析。admin 的 UID 0 和弱哈希组合构成了完整攻击链。nobody 用户 UID 为 0 但密码禁用，可能不直接相关，但建议验证文件权限（如是否全局可读）。后续应检查系统中其他敏感文件（如 /etc/passwd）的类似问题，并强化密码哈希算法（如使用 SHA-512）。", "file_path": "etc/passwd.bak"}
{"name": "BufferOverflow-http_cgi_main", "location": "httpd:0x00408130 sym.http_cgi_main", "description": "在 sym.http_cgi_main 函数中，使用 strcpy 复制用户输入数据到栈缓冲区，缺少边界检查。攻击者可以通过发送特制的 HTTP CGI 请求，包含超长字符串，溢出目标缓冲区并覆盖返回地址。具体触发条件：攻击者作为已认证用户发送恶意 HTTP POST 请求到 CGI 端点，请求中包含超长参数值。利用方式：通过精心构造的溢出载荷，控制程序执行流，实现代码执行或权限提升。漏洞位于 HTTP 请求处理链中，从网络输入到危险操作（strcpy）的数据流缺少验证。", "link_identifiers": ["g_http_file_pTypeDefault", "g_http_authUsrInfo"], "code_snippet": "0x00408130      8f998174       lw t9, -sym.imp.strcpy(gp)  ; [0x40a020:4]=0x8f998010\n0x00408134      27a400dc       addiu a0, sp, 0xdc\n0x00408138      27a5009d       addiu a1, sp, 0x9d\n0x0040813c      0320f809       jalr t9\n0x00408140      a0400000       sb zero, (v0)", "risk_score": 8.5, "confidence": 8.0, "notes": "需要进一步验证堆栈布局和偏移量，以确定精确的溢出条件。建议测试实际 HTTP 请求以确认可利用性。关联函数：sym.http_parser_main（输入解析）、sym.http_stream_fgets（输入读取）。", "file_path": "usr/bin/httpd"}
{"name": "BufferOverflow-cwmp_processConnReq", "location": "cwmp:0x0040acc4 sym.cwmp_processConnReq", "description": "漏洞发生在 sym.cwmp_processConnReq 函数处理 HTTP 请求的 Authorization 头时。函数使用类似 strcpy 的操作将解析的字段值（如 username、realm 等）复制到固定大小的栈缓冲区（如 auStack_bb4[100]）。由于没有对输入长度进行检查，攻击者可以构造超长的字段值（超过 100 字节），导致栈缓冲区溢出。溢出可能覆盖返回地址或其他关键栈数据，允许攻击者执行任意代码。触发条件：攻击者发送恶意 HTTP 请求到 cwmp 服务端口，包含超长 Authorization 头字段。利用方式：通过精心构造的溢出载荷控制 EIP，实现代码执行。该漏洞需要攻击者具有网络访问权限，但无需认证即可触发（在认证解析阶段发生）。", "link_identifiers": ["HTTP Authorization header", "auStack_bb4", "auStack_b50", "auStack_aec", "auStack_a88", "auStack_a24", "auStack_9c0", "auStack_95c", "auStack_8f8", "auStack_894"], "code_snippet": "// 关键代码片段从反编译中提取\niVar6 = (**(loc._gp + -0x7da8))(auStack_e18,\"username\");\npuVar5 = auStack_bb4;\nif (iVar6 == 0) goto code_r0x0040b2f4;\n...\ncode_r0x0040b2f4:\n    (**(loc._gp + -0x7dfc))(puVar5,auStack_e7c); // 类似 strcpy 的操作，复制 auStack_e7c 到 puVar5（如 auStack_bb4）\n// auStack_e7c 从输入解析，没有大小限制，而 puVar5 指向固定大小缓冲区（100 字节）", "risk_score": 8.5, "confidence": 9.0, "notes": "基于反编译证据，漏洞似乎实际可利用：输入点（网络套接字）、数据流（HTTP 解析）、危险操作（strcpy）均存在。建议进一步验证栈布局和偏移量以确认 EIP 控制。关联函数：sym.cwmp_getLine 可能也涉及边界检查问题。后续分析方向：检查其他 XML/SOAP 处理函数（如 sym.cwmp_hanleSoapHeader）是否存在类似漏洞。", "file_path": "usr/bin/cwmp"}
{"name": "BufferOverflow-vsf_read_only_check", "location": "vsftpd:0x41a2d8 sym.vsf_read_only_check", "description": "A buffer overflow vulnerability exists in the 'vsf_read_only_check' function due to the use of 'strcpy' on user-controlled data without bounds checking. The function defines two fixed-size stack buffers (128 bytes each) and copies input from FTP command arguments directly into these buffers using 'strcpy'. If an authenticated user provides an argument longer than 128 bytes (e.g., a file path), it will overflow the buffer, corrupting the stack and potentially allowing arbitrary code execution. The vulnerability can be triggered through multiple FTP commands, including RNFR, RNTO, DELE, and SITE CHMOD, which pass user input to 'vsf_read_only_check'. The overflow can overwrite return addresses or local variables, leading to control flow hijacking. Given the embedded nature of the target, mitigations like ASLR or stack canaries are likely absent, making exploitation feasible.", "link_identifiers": ["FTP command arguments (e.g., RNFR, RNTO, DELE, SITE CHMOD)", "vsf_read_only_check function input parameter"], "code_snippet": "uint sym.vsf_read_only_check(uint param_1,uint param_2)\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uStack_120;\n    uint uStack_11c;\n    uint uStack_118;\n    uint uStack_114;\n    uchar auStack_110 [128];\n    char acStack_90 [128];\n    \n    uStack_11c = 0;\n    uStack_118 = 0;\n    uStack_114 = 0;\n    uStack_120 = 0;\n    (**(loc._gp + -0x75d4))(auStack_110,0,0x80);\n    (**(loc._gp + -0x75d4))(acStack_90,0,0x80);\n    uVar1 = sym.str_getbuf(param_2);\n    (**(loc._gp + -0x7680))(acStack_90,uVar1);  // strcpy(acStack_90, user_input)\n    (**(loc._gp + -0x74d4))(auStack_110,0x80);\n    // ... rest of function ...\n}", "risk_score": 8.5, "confidence": 9.0, "notes": "The vulnerability is reachable via authenticated FTP sessions. The function is called from multiple points in 'process_post_login', indicating a broad attack surface. Exploitation may require crafting a payload without null bytes and overcoming potential alignment issues on MIPS. Further analysis could identify exact offset for return address overwrite and develop a reliable exploit. The vsftpd process may run with elevated privileges, leading to privilege escalation.", "file_path": "usr/bin/vsftpd"}
{"name": "BufferOverflow-DeletePortMapping", "location": "upnpd:0x406618 fcn.00406618", "description": "在 DeletePortMapping 函数 (fcn.00406618) 中，当成功删除端口映射时，代码使用 `sprintf` 将端口映射数量（来自 `pmlist_Size()`）格式化为一个仅8字节的栈缓冲区（`auStack_218`）。端口映射数量为 `uint32_t` 类型，最大值为 4294967295（10位数字加空字符需要11字节），这必然导致栈缓冲区溢出。攻击者作为已登录用户可以通过以下步骤利用：1) 使用 AddPortMapping 请求添加大量端口映射（例如，通过重复发送有效请求）；2) 发送 DeletePortMapping 请求触发删除操作，使 `pmlist_Size()` 返回大值，溢出缓冲区并可能覆盖返回地址或局部变量，从而实现任意代码执行。触发条件包括：有效的 'NewExternalPort' 和 'NewProtocol' 参数，且端口映射存在。边界检查缺失，输入未经验证直接用于格式化。", "link_identifiers": ["NewExternalPort", "NewProtocol", "PortMappingNumberOfEntries", "UPnP Action 请求", "pmlist_Size"], "code_snippet": "uVar4 = sym.pmlist_Size();\n(**(loc._gp + -0x7ed0))(auStack_218,\"%d\",uVar4);  // auStack_218 是8字节缓冲区，uVar4 是 uint32_t 整数", "risk_score": 8.5, "confidence": 8.0, "notes": "该漏洞需要攻击者能添加端口映射，但作为已登录用户这是可行的。建议进一步验证 pmlist_Size() 的实际最大值和栈布局以确认利用细节。关联函数：pmlist_Size() 和 AddPortMapping。后续分析方向：检查其他 UPnP 处理函数和网络输入点。", "file_path": "usr/bin/upnpd"}
{"location": "handle_card:0x0040cec4 (fcn.0040c740) strcpy call", "description": "A stack-based buffer overflow vulnerability exists in function fcn.0040c740 (invoked from main). The vulnerability occurs when handling the command-line option -c (usb mode switch cmd), where user-supplied input is copied to a stack buffer using strcpy without bounds checking. The buffer is allocated with size 0x101 (257 bytes) at offset fp+0x214, and strcpy copies until a null terminator, allowing overflow of the stack frame. The saved return address is at offset fp+0x24ac, requiring an overflow of approximately 8856 bytes to reach it. This can be exploited by a local attacker with valid login credentials (non-root) to overwrite the return address and execute arbitrary code with elevated privileges (likely root, as the binary handles USB operations and may run with setuid or similar).", "link_identifiers": ["argv (command-line argument -c)", "strcpy", "fcn.0040c740"], "code_snippet": "0x0040ceb4      8fc224bc       lw v0, 0x24bc(fp)          ; Load user input from -c option\n0x0040ceb8      27c30214       addiu v1, fp, 0x214         ; Destination buffer\n0x0040cebc      00602021       move a0, v1\n0x0040cec0      00402821       move a1, v0                 ; Source is user input\n0x0040cec4      8f8280d4       lw v0, -sym.imp.strcpy(gp) ; strcpy function\n0x0040cec8      0040c821       move t9, v0\n0x0040cecc      0320f809       jalr t9                     ; Call strcpy, no bounds check", "risk_score": 8.5, "confidence": 9.0, "notes": "The binary likely requires root privileges for USB operations, making this vulnerability high-impact. Exploitation depends on overcoming ASLR and stack protections, but in firmware contexts, these may be weakened. The overflow size is large but feasible with crafted input. Additional analysis of modeSwitchByCmd did not reveal direct command injection, but the buffer overflow provides a reliable exploitation path.", "file_path": "usr/sbin/handle_card"}
{"name": "BufferOverflow-pppd-sym.vslprintf", "location": "pppd:0x00422ebc (sym.vslprintf) 和 pppd:0x00421dc4 (parse_args)", "description": "在 'pppd' 的命令行参数解析过程中，存在一个栈缓冲区溢出漏洞，允许攻击者通过恶意命令行参数执行任意代码。漏洞触发流程如下：\n- **输入点**：不可信的命令行参数通过 `argv` 传入 `main` 函数，并传递给 `parse_args` 函数（地址 0x00421dc4）。\n- **数据流**：在 `parse_args` 中，参数被处理并由 `fcn.00420fa0` 进行选项解析。当选项错误时，调用 `sym.option_error` 生成错误消息。\n- **漏洞点**：`sym.option_error` 使用 `sym.vslprintf`（地址 0x00422ebc）格式化错误消息，其中污点整数（来自命令行参数）用于数字字符串格式化。在 `sym.vslprintf` 的格式化循环中，缺少对栈缓冲区 'auStack_3e' 的边界检查，导致指针 'puVar11' 递减到缓冲区之外，覆盖栈数据（如返回地址）。\n- **触发条件**：攻击者作为已登录非 root 用户执行 'pppd' 并传递特定无效选项（例如，故意触发解析错误），使污点数据进入错误处理路径。\n- **约束条件**：漏洞依赖于触发 `option_error` 路径，且污点数据必须为整数类型用于格式化。缓冲区大小未明确限制，但溢出可能受栈布局影响。\n- **潜在攻击方式**：通过精心构造命令行参数，控制溢出数据覆盖返回地址，跳转到 shellcode 或现有代码片段，实现权限提升（如果 'pppd' 以 root 权限运行，常见于网络配置）。\n- **可利用性证据**：反编译代码显示明确的缓冲区溢出条件，且命令行参数完全用户可控。漏洞在 `sym.vslprintf` 的循环中验证，缺乏边界检查。", "link_identifiers": ["argv（命令行参数）", "sym.option_error", "sym.vslprintf", "fcn.00420fa0", "parse_args"], "code_snippet": "从反汇编中提取的关键代码片段（sym.vslprintf 部分）：\n0x00422ebc: auStack_3e[1] = 0; puVar11 = auStack_3e + 1; do { if (puVar11 <= auStack_5c + iVar21) break; puVar11 = puVar11 - 1; *puVar11 = pcVar17[uVar22]; } while ((0 < puVar7) || (puVar23 != 0));\n解释：循环中 'puVar11' 指针递减，但中断条件使用无关缓冲区 'auStack_5c'，缺乏对 'auStack_3e' 的边界检查，导致栈溢出。", "risk_score": 8.5, "confidence": 8.0, "notes": "此漏洞需要进一步验证实际利用条件，例如测试特定命令行选项（如无效参数）以重现溢出。关联文件：pppd 二进制。建议后续分析：检查 'pppd' 的权限设置（是否 setuid-root）以确认权限提升可能性，并动态测试漏洞触发。其他发现（如路径遍历在 options_from_file）风险较低，因缺少完整攻击链证据。", "file_path": "usr/sbin/pppd"}
{"name": "命令注入-client6_script", "location": "dhcp6c:0x00405394 fcn.00405394 (client6_recv); dhcp6c:0x00413818,0x00414aec sym.client6_script", "description": "在 DHCPv6 客户端处理回复消息时，存在命令注入漏洞。攻击者可通过发送恶意 DHCPv6 回复消息控制选项数据（如 DNS 服务器列表），这些数据被解析后传递给 client6_script 函数，并通过环境变量在 execve 调用中执行外部脚本。具体表现：当设备接收 DHCPv6 REPLY 消息时，client6_recv 函数调用 dhcp6_get_options 解析选项，将污点选项列表传递给 client6_script；在 client6_script 中，污点数据被转换为字符串并存储到环境变量数组，最终通过 execve 执行脚本，缺少对选项内容的过滤和验证。触发条件：攻击者发送特制 DHCPv6 回复消息（例如通过中间人或控制 DHCPv6 服务器），其中选项数据包含恶意字符串。约束条件：代码有基本错误检查（如选项存在性），但未对选项内容进行安全处理；in6addr2str 函数可能限制输入格式，但若数据被误用或转换函数有缺陷，可能绕过。潜在攻击：攻击者利用此漏洞注入命令，以 root 权限执行任意代码，提升权限或控制设备。利用方式：伪造 DHCPv6 回复消息，注入恶意环境变量值。", "link_identifiers": ["recvmsg", "dhcp6_get_options", "client6_script", "execve", "环境变量", "DHCPv6 选项", "DNS 服务器列表"], "code_snippet": "从 fcn.00405394 (client6_recv) 反编译:\n0x00405538: bal sym.dhcp6_get_options  // 解析 DHCPv6 选项，污点数据存储到 aiStack_2128\n0x004064c4: bal sym.client6_script    // 调用 client6_script，传递污点选项\n从 sym.client6_script 反编译:\n0x00413818: sw a3, (arg_8ch)          // 污点数据从参数存储到栈\n0x0041383c: lw v0, 0x58(a3)           // 访问污点数据偏移 0x58 (DNS 服务器列表)\n0x00413d78: bal sym.in6addr2str       // 转换地址为字符串\n0x00413d24: sw v0, (v1)               // 存储字符串到环境变量数组\n0x00414aec: jalr t9                   // 调用 execve，使用环境变量执行脚本", "risk_score": 8.5, "confidence": 8.0, "notes": "攻击链完整且可验证：从网络输入点（DHCPv6 回复消息）到汇聚点（execve）。攻击者需能发送恶意 DHCPv6 回复消息（例如通过中间人或控制 DHCPv6 服务器），并结合登录凭据（非 root）可能提升权限。建议进一步验证 client6_script 中环境变量的构建细节和脚本行为。关联文件：dhcp6c；相关函数：dhcp6_get_options, in6addr2str。后续分析方向：检查脚本路径（obj.info_path）和环境变量使用情况。", "file_path": "usr/sbin/dhcp6c"}
